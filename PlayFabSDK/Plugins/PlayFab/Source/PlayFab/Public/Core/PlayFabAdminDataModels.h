// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#pragma once

#include "Core/PlayFabBaseModel.h"

namespace PlayFab
{
namespace AdminModels
{

	
	struct PLAYFAB_API FAbortTaskInstanceRequest : public FPlayFabBaseModel
    {
		
		// ID of a task instance that is being aborted.
		FString TaskInstanceId;
	
        FAbortTaskInstanceRequest() :
			FPlayFabBaseModel(),
			TaskInstanceId()
			{}
		
		FAbortTaskInstanceRequest(const FAbortTaskInstanceRequest& src) :
			FPlayFabBaseModel(),
			TaskInstanceId(src.TaskInstanceId)
			{}
			
		FAbortTaskInstanceRequest(const TSharedPtr<FJsonObject>& obj) : FAbortTaskInstanceRequest()
        {
            readFromValue(obj);
        }
		
		~FAbortTaskInstanceRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FActionsOnPlayersInSegmentTaskParameter : public FPlayFabBaseModel
    {
		
		// ID of the segment to perform actions on.
		FString SegmentId;
		// ID of the action to perform on each player in segment.
		FString ActionId;
	
        FActionsOnPlayersInSegmentTaskParameter() :
			FPlayFabBaseModel(),
			SegmentId(),
			ActionId()
			{}
		
		FActionsOnPlayersInSegmentTaskParameter(const FActionsOnPlayersInSegmentTaskParameter& src) :
			FPlayFabBaseModel(),
			SegmentId(src.SegmentId),
			ActionId(src.ActionId)
			{}
			
		FActionsOnPlayersInSegmentTaskParameter(const TSharedPtr<FJsonObject>& obj) : FActionsOnPlayersInSegmentTaskParameter()
        {
            readFromValue(obj);
        }
		
		~FActionsOnPlayersInSegmentTaskParameter();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FNameIdentifier : public FPlayFabBaseModel
    {
		
		// [optional] undefined
		FString Name;
		// [optional] undefined
		FString Id;
	
        FNameIdentifier() :
			FPlayFabBaseModel(),
			Name(),
			Id()
			{}
		
		FNameIdentifier(const FNameIdentifier& src) :
			FPlayFabBaseModel(),
			Name(src.Name),
			Id(src.Id)
			{}
			
		FNameIdentifier(const TSharedPtr<FJsonObject>& obj) : FNameIdentifier()
        {
            readFromValue(obj);
        }
		
		~FNameIdentifier();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum TaskInstanceStatus
	{
		TaskInstanceStatusSucceeded,
		TaskInstanceStatusStarting,
		TaskInstanceStatusInProgress,
		TaskInstanceStatusFailed,
		TaskInstanceStatusAborted,
		TaskInstanceStatusPending
	};
	
	void writeTaskInstanceStatusEnumJSON(TaskInstanceStatus enumVal, JsonWriter& writer);
	TaskInstanceStatus readTaskInstanceStatusFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FActionsOnPlayersInSegmentTaskSummary : public FPlayFabBaseModel
    {
		
		// [optional] ID of the task instance.
		FString TaskInstanceId;
		// [optional] Identifier of the task this instance belongs to.
		TSharedPtr<FNameIdentifier> TaskIdentifier;
		// UTC timestamp when the task started.
		FDateTime StartedAt;
		// [optional] UTC timestamp when the task completed.
		OptionalTime CompletedAt;
		// [optional] Current status of the task instance.
		Boxed<TaskInstanceStatus> Status;
		// [optional] Progress represented as percentage.
		OptionalDouble PercentComplete;
		// [optional] Estimated time remaining in seconds.
		OptionalDouble EstimatedSecondsRemaining;
		// [optional] If manually scheduled, ID of user who scheduled the task.
		FString ScheduledByUserId;
		// [optional] Error message for last processing attempt, if an error occured.
		FString ErrorMessage;
		// [optional] Flag indicating if the error was fatal, if false job will be retried.
		OptionalBool ErrorWasFatal;
		// [optional] Total players in segment when task was started.
		OptionalInt32 TotalPlayersInSegment;
		// [optional] Total number of players that have had the actions applied to.
		OptionalInt32 TotalPlayersProcessed;
	
        FActionsOnPlayersInSegmentTaskSummary() :
			FPlayFabBaseModel(),
			TaskInstanceId(),
			TaskIdentifier(nullptr),
			StartedAt(0),
			CompletedAt(),
			Status(),
			PercentComplete(),
			EstimatedSecondsRemaining(),
			ScheduledByUserId(),
			ErrorMessage(),
			ErrorWasFatal(),
			TotalPlayersInSegment(),
			TotalPlayersProcessed()
			{}
		
		FActionsOnPlayersInSegmentTaskSummary(const FActionsOnPlayersInSegmentTaskSummary& src) :
			FPlayFabBaseModel(),
			TaskInstanceId(src.TaskInstanceId),
			TaskIdentifier(src.TaskIdentifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.TaskIdentifier)) : nullptr),
			StartedAt(src.StartedAt),
			CompletedAt(src.CompletedAt),
			Status(src.Status),
			PercentComplete(src.PercentComplete),
			EstimatedSecondsRemaining(src.EstimatedSecondsRemaining),
			ScheduledByUserId(src.ScheduledByUserId),
			ErrorMessage(src.ErrorMessage),
			ErrorWasFatal(src.ErrorWasFatal),
			TotalPlayersInSegment(src.TotalPlayersInSegment),
			TotalPlayersProcessed(src.TotalPlayersProcessed)
			{}
			
		FActionsOnPlayersInSegmentTaskSummary(const TSharedPtr<FJsonObject>& obj) : FActionsOnPlayersInSegmentTaskSummary()
        {
            readFromValue(obj);
        }
		
		~FActionsOnPlayersInSegmentTaskSummary();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAdCampaignAttribution : public FPlayFabBaseModel
    {
		
		// [optional] Attribution network name
		FString Platform;
		// [optional] Attribution campaign identifier
		FString CampaignId;
		// UTC time stamp of attribution
		FDateTime AttributedAt;
	
        FAdCampaignAttribution() :
			FPlayFabBaseModel(),
			Platform(),
			CampaignId(),
			AttributedAt(0)
			{}
		
		FAdCampaignAttribution(const FAdCampaignAttribution& src) :
			FPlayFabBaseModel(),
			Platform(src.Platform),
			CampaignId(src.CampaignId),
			AttributedAt(src.AttributedAt)
			{}
			
		FAdCampaignAttribution(const TSharedPtr<FJsonObject>& obj) : FAdCampaignAttribution()
        {
            readFromValue(obj);
        }
		
		~FAdCampaignAttribution();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddNewsRequest : public FPlayFabBaseModel
    {
		
		// [optional] Time this news was published. If not set, defaults to now.
		OptionalTime Timestamp;
		// Title (headline) of the news item
		FString Title;
		// Body text of the news
		FString Body;
	
        FAddNewsRequest() :
			FPlayFabBaseModel(),
			Timestamp(),
			Title(),
			Body()
			{}
		
		FAddNewsRequest(const FAddNewsRequest& src) :
			FPlayFabBaseModel(),
			Timestamp(src.Timestamp),
			Title(src.Title),
			Body(src.Body)
			{}
			
		FAddNewsRequest(const TSharedPtr<FJsonObject>& obj) : FAddNewsRequest()
        {
            readFromValue(obj);
        }
		
		~FAddNewsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddNewsResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique id of the new news item
		FString NewsId;
	
        FAddNewsResult() :
			FPlayFabBaseModel(),
			NewsId()
			{}
		
		FAddNewsResult(const FAddNewsResult& src) :
			FPlayFabBaseModel(),
			NewsId(src.NewsId)
			{}
			
		FAddNewsResult(const TSharedPtr<FJsonObject>& obj) : FAddNewsResult()
        {
            readFromValue(obj);
        }
		
		~FAddNewsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddPlayerTagRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique tag for player profile.
		FString TagName;
	
        FAddPlayerTagRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			TagName()
			{}
		
		FAddPlayerTagRequest(const FAddPlayerTagRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			TagName(src.TagName)
			{}
			
		FAddPlayerTagRequest(const TSharedPtr<FJsonObject>& obj) : FAddPlayerTagRequest()
        {
            readFromValue(obj);
        }
		
		~FAddPlayerTagRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddPlayerTagResult : public FPlayFabBaseModel
    {
		
	
        FAddPlayerTagResult() :
			FPlayFabBaseModel()
			{}
		
		FAddPlayerTagResult(const FAddPlayerTagResult& src) :
			FPlayFabBaseModel()
			{}
			
		FAddPlayerTagResult(const TSharedPtr<FJsonObject>& obj) : FAddPlayerTagResult()
        {
            readFromValue(obj);
        }
		
		~FAddPlayerTagResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum Region
	{
		RegionUSCentral,
		RegionUSEast,
		RegionEUWest,
		RegionSingapore,
		RegionJapan,
		RegionBrazil,
		RegionAustralia
	};
	
	void writeRegionEnumJSON(Region enumVal, JsonWriter& writer);
	Region readRegionFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FAddServerBuildRequest : public FPlayFabBaseModel
    {
		
		// unique identifier for the build executable
		FString BuildId;
		// [optional] appended to the end of the command line when starting game servers
		FString CommandLineTemplate;
		// [optional] path to the game server executable. Defaults to gameserver.exe
		FString ExecutablePath;
		// [optional] server host regions in which this build should be running and available
		TArray<Region> ActiveRegions;
		// [optional] developer comment(s) for this build
		FString Comment;
		// maximum number of game server instances that can run on a single host machine
		int32 MaxGamesPerHost;
		// minimum capacity of additional game server instances that can be started before the autoscaling service starts new host machines (given the number of current running host machines and game server instances)
		int32 MinFreeGameSlots;
	
        FAddServerBuildRequest() :
			FPlayFabBaseModel(),
			BuildId(),
			CommandLineTemplate(),
			ExecutablePath(),
			ActiveRegions(),
			Comment(),
			MaxGamesPerHost(0),
			MinFreeGameSlots(0)
			{}
		
		FAddServerBuildRequest(const FAddServerBuildRequest& src) :
			FPlayFabBaseModel(),
			BuildId(src.BuildId),
			CommandLineTemplate(src.CommandLineTemplate),
			ExecutablePath(src.ExecutablePath),
			ActiveRegions(src.ActiveRegions),
			Comment(src.Comment),
			MaxGamesPerHost(src.MaxGamesPerHost),
			MinFreeGameSlots(src.MinFreeGameSlots)
			{}
			
		FAddServerBuildRequest(const TSharedPtr<FJsonObject>& obj) : FAddServerBuildRequest()
        {
            readFromValue(obj);
        }
		
		~FAddServerBuildRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum GameBuildStatus
	{
		GameBuildStatusAvailable,
		GameBuildStatusValidating,
		GameBuildStatusInvalidBuildPackage,
		GameBuildStatusProcessing,
		GameBuildStatusFailedToProcess
	};
	
	void writeGameBuildStatusEnumJSON(GameBuildStatus enumVal, JsonWriter& writer);
	GameBuildStatus readGameBuildStatusFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FAddServerBuildResult : public FPlayFabBaseModel
    {
		
		// [optional] unique identifier for this build executable
		FString BuildId;
		// [optional] array of regions where this build can used, when it is active
		TArray<Region> ActiveRegions;
		// maximum number of game server instances that can run on a single host machine
		int32 MaxGamesPerHost;
		// minimum capacity of additional game server instances that can be started before the autoscaling service starts new host machines (given the number of current running host machines and game server instances)
		int32 MinFreeGameSlots;
		// [optional] appended to the end of the command line when starting game servers
		FString CommandLineTemplate;
		// [optional] path to the game server executable. Defaults to gameserver.exe
		FString ExecutablePath;
		// [optional] developer comment(s) for this build
		FString Comment;
		// time this build was last modified (or uploaded, if this build has never been modified)
		FDateTime Timestamp;
		// [optional] Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// [optional] the current status of the build validation and processing steps
		Boxed<GameBuildStatus> Status;
	
        FAddServerBuildResult() :
			FPlayFabBaseModel(),
			BuildId(),
			ActiveRegions(),
			MaxGamesPerHost(0),
			MinFreeGameSlots(0),
			CommandLineTemplate(),
			ExecutablePath(),
			Comment(),
			Timestamp(0),
			TitleId(),
			Status()
			{}
		
		FAddServerBuildResult(const FAddServerBuildResult& src) :
			FPlayFabBaseModel(),
			BuildId(src.BuildId),
			ActiveRegions(src.ActiveRegions),
			MaxGamesPerHost(src.MaxGamesPerHost),
			MinFreeGameSlots(src.MinFreeGameSlots),
			CommandLineTemplate(src.CommandLineTemplate),
			ExecutablePath(src.ExecutablePath),
			Comment(src.Comment),
			Timestamp(src.Timestamp),
			TitleId(src.TitleId),
			Status(src.Status)
			{}
			
		FAddServerBuildResult(const TSharedPtr<FJsonObject>& obj) : FAddServerBuildResult()
        {
            readFromValue(obj);
        }
		
		~FAddServerBuildResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
		
		// PlayFab unique identifier of the user whose virtual currency balance is to be increased.
		FString PlayFabId;
		// Name of the virtual currency which is to be incremented.
		FString VirtualCurrency;
		// Amount to be added to the user balance of the specified virtual currency. Maximum VC balance is Int32 (2,147,483,647). Any increase over this value will be discarded.
		int32 Amount;
	
        FAddUserVirtualCurrencyRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			VirtualCurrency(),
			Amount(0)
			{}
		
		FAddUserVirtualCurrencyRequest(const FAddUserVirtualCurrencyRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			VirtualCurrency(src.VirtualCurrency),
			Amount(src.Amount)
			{}
			
		FAddUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FAddUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }
		
		~FAddUserVirtualCurrencyRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FVirtualCurrencyData : public FPlayFabBaseModel
    {
		
		// unique one- or two-character identifier for this currency type (e.g.: "CC", "G")
		FString CurrencyCode;
		// [optional] friendly name to show in the developer portal, reports, etc.
		FString DisplayName;
		// [optional] amount to automatically grant users upon first login to the title
		OptionalInt32 InitialDeposit;
		// [optional] rate at which the currency automatically be added to over time, in units per day (24 hours)
		OptionalInt32 RechargeRate;
		// [optional] maximum amount to which the currency will recharge (cannot exceed MaxAmount, but can be less)
		OptionalInt32 RechargeMax;
	
        FVirtualCurrencyData() :
			FPlayFabBaseModel(),
			CurrencyCode(),
			DisplayName(),
			InitialDeposit(),
			RechargeRate(),
			RechargeMax()
			{}
		
		FVirtualCurrencyData(const FVirtualCurrencyData& src) :
			FPlayFabBaseModel(),
			CurrencyCode(src.CurrencyCode),
			DisplayName(src.DisplayName),
			InitialDeposit(src.InitialDeposit),
			RechargeRate(src.RechargeRate),
			RechargeMax(src.RechargeMax)
			{}
			
		FVirtualCurrencyData(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyData()
        {
            readFromValue(obj);
        }
		
		~FVirtualCurrencyData();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddVirtualCurrencyTypesRequest : public FPlayFabBaseModel
    {
		
		// List of virtual currencies and their initial deposits (the amount a user is granted when signing in for the first time) to the title
		TArray<FVirtualCurrencyData> VirtualCurrencies;
	
        FAddVirtualCurrencyTypesRequest() :
			FPlayFabBaseModel(),
			VirtualCurrencies()
			{}
		
		FAddVirtualCurrencyTypesRequest(const FAddVirtualCurrencyTypesRequest& src) :
			FPlayFabBaseModel(),
			VirtualCurrencies(src.VirtualCurrencies)
			{}
			
		FAddVirtualCurrencyTypesRequest(const TSharedPtr<FJsonObject>& obj) : FAddVirtualCurrencyTypesRequest()
        {
            readFromValue(obj);
        }
		
		~FAddVirtualCurrencyTypesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FBanInfo : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] The unique Ban Id associated with this ban.
		FString BanId;
		// [optional] The IP address on which the ban was applied. May affect multiple players.
		FString IPAddress;
		// [optional] The MAC address on which the ban was applied. May affect multiple players.
		FString MACAddress;
		// [optional] The time when this ban was applied.
		OptionalTime Created;
		// [optional] The time when this ban expires. Permanent bans do not have expiration date.
		OptionalTime Expires;
		// [optional] The reason why this ban was applied.
		FString Reason;
		// The active state of this ban. Expired bans may still have this value set to true but they will have no effect.
		bool Active;
	
        FBanInfo() :
			FPlayFabBaseModel(),
			PlayFabId(),
			BanId(),
			IPAddress(),
			MACAddress(),
			Created(),
			Expires(),
			Reason(),
			Active(false)
			{}
		
		FBanInfo(const FBanInfo& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			BanId(src.BanId),
			IPAddress(src.IPAddress),
			MACAddress(src.MACAddress),
			Created(src.Created),
			Expires(src.Expires),
			Reason(src.Reason),
			Active(src.Active)
			{}
			
		FBanInfo(const TSharedPtr<FJsonObject>& obj) : FBanInfo()
        {
            readFromValue(obj);
        }
		
		~FBanInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FBanRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] IP address to be banned. May affect multiple players.
		FString IPAddress;
		// [optional] MAC address to be banned. May affect multiple players.
		FString MACAddress;
		// [optional] The reason for this ban. Maximum 140 characters.
		FString Reason;
		// [optional] The duration in hours for the ban. Leave this blank for a permanent ban.
		OptionalUint32 DurationInHours;
	
        FBanRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			IPAddress(),
			MACAddress(),
			Reason(),
			DurationInHours()
			{}
		
		FBanRequest(const FBanRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			IPAddress(src.IPAddress),
			MACAddress(src.MACAddress),
			Reason(src.Reason),
			DurationInHours(src.DurationInHours)
			{}
			
		FBanRequest(const TSharedPtr<FJsonObject>& obj) : FBanRequest()
        {
            readFromValue(obj);
        }
		
		~FBanRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FBanUsersRequest : public FPlayFabBaseModel
    {
		
		// List of ban requests to be applied. Maximum 100.
		TArray<FBanRequest> Bans;
	
        FBanUsersRequest() :
			FPlayFabBaseModel(),
			Bans()
			{}
		
		FBanUsersRequest(const FBanUsersRequest& src) :
			FPlayFabBaseModel(),
			Bans(src.Bans)
			{}
			
		FBanUsersRequest(const TSharedPtr<FJsonObject>& obj) : FBanUsersRequest()
        {
            readFromValue(obj);
        }
		
		~FBanUsersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FBanUsersResult : public FPlayFabBaseModel
    {
		
		// [optional] Information on the bans that were applied
		TArray<FBanInfo> BanData;
	
        FBanUsersResult() :
			FPlayFabBaseModel(),
			BanData()
			{}
		
		FBanUsersResult(const FBanUsersResult& src) :
			FPlayFabBaseModel(),
			BanData(src.BanData)
			{}
			
		FBanUsersResult(const TSharedPtr<FJsonObject>& obj) : FBanUsersResult()
        {
            readFromValue(obj);
        }
		
		~FBanUsersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FBlankResult : public FPlayFabBaseModel
    {
		
	
        FBlankResult() :
			FPlayFabBaseModel()
			{}
		
		FBlankResult(const FBlankResult& src) :
			FPlayFabBaseModel()
			{}
			
		FBlankResult(const TSharedPtr<FJsonObject>& obj) : FBlankResult()
        {
            readFromValue(obj);
        }
		
		~FBlankResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItemConsumableInfo : public FPlayFabBaseModel
    {
		
		// [optional] number of times this object can be used, after which it will be removed from the player inventory
		OptionalUint32 UsageCount;
		// [optional] duration in seconds for how long the item will remain in the player inventory - once elapsed, the item will be removed (recommended minimum value is 5 seconds, as lower values can cause the item to expire before operations depending on this item's details have completed)
		OptionalUint32 UsagePeriod;
		// [optional] all inventory item instances in the player inventory sharing a non-null UsagePeriodGroup have their UsagePeriod values added together, and share the result - when that period has elapsed, all the items in the group will be removed
		FString UsagePeriodGroup;
	
        FCatalogItemConsumableInfo() :
			FPlayFabBaseModel(),
			UsageCount(),
			UsagePeriod(),
			UsagePeriodGroup()
			{}
		
		FCatalogItemConsumableInfo(const FCatalogItemConsumableInfo& src) :
			FPlayFabBaseModel(),
			UsageCount(src.UsageCount),
			UsagePeriod(src.UsagePeriod),
			UsagePeriodGroup(src.UsagePeriodGroup)
			{}
			
		FCatalogItemConsumableInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemConsumableInfo()
        {
            readFromValue(obj);
        }
		
		~FCatalogItemConsumableInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItemContainerInfo : public FPlayFabBaseModel
    {
		
		// [optional] ItemId for the catalog item used to unlock the container, if any (if not specified, a call to UnlockContainerItem will open the container, adding the contents to the player inventory and currency balances)
		FString KeyItemId;
		// [optional] unique ItemId values for all items which will be added to the player inventory, once the container has been unlocked
		TArray<FString> ItemContents;
		// [optional] unique TableId values for all RandomResultTable objects which are part of the container (once unlocked, random tables will be resolved and add the relevant items to the player inventory)
		TArray<FString> ResultTableContents;
		// [optional] virtual currency types and balances which will be added to the player inventory when the container is unlocked
		TMap<FString, uint32> VirtualCurrencyContents;
	
        FCatalogItemContainerInfo() :
			FPlayFabBaseModel(),
			KeyItemId(),
			ItemContents(),
			ResultTableContents(),
			VirtualCurrencyContents()
			{}
		
		FCatalogItemContainerInfo(const FCatalogItemContainerInfo& src) :
			FPlayFabBaseModel(),
			KeyItemId(src.KeyItemId),
			ItemContents(src.ItemContents),
			ResultTableContents(src.ResultTableContents),
			VirtualCurrencyContents(src.VirtualCurrencyContents)
			{}
			
		FCatalogItemContainerInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemContainerInfo()
        {
            readFromValue(obj);
        }
		
		~FCatalogItemContainerInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItemBundleInfo : public FPlayFabBaseModel
    {
		
		// [optional] unique ItemId values for all items which will be added to the player inventory when the bundle is added
		TArray<FString> BundledItems;
		// [optional] unique TableId values for all RandomResultTable objects which are part of the bundle (random tables will be resolved and add the relevant items to the player inventory when the bundle is added)
		TArray<FString> BundledResultTables;
		// [optional] virtual currency types and balances which will be added to the player inventory when the bundle is added
		TMap<FString, uint32> BundledVirtualCurrencies;
	
        FCatalogItemBundleInfo() :
			FPlayFabBaseModel(),
			BundledItems(),
			BundledResultTables(),
			BundledVirtualCurrencies()
			{}
		
		FCatalogItemBundleInfo(const FCatalogItemBundleInfo& src) :
			FPlayFabBaseModel(),
			BundledItems(src.BundledItems),
			BundledResultTables(src.BundledResultTables),
			BundledVirtualCurrencies(src.BundledVirtualCurrencies)
			{}
			
		FCatalogItemBundleInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemBundleInfo()
        {
            readFromValue(obj);
        }
		
		~FCatalogItemBundleInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItem : public FPlayFabBaseModel
    {
		
		// unique identifier for this item
		FString ItemId;
		// [optional] class to which the item belongs
		FString ItemClass;
		// [optional] catalog version for this item
		FString CatalogVersion;
		// [optional] text name for the item, to show in-game
		FString DisplayName;
		// [optional] text description of item, to show in-game
		FString Description;
		// [optional] price of this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
		TMap<FString, uint32> VirtualCurrencyPrices;
		// [optional] override prices for this item for specific currencies
		TMap<FString, uint32> RealCurrencyPrices;
		// [optional] list of item tags
		TArray<FString> Tags;
		// [optional] game specific custom data
		FString CustomData;
		// [optional] defines the consumable properties (number of uses, timeout) for the item
		TSharedPtr<FCatalogItemConsumableInfo> Consumable;
		// [optional] defines the container properties for the item - what items it contains, including random drop tables and virtual currencies, and what item (if any) is required to open it via the UnlockContainerItem API
		TSharedPtr<FCatalogItemContainerInfo> Container;
		// [optional] defines the bundle properties for the item - bundles are items which contain other items, including random drop tables and virtual currencies
		TSharedPtr<FCatalogItemBundleInfo> Bundle;
		// if true, then an item instance of this type can be used to grant a character to a user.
		bool CanBecomeCharacter;
		// if true, then only one item instance of this type will exist and its remaininguses will be incremented instead. RemainingUses will cap out at Int32.Max (2,147,483,647). All subsequent increases will be discarded
		bool IsStackable;
		// if true, then an item instance of this type can be traded between players using the trading APIs
		bool IsTradable;
		// [optional] URL to the item image. For Facebook purchase to display the image on the item purchase page, this must be set to an HTTP URL.
		FString ItemImageUrl;
		// BETA: If true, then only a fixed number can ever be granted.
		bool IsLimitedEdition;
		// If the item has IsLImitedEdition set to true, and this is the first time this ItemId has been defined as a limited edition item, this value determines the total number of instances to allocate for the title. Once this limit has been reached, no more instances of this ItemId can be created, and attempts to purchase or grant it will return a Result of false for that ItemId. If the item has already been defined to have a limited edition count, or if this value is less than zero, it will be ignored.
		int32 InitialLimitedEditionCount;
	
        FCatalogItem() :
			FPlayFabBaseModel(),
			ItemId(),
			ItemClass(),
			CatalogVersion(),
			DisplayName(),
			Description(),
			VirtualCurrencyPrices(),
			RealCurrencyPrices(),
			Tags(),
			CustomData(),
			Consumable(nullptr),
			Container(nullptr),
			Bundle(nullptr),
			CanBecomeCharacter(false),
			IsStackable(false),
			IsTradable(false),
			ItemImageUrl(),
			IsLimitedEdition(false),
			InitialLimitedEditionCount(0)
			{}
		
		FCatalogItem(const FCatalogItem& src) :
			FPlayFabBaseModel(),
			ItemId(src.ItemId),
			ItemClass(src.ItemClass),
			CatalogVersion(src.CatalogVersion),
			DisplayName(src.DisplayName),
			Description(src.Description),
			VirtualCurrencyPrices(src.VirtualCurrencyPrices),
			RealCurrencyPrices(src.RealCurrencyPrices),
			Tags(src.Tags),
			CustomData(src.CustomData),
			Consumable(src.Consumable.IsValid() ? MakeShareable(new FCatalogItemConsumableInfo(*src.Consumable)) : nullptr),
			Container(src.Container.IsValid() ? MakeShareable(new FCatalogItemContainerInfo(*src.Container)) : nullptr),
			Bundle(src.Bundle.IsValid() ? MakeShareable(new FCatalogItemBundleInfo(*src.Bundle)) : nullptr),
			CanBecomeCharacter(src.CanBecomeCharacter),
			IsStackable(src.IsStackable),
			IsTradable(src.IsTradable),
			ItemImageUrl(src.ItemImageUrl),
			IsLimitedEdition(src.IsLimitedEdition),
			InitialLimitedEditionCount(src.InitialLimitedEditionCount)
			{}
			
		FCatalogItem(const TSharedPtr<FJsonObject>& obj) : FCatalogItem()
        {
            readFromValue(obj);
        }
		
		~FCatalogItem();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCloudScriptFile : public FPlayFabBaseModel
    {
		
		// Name of the javascript file. These names are not used internally by the server, they are only for developer organizational purposes.
		FString Filename;
		// Contents of the Cloud Script javascript. Must be string-escaped javascript.
		FString FileContents;
	
        FCloudScriptFile() :
			FPlayFabBaseModel(),
			Filename(),
			FileContents()
			{}
		
		FCloudScriptFile(const FCloudScriptFile& src) :
			FPlayFabBaseModel(),
			Filename(src.Filename),
			FileContents(src.FileContents)
			{}
			
		FCloudScriptFile(const TSharedPtr<FJsonObject>& obj) : FCloudScriptFile()
        {
            readFromValue(obj);
        }
		
		~FCloudScriptFile();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCloudScriptTaskParameter : public FPlayFabBaseModel
    {
		
		// [optional] Name of the CloudScript function to execute.
		FString FunctionName;
		// [optional] Argument to pass to the CloudScript function.
		FMultitypeVar Argument;
	
        FCloudScriptTaskParameter() :
			FPlayFabBaseModel(),
			FunctionName(),
			Argument()
			{}
		
		FCloudScriptTaskParameter(const FCloudScriptTaskParameter& src) :
			FPlayFabBaseModel(),
			FunctionName(src.FunctionName),
			Argument(src.Argument)
			{}
			
		FCloudScriptTaskParameter(const TSharedPtr<FJsonObject>& obj) : FCloudScriptTaskParameter()
        {
            readFromValue(obj);
        }
		
		~FCloudScriptTaskParameter();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLogStatement : public FPlayFabBaseModel
    {
		
		// [optional] 'Debug', 'Info', or 'Error'
		FString Level;
		// [optional] undefined
		FString Message;
		// [optional] Optional object accompanying the message as contextual information
		FMultitypeVar Data;
	
        FLogStatement() :
			FPlayFabBaseModel(),
			Level(),
			Message(),
			Data()
			{}
		
		FLogStatement(const FLogStatement& src) :
			FPlayFabBaseModel(),
			Level(src.Level),
			Message(src.Message),
			Data(src.Data)
			{}
			
		FLogStatement(const TSharedPtr<FJsonObject>& obj) : FLogStatement()
        {
            readFromValue(obj);
        }
		
		~FLogStatement();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FScriptExecutionError : public FPlayFabBaseModel
    {
		
		// [optional] Error code, such as CloudScriptNotFound, JavascriptException, CloudScriptFunctionArgumentSizeExceeded, CloudScriptAPIRequestCountExceeded, CloudScriptAPIRequestError, or CloudScriptHTTPRequestError
		FString Error;
		// [optional] Details about the error
		FString Message;
		// [optional] Point during the execution of the script at which the error occurred, if any
		FString StackTrace;
	
        FScriptExecutionError() :
			FPlayFabBaseModel(),
			Error(),
			Message(),
			StackTrace()
			{}
		
		FScriptExecutionError(const FScriptExecutionError& src) :
			FPlayFabBaseModel(),
			Error(src.Error),
			Message(src.Message),
			StackTrace(src.StackTrace)
			{}
			
		FScriptExecutionError(const TSharedPtr<FJsonObject>& obj) : FScriptExecutionError()
        {
            readFromValue(obj);
        }
		
		~FScriptExecutionError();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FExecuteCloudScriptResult : public FPlayFabBaseModel
    {
		
		// [optional] The name of the function that executed
		FString FunctionName;
		// The revision of the CloudScript that executed
		int32 Revision;
		// [optional] The object returned from the CloudScript function, if any
		FMultitypeVar FunctionResult;
		// [optional] Entries logged during the function execution. These include both entries logged in the function code using log.info() and log.error() and error entries for API and HTTP request failures.
		TArray<FLogStatement> Logs;
		// undefined
		double ExecutionTimeSeconds;
		// Processor time consumed while executing the function. This does not include time spent waiting on API calls or HTTP requests.
		double ProcessorTimeSeconds;
		// undefined
		uint32 MemoryConsumedBytes;
		// Number of PlayFab API requests issued by the CloudScript function
		int32 APIRequestsIssued;
		// Number of external HTTP requests issued by the CloudScript function
		int32 HttpRequestsIssued;
		// [optional] Information about the error, if any, that occured during execution
		TSharedPtr<FScriptExecutionError> Error;
	
        FExecuteCloudScriptResult() :
			FPlayFabBaseModel(),
			FunctionName(),
			Revision(0),
			FunctionResult(),
			Logs(),
			ExecutionTimeSeconds(0),
			ProcessorTimeSeconds(0),
			MemoryConsumedBytes(0),
			APIRequestsIssued(0),
			HttpRequestsIssued(0),
			Error(nullptr)
			{}
		
		FExecuteCloudScriptResult(const FExecuteCloudScriptResult& src) :
			FPlayFabBaseModel(),
			FunctionName(src.FunctionName),
			Revision(src.Revision),
			FunctionResult(src.FunctionResult),
			Logs(src.Logs),
			ExecutionTimeSeconds(src.ExecutionTimeSeconds),
			ProcessorTimeSeconds(src.ProcessorTimeSeconds),
			MemoryConsumedBytes(src.MemoryConsumedBytes),
			APIRequestsIssued(src.APIRequestsIssued),
			HttpRequestsIssued(src.HttpRequestsIssued),
			Error(src.Error.IsValid() ? MakeShareable(new FScriptExecutionError(*src.Error)) : nullptr)
			{}
			
		FExecuteCloudScriptResult(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptResult()
        {
            readFromValue(obj);
        }
		
		~FExecuteCloudScriptResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCloudScriptTaskSummary : public FPlayFabBaseModel
    {
		
		// [optional] ID of the task instance.
		FString TaskInstanceId;
		// [optional] Identifier of the task this instance belongs to.
		TSharedPtr<FNameIdentifier> TaskIdentifier;
		// UTC timestamp when the task started.
		FDateTime StartedAt;
		// [optional] UTC timestamp when the task completed.
		OptionalTime CompletedAt;
		// [optional] Current status of the task instance.
		Boxed<TaskInstanceStatus> Status;
		// [optional] Progress represented as percentage.
		OptionalDouble PercentComplete;
		// [optional] Estimated time remaining in seconds.
		OptionalDouble EstimatedSecondsRemaining;
		// [optional] If manually scheduled, ID of user who scheduled the task.
		FString ScheduledByUserId;
		// [optional] Result of CloudScript execution
		TSharedPtr<FExecuteCloudScriptResult> Result;
	
        FCloudScriptTaskSummary() :
			FPlayFabBaseModel(),
			TaskInstanceId(),
			TaskIdentifier(nullptr),
			StartedAt(0),
			CompletedAt(),
			Status(),
			PercentComplete(),
			EstimatedSecondsRemaining(),
			ScheduledByUserId(),
			Result(nullptr)
			{}
		
		FCloudScriptTaskSummary(const FCloudScriptTaskSummary& src) :
			FPlayFabBaseModel(),
			TaskInstanceId(src.TaskInstanceId),
			TaskIdentifier(src.TaskIdentifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.TaskIdentifier)) : nullptr),
			StartedAt(src.StartedAt),
			CompletedAt(src.CompletedAt),
			Status(src.Status),
			PercentComplete(src.PercentComplete),
			EstimatedSecondsRemaining(src.EstimatedSecondsRemaining),
			ScheduledByUserId(src.ScheduledByUserId),
			Result(src.Result.IsValid() ? MakeShareable(new FExecuteCloudScriptResult(*src.Result)) : nullptr)
			{}
			
		FCloudScriptTaskSummary(const TSharedPtr<FJsonObject>& obj) : FCloudScriptTaskSummary()
        {
            readFromValue(obj);
        }
		
		~FCloudScriptTaskSummary();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCloudScriptVersionStatus : public FPlayFabBaseModel
    {
		
		// Version number
		int32 Version;
		// Published code revision for this Cloud Script version
		int32 PublishedRevision;
		// Most recent revision for this Cloud Script version
		int32 LatestRevision;
	
        FCloudScriptVersionStatus() :
			FPlayFabBaseModel(),
			Version(0),
			PublishedRevision(0),
			LatestRevision(0)
			{}
		
		FCloudScriptVersionStatus(const FCloudScriptVersionStatus& src) :
			FPlayFabBaseModel(),
			Version(src.Version),
			PublishedRevision(src.PublishedRevision),
			LatestRevision(src.LatestRevision)
			{}
			
		FCloudScriptVersionStatus(const TSharedPtr<FJsonObject>& obj) : FCloudScriptVersionStatus()
        {
            readFromValue(obj);
        }
		
		~FCloudScriptVersionStatus();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FContentInfo : public FPlayFabBaseModel
    {
		
		// [optional] Key of the content
		FString Key;
		// Size of the content in bytes
		uint32 Size;
		// Last modified time
		FDateTime LastModified;
	
        FContentInfo() :
			FPlayFabBaseModel(),
			Key(),
			Size(0),
			LastModified(0)
			{}
		
		FContentInfo(const FContentInfo& src) :
			FPlayFabBaseModel(),
			Key(src.Key),
			Size(src.Size),
			LastModified(src.LastModified)
			{}
			
		FContentInfo(const TSharedPtr<FJsonObject>& obj) : FContentInfo()
        {
            readFromValue(obj);
        }
		
		~FContentInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum ContinentCode
	{
		ContinentCodeAF,
		ContinentCodeAN,
		ContinentCodeAS,
		ContinentCodeEU,
		ContinentCodeNA,
		ContinentCodeOC,
		ContinentCodeSA
	};
	
	void writeContinentCodeEnumJSON(ContinentCode enumVal, JsonWriter& writer);
	ContinentCode readContinentCodeFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	enum CountryCode
	{
		CountryCodeAF,
		CountryCodeAX,
		CountryCodeAL,
		CountryCodeDZ,
		CountryCodeAS,
		CountryCodeAD,
		CountryCodeAO,
		CountryCodeAI,
		CountryCodeAQ,
		CountryCodeAG,
		CountryCodeAR,
		CountryCodeAM,
		CountryCodeAW,
		CountryCodeAU,
		CountryCodeAT,
		CountryCodeAZ,
		CountryCodeBS,
		CountryCodeBH,
		CountryCodeBD,
		CountryCodeBB,
		CountryCodeBY,
		CountryCodeBE,
		CountryCodeBZ,
		CountryCodeBJ,
		CountryCodeBM,
		CountryCodeBT,
		CountryCodeBO,
		CountryCodeBQ,
		CountryCodeBA,
		CountryCodeBW,
		CountryCodeBV,
		CountryCodeBR,
		CountryCodeIO,
		CountryCodeBN,
		CountryCodeBG,
		CountryCodeBF,
		CountryCodeBI,
		CountryCodeKH,
		CountryCodeCM,
		CountryCodeCA,
		CountryCodeCV,
		CountryCodeKY,
		CountryCodeCF,
		CountryCodeTD,
		CountryCodeCL,
		CountryCodeCN,
		CountryCodeCX,
		CountryCodeCC,
		CountryCodeCO,
		CountryCodeKM,
		CountryCodeCG,
		CountryCodeCD,
		CountryCodeCK,
		CountryCodeCR,
		CountryCodeCI,
		CountryCodeHR,
		CountryCodeCU,
		CountryCodeCW,
		CountryCodeCY,
		CountryCodeCZ,
		CountryCodeDK,
		CountryCodeDJ,
		CountryCodeDM,
		CountryCodeDO,
		CountryCodeEC,
		CountryCodeEG,
		CountryCodeSV,
		CountryCodeGQ,
		CountryCodeER,
		CountryCodeEE,
		CountryCodeET,
		CountryCodeFK,
		CountryCodeFO,
		CountryCodeFJ,
		CountryCodeFI,
		CountryCodeFR,
		CountryCodeGF,
		CountryCodePF,
		CountryCodeTF,
		CountryCodeGA,
		CountryCodeGM,
		CountryCodeGE,
		CountryCodeDE,
		CountryCodeGH,
		CountryCodeGI,
		CountryCodeGR,
		CountryCodeGL,
		CountryCodeGD,
		CountryCodeGP,
		CountryCodeGU,
		CountryCodeGT,
		CountryCodeGG,
		CountryCodeGN,
		CountryCodeGW,
		CountryCodeGY,
		CountryCodeHT,
		CountryCodeHM,
		CountryCodeVA,
		CountryCodeHN,
		CountryCodeHK,
		CountryCodeHU,
		CountryCodeIS,
		CountryCodeIN,
		CountryCodeID,
		CountryCodeIR,
		CountryCodeIQ,
		CountryCodeIE,
		CountryCodeIM,
		CountryCodeIL,
		CountryCodeIT,
		CountryCodeJM,
		CountryCodeJP,
		CountryCodeJE,
		CountryCodeJO,
		CountryCodeKZ,
		CountryCodeKE,
		CountryCodeKI,
		CountryCodeKP,
		CountryCodeKR,
		CountryCodeKW,
		CountryCodeKG,
		CountryCodeLA,
		CountryCodeLV,
		CountryCodeLB,
		CountryCodeLS,
		CountryCodeLR,
		CountryCodeLY,
		CountryCodeLI,
		CountryCodeLT,
		CountryCodeLU,
		CountryCodeMO,
		CountryCodeMK,
		CountryCodeMG,
		CountryCodeMW,
		CountryCodeMY,
		CountryCodeMV,
		CountryCodeML,
		CountryCodeMT,
		CountryCodeMH,
		CountryCodeMQ,
		CountryCodeMR,
		CountryCodeMU,
		CountryCodeYT,
		CountryCodeMX,
		CountryCodeFM,
		CountryCodeMD,
		CountryCodeMC,
		CountryCodeMN,
		CountryCodeME,
		CountryCodeMS,
		CountryCodeMA,
		CountryCodeMZ,
		CountryCodeMM,
		CountryCodeNA,
		CountryCodeNR,
		CountryCodeNP,
		CountryCodeNL,
		CountryCodeNC,
		CountryCodeNZ,
		CountryCodeNI,
		CountryCodeNE,
		CountryCodeNG,
		CountryCodeNU,
		CountryCodeNF,
		CountryCodeMP,
		CountryCodeNO,
		CountryCodeOM,
		CountryCodePK,
		CountryCodePW,
		CountryCodePS,
		CountryCodePA,
		CountryCodePG,
		CountryCodePY,
		CountryCodePE,
		CountryCodePH,
		CountryCodePN,
		CountryCodePL,
		CountryCodePT,
		CountryCodePR,
		CountryCodeQA,
		CountryCodeRE,
		CountryCodeRO,
		CountryCodeRU,
		CountryCodeRW,
		CountryCodeBL,
		CountryCodeSH,
		CountryCodeKN,
		CountryCodeLC,
		CountryCodeMF,
		CountryCodePM,
		CountryCodeVC,
		CountryCodeWS,
		CountryCodeSM,
		CountryCodeST,
		CountryCodeSA,
		CountryCodeSN,
		CountryCodeRS,
		CountryCodeSC,
		CountryCodeSL,
		CountryCodeSG,
		CountryCodeSX,
		CountryCodeSK,
		CountryCodeSI,
		CountryCodeSB,
		CountryCodeSO,
		CountryCodeZA,
		CountryCodeGS,
		CountryCodeSS,
		CountryCodeES,
		CountryCodeLK,
		CountryCodeSD,
		CountryCodeSR,
		CountryCodeSJ,
		CountryCodeSZ,
		CountryCodeSE,
		CountryCodeCH,
		CountryCodeSY,
		CountryCodeTW,
		CountryCodeTJ,
		CountryCodeTZ,
		CountryCodeTH,
		CountryCodeTL,
		CountryCodeTG,
		CountryCodeTK,
		CountryCodeTO,
		CountryCodeTT,
		CountryCodeTN,
		CountryCodeTR,
		CountryCodeTM,
		CountryCodeTC,
		CountryCodeTV,
		CountryCodeUG,
		CountryCodeUA,
		CountryCodeAE,
		CountryCodeGB,
		CountryCodeUS,
		CountryCodeUM,
		CountryCodeUY,
		CountryCodeUZ,
		CountryCodeVU,
		CountryCodeVE,
		CountryCodeVN,
		CountryCodeVG,
		CountryCodeVI,
		CountryCodeWF,
		CountryCodeEH,
		CountryCodeYE,
		CountryCodeZM,
		CountryCodeZW
	};
	
	void writeCountryCodeEnumJSON(CountryCode enumVal, JsonWriter& writer);
	CountryCode readCountryCodeFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FCreateActionsOnPlayerSegmentTaskRequest : public FPlayFabBaseModel
    {
		
		// Name of the task. This is a unique identifier for tasks in the title.
		FString Name;
		// [optional] Description the task
		FString Description;
		// [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
		FString Schedule;
		// Whether the schedule is active. Inactive schedule will not trigger task execution.
		bool IsActive;
		// Task details related to segment and action
		FActionsOnPlayersInSegmentTaskParameter Parameter;
	
        FCreateActionsOnPlayerSegmentTaskRequest() :
			FPlayFabBaseModel(),
			Name(),
			Description(),
			Schedule(),
			IsActive(false),
			Parameter()
			{}
		
		FCreateActionsOnPlayerSegmentTaskRequest(const FCreateActionsOnPlayerSegmentTaskRequest& src) :
			FPlayFabBaseModel(),
			Name(src.Name),
			Description(src.Description),
			Schedule(src.Schedule),
			IsActive(src.IsActive),
			Parameter(src.Parameter)
			{}
			
		FCreateActionsOnPlayerSegmentTaskRequest(const TSharedPtr<FJsonObject>& obj) : FCreateActionsOnPlayerSegmentTaskRequest()
        {
            readFromValue(obj);
        }
		
		~FCreateActionsOnPlayerSegmentTaskRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCreateCloudScriptTaskRequest : public FPlayFabBaseModel
    {
		
		// Name of the task. This is a unique identifier for tasks in the title.
		FString Name;
		// [optional] Description the task
		FString Description;
		// [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
		FString Schedule;
		// Whether the schedule is active. Inactive schedule will not trigger task execution.
		bool IsActive;
		// Task details related to CloudScript
		FCloudScriptTaskParameter Parameter;
	
        FCreateCloudScriptTaskRequest() :
			FPlayFabBaseModel(),
			Name(),
			Description(),
			Schedule(),
			IsActive(false),
			Parameter()
			{}
		
		FCreateCloudScriptTaskRequest(const FCreateCloudScriptTaskRequest& src) :
			FPlayFabBaseModel(),
			Name(src.Name),
			Description(src.Description),
			Schedule(src.Schedule),
			IsActive(src.IsActive),
			Parameter(src.Parameter)
			{}
			
		FCreateCloudScriptTaskRequest(const TSharedPtr<FJsonObject>& obj) : FCreateCloudScriptTaskRequest()
        {
            readFromValue(obj);
        }
		
		~FCreateCloudScriptTaskRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum StatisticResetIntervalOption
	{
		StatisticResetIntervalOptionNever,
		StatisticResetIntervalOptionHour,
		StatisticResetIntervalOptionDay,
		StatisticResetIntervalOptionWeek,
		StatisticResetIntervalOptionMonth
	};
	
	void writeStatisticResetIntervalOptionEnumJSON(StatisticResetIntervalOption enumVal, JsonWriter& writer);
	StatisticResetIntervalOption readStatisticResetIntervalOptionFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	enum StatisticAggregationMethod
	{
		StatisticAggregationMethodLast,
		StatisticAggregationMethodMin,
		StatisticAggregationMethodMax,
		StatisticAggregationMethodSum
	};
	
	void writeStatisticAggregationMethodEnumJSON(StatisticAggregationMethod enumVal, JsonWriter& writer);
	StatisticAggregationMethod readStatisticAggregationMethodFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FCreatePlayerStatisticDefinitionRequest : public FPlayFabBaseModel
    {
		
		// unique name of the statistic
		FString StatisticName;
		// [optional] interval at which the values of the statistic for all players are reset (resets begin at the next interval boundary)
		Boxed<StatisticResetIntervalOption> VersionChangeInterval;
		// [optional] the aggregation method to use in updating the statistic (defaults to last)
		Boxed<StatisticAggregationMethod> AggregationMethod;
	
        FCreatePlayerStatisticDefinitionRequest() :
			FPlayFabBaseModel(),
			StatisticName(),
			VersionChangeInterval(),
			AggregationMethod()
			{}
		
		FCreatePlayerStatisticDefinitionRequest(const FCreatePlayerStatisticDefinitionRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			VersionChangeInterval(src.VersionChangeInterval),
			AggregationMethod(src.AggregationMethod)
			{}
			
		FCreatePlayerStatisticDefinitionRequest(const TSharedPtr<FJsonObject>& obj) : FCreatePlayerStatisticDefinitionRequest()
        {
            readFromValue(obj);
        }
		
		~FCreatePlayerStatisticDefinitionRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPlayerStatisticDefinition : public FPlayFabBaseModel
    {
		
		// [optional] unique name of the statistic
		FString StatisticName;
		// current active version of the statistic, incremented each time the statistic resets
		uint32 CurrentVersion;
		// [optional] interval at which the values of the statistic for all players are reset automatically
		Boxed<StatisticResetIntervalOption> VersionChangeInterval;
		// [optional] the aggregation method to use in updating the statistic (defaults to last)
		Boxed<StatisticAggregationMethod> AggregationMethod;
	
        FPlayerStatisticDefinition() :
			FPlayFabBaseModel(),
			StatisticName(),
			CurrentVersion(0),
			VersionChangeInterval(),
			AggregationMethod()
			{}
		
		FPlayerStatisticDefinition(const FPlayerStatisticDefinition& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			CurrentVersion(src.CurrentVersion),
			VersionChangeInterval(src.VersionChangeInterval),
			AggregationMethod(src.AggregationMethod)
			{}
			
		FPlayerStatisticDefinition(const TSharedPtr<FJsonObject>& obj) : FPlayerStatisticDefinition()
        {
            readFromValue(obj);
        }
		
		~FPlayerStatisticDefinition();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCreatePlayerStatisticDefinitionResult : public FPlayFabBaseModel
    {
		
		// [optional] created statistic definition
		TSharedPtr<FPlayerStatisticDefinition> Statistic;
	
        FCreatePlayerStatisticDefinitionResult() :
			FPlayFabBaseModel(),
			Statistic(nullptr)
			{}
		
		FCreatePlayerStatisticDefinitionResult(const FCreatePlayerStatisticDefinitionResult& src) :
			FPlayFabBaseModel(),
			Statistic(src.Statistic.IsValid() ? MakeShareable(new FPlayerStatisticDefinition(*src.Statistic)) : nullptr)
			{}
			
		FCreatePlayerStatisticDefinitionResult(const TSharedPtr<FJsonObject>& obj) : FCreatePlayerStatisticDefinitionResult()
        {
            readFromValue(obj);
        }
		
		~FCreatePlayerStatisticDefinitionResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCreateTaskResult : public FPlayFabBaseModel
    {
		
		// [optional] ID of the task
		FString TaskId;
	
        FCreateTaskResult() :
			FPlayFabBaseModel(),
			TaskId()
			{}
		
		FCreateTaskResult(const FCreateTaskResult& src) :
			FPlayFabBaseModel(),
			TaskId(src.TaskId)
			{}
			
		FCreateTaskResult(const TSharedPtr<FJsonObject>& obj) : FCreateTaskResult()
        {
            readFromValue(obj);
        }
		
		~FCreateTaskResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum Currency
	{
		CurrencyAED,
		CurrencyAFN,
		CurrencyALL,
		CurrencyAMD,
		CurrencyANG,
		CurrencyAOA,
		CurrencyARS,
		CurrencyAUD,
		CurrencyAWG,
		CurrencyAZN,
		CurrencyBAM,
		CurrencyBBD,
		CurrencyBDT,
		CurrencyBGN,
		CurrencyBHD,
		CurrencyBIF,
		CurrencyBMD,
		CurrencyBND,
		CurrencyBOB,
		CurrencyBRL,
		CurrencyBSD,
		CurrencyBTN,
		CurrencyBWP,
		CurrencyBYR,
		CurrencyBZD,
		CurrencyCAD,
		CurrencyCDF,
		CurrencyCHF,
		CurrencyCLP,
		CurrencyCNY,
		CurrencyCOP,
		CurrencyCRC,
		CurrencyCUC,
		CurrencyCUP,
		CurrencyCVE,
		CurrencyCZK,
		CurrencyDJF,
		CurrencyDKK,
		CurrencyDOP,
		CurrencyDZD,
		CurrencyEGP,
		CurrencyERN,
		CurrencyETB,
		CurrencyEUR,
		CurrencyFJD,
		CurrencyFKP,
		CurrencyGBP,
		CurrencyGEL,
		CurrencyGGP,
		CurrencyGHS,
		CurrencyGIP,
		CurrencyGMD,
		CurrencyGNF,
		CurrencyGTQ,
		CurrencyGYD,
		CurrencyHKD,
		CurrencyHNL,
		CurrencyHRK,
		CurrencyHTG,
		CurrencyHUF,
		CurrencyIDR,
		CurrencyILS,
		CurrencyIMP,
		CurrencyINR,
		CurrencyIQD,
		CurrencyIRR,
		CurrencyISK,
		CurrencyJEP,
		CurrencyJMD,
		CurrencyJOD,
		CurrencyJPY,
		CurrencyKES,
		CurrencyKGS,
		CurrencyKHR,
		CurrencyKMF,
		CurrencyKPW,
		CurrencyKRW,
		CurrencyKWD,
		CurrencyKYD,
		CurrencyKZT,
		CurrencyLAK,
		CurrencyLBP,
		CurrencyLKR,
		CurrencyLRD,
		CurrencyLSL,
		CurrencyLYD,
		CurrencyMAD,
		CurrencyMDL,
		CurrencyMGA,
		CurrencyMKD,
		CurrencyMMK,
		CurrencyMNT,
		CurrencyMOP,
		CurrencyMRO,
		CurrencyMUR,
		CurrencyMVR,
		CurrencyMWK,
		CurrencyMXN,
		CurrencyMYR,
		CurrencyMZN,
		CurrencyNAD,
		CurrencyNGN,
		CurrencyNIO,
		CurrencyNOK,
		CurrencyNPR,
		CurrencyNZD,
		CurrencyOMR,
		CurrencyPAB,
		CurrencyPEN,
		CurrencyPGK,
		CurrencyPHP,
		CurrencyPKR,
		CurrencyPLN,
		CurrencyPYG,
		CurrencyQAR,
		CurrencyRON,
		CurrencyRSD,
		CurrencyRUB,
		CurrencyRWF,
		CurrencySAR,
		CurrencySBD,
		CurrencySCR,
		CurrencySDG,
		CurrencySEK,
		CurrencySGD,
		CurrencySHP,
		CurrencySLL,
		CurrencySOS,
		CurrencySPL,
		CurrencySRD,
		CurrencySTD,
		CurrencySVC,
		CurrencySYP,
		CurrencySZL,
		CurrencyTHB,
		CurrencyTJS,
		CurrencyTMT,
		CurrencyTND,
		CurrencyTOP,
		CurrencyTRY,
		CurrencyTTD,
		CurrencyTVD,
		CurrencyTWD,
		CurrencyTZS,
		CurrencyUAH,
		CurrencyUGX,
		CurrencyUSD,
		CurrencyUYU,
		CurrencyUZS,
		CurrencyVEF,
		CurrencyVND,
		CurrencyVUV,
		CurrencyWST,
		CurrencyXAF,
		CurrencyXCD,
		CurrencyXDR,
		CurrencyXOF,
		CurrencyXPF,
		CurrencyYER,
		CurrencyZAR,
		CurrencyZMW,
		CurrencyZWD
	};
	
	void writeCurrencyEnumJSON(Currency enumVal, JsonWriter& writer);
	Currency readCurrencyFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FDeleteContentRequest : public FPlayFabBaseModel
    {
		
		// Key of the content item to be deleted
		FString Key;
	
        FDeleteContentRequest() :
			FPlayFabBaseModel(),
			Key()
			{}
		
		FDeleteContentRequest(const FDeleteContentRequest& src) :
			FPlayFabBaseModel(),
			Key(src.Key)
			{}
			
		FDeleteContentRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteContentRequest()
        {
            readFromValue(obj);
        }
		
		~FDeleteContentRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeleteStoreRequest : public FPlayFabBaseModel
    {
		
		// [optional] catalog version of the store to delete. If null, uses the default catalog.
		FString CatalogVersion;
		// unqiue identifier for the store which is to be deleted
		FString StoreId;
	
        FDeleteStoreRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			StoreId()
			{}
		
		FDeleteStoreRequest(const FDeleteStoreRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			StoreId(src.StoreId)
			{}
			
		FDeleteStoreRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteStoreRequest()
        {
            readFromValue(obj);
        }
		
		~FDeleteStoreRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeleteStoreResult : public FPlayFabBaseModel
    {
		
	
        FDeleteStoreResult() :
			FPlayFabBaseModel()
			{}
		
		FDeleteStoreResult(const FDeleteStoreResult& src) :
			FPlayFabBaseModel()
			{}
			
		FDeleteStoreResult(const TSharedPtr<FJsonObject>& obj) : FDeleteStoreResult()
        {
            readFromValue(obj);
        }
		
		~FDeleteStoreResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeleteTaskRequest : public FPlayFabBaseModel
    {
		
		// [optional] Specify either the task ID or the name of task to be deleted.
		TSharedPtr<FNameIdentifier> Identifier;
	
        FDeleteTaskRequest() :
			FPlayFabBaseModel(),
			Identifier(nullptr)
			{}
		
		FDeleteTaskRequest(const FDeleteTaskRequest& src) :
			FPlayFabBaseModel(),
			Identifier(src.Identifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.Identifier)) : nullptr)
			{}
			
		FDeleteTaskRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteTaskRequest()
        {
            readFromValue(obj);
        }
		
		~FDeleteTaskRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeleteUsersRequest : public FPlayFabBaseModel
    {
		
		// An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
		TArray<FString> PlayFabIds;
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
	
        FDeleteUsersRequest() :
			FPlayFabBaseModel(),
			PlayFabIds(),
			TitleId()
			{}
		
		FDeleteUsersRequest(const FDeleteUsersRequest& src) :
			FPlayFabBaseModel(),
			PlayFabIds(src.PlayFabIds),
			TitleId(src.TitleId)
			{}
			
		FDeleteUsersRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteUsersRequest()
        {
            readFromValue(obj);
        }
		
		~FDeleteUsersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeleteUsersResult : public FPlayFabBaseModel
    {
		
	
        FDeleteUsersResult() :
			FPlayFabBaseModel()
			{}
		
		FDeleteUsersResult(const FDeleteUsersResult& src) :
			FPlayFabBaseModel()
			{}
			
		FDeleteUsersResult(const TSharedPtr<FJsonObject>& obj) : FDeleteUsersResult()
        {
            readFromValue(obj);
        }
		
		~FDeleteUsersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum EffectType
	{
		EffectTypeAllow
	};
	
	void writeEffectTypeEnumJSON(EffectType enumVal, JsonWriter& writer);
	EffectType readEffectTypeFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FEmptyResult : public FPlayFabBaseModel
    {
		
	
        FEmptyResult() :
			FPlayFabBaseModel()
			{}
		
		FEmptyResult(const FEmptyResult& src) :
			FPlayFabBaseModel()
			{}
			
		FEmptyResult(const TSharedPtr<FJsonObject>& obj) : FEmptyResult()
        {
            readFromValue(obj);
        }
		
		~FEmptyResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGameModeInfo : public FPlayFabBaseModel
    {
		
		// specific game mode type
		FString Gamemode;
		// minimum user count required for this Game Server Instance to continue (usually 1)
		uint32 MinPlayerCount;
		// maximum user count a specific Game Server Instance can support
		uint32 MaxPlayerCount;
		// [optional] whether to start as an open session, meaning that players can matchmake into it (defaults to true)
		OptionalBool StartOpen;
	
        FGameModeInfo() :
			FPlayFabBaseModel(),
			Gamemode(),
			MinPlayerCount(0),
			MaxPlayerCount(0),
			StartOpen()
			{}
		
		FGameModeInfo(const FGameModeInfo& src) :
			FPlayFabBaseModel(),
			Gamemode(src.Gamemode),
			MinPlayerCount(src.MinPlayerCount),
			MaxPlayerCount(src.MaxPlayerCount),
			StartOpen(src.StartOpen)
			{}
			
		FGameModeInfo(const TSharedPtr<FJsonObject>& obj) : FGameModeInfo()
        {
            readFromValue(obj);
        }
		
		~FGameModeInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetActionGroupResult : public FPlayFabBaseModel
    {
		
		// Action Group name
		FString Name;
		// [optional] Action Group ID
		FString Id;
	
        FGetActionGroupResult() :
			FPlayFabBaseModel(),
			Name(),
			Id()
			{}
		
		FGetActionGroupResult(const FGetActionGroupResult& src) :
			FPlayFabBaseModel(),
			Name(src.Name),
			Id(src.Id)
			{}
			
		FGetActionGroupResult(const TSharedPtr<FJsonObject>& obj) : FGetActionGroupResult()
        {
            readFromValue(obj);
        }
		
		~FGetActionGroupResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetActionsOnPlayersInSegmentTaskInstanceResult : public FPlayFabBaseModel
    {
		
		// [optional] Status summary of the actions-on-players-in-segment task instance
		TSharedPtr<FActionsOnPlayersInSegmentTaskSummary> Summary;
		// [optional] Parameter of this task instance
		TSharedPtr<FActionsOnPlayersInSegmentTaskParameter> Parameter;
	
        FGetActionsOnPlayersInSegmentTaskInstanceResult() :
			FPlayFabBaseModel(),
			Summary(nullptr),
			Parameter(nullptr)
			{}
		
		FGetActionsOnPlayersInSegmentTaskInstanceResult(const FGetActionsOnPlayersInSegmentTaskInstanceResult& src) :
			FPlayFabBaseModel(),
			Summary(src.Summary.IsValid() ? MakeShareable(new FActionsOnPlayersInSegmentTaskSummary(*src.Summary)) : nullptr),
			Parameter(src.Parameter.IsValid() ? MakeShareable(new FActionsOnPlayersInSegmentTaskParameter(*src.Parameter)) : nullptr)
			{}
			
		FGetActionsOnPlayersInSegmentTaskInstanceResult(const TSharedPtr<FJsonObject>& obj) : FGetActionsOnPlayersInSegmentTaskInstanceResult()
        {
            readFromValue(obj);
        }
		
		~FGetActionsOnPlayersInSegmentTaskInstanceResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetAllActionGroupsRequest : public FPlayFabBaseModel
    {
		
	
        FGetAllActionGroupsRequest() :
			FPlayFabBaseModel()
			{}
		
		FGetAllActionGroupsRequest(const FGetAllActionGroupsRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FGetAllActionGroupsRequest(const TSharedPtr<FJsonObject>& obj) : FGetAllActionGroupsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetAllActionGroupsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetAllActionGroupsResult : public FPlayFabBaseModel
    {
		
		// List of Action Groups.
		TArray<FGetActionGroupResult> ActionGroups;
	
        FGetAllActionGroupsResult() :
			FPlayFabBaseModel(),
			ActionGroups()
			{}
		
		FGetAllActionGroupsResult(const FGetAllActionGroupsResult& src) :
			FPlayFabBaseModel(),
			ActionGroups(src.ActionGroups)
			{}
			
		FGetAllActionGroupsResult(const TSharedPtr<FJsonObject>& obj) : FGetAllActionGroupsResult()
        {
            readFromValue(obj);
        }
		
		~FGetAllActionGroupsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetAllSegmentsRequest : public FPlayFabBaseModel
    {
		
	
        FGetAllSegmentsRequest() :
			FPlayFabBaseModel()
			{}
		
		FGetAllSegmentsRequest(const FGetAllSegmentsRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FGetAllSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetAllSegmentsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetAllSegmentsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetSegmentResult : public FPlayFabBaseModel
    {
		
		// Unique identifier for this segment.
		FString Id;
		// [optional] Segment name.
		FString Name;
		// [optional] Identifier of the segments AB Test, if it is attached to one.
		FString ABTestParent;
	
        FGetSegmentResult() :
			FPlayFabBaseModel(),
			Id(),
			Name(),
			ABTestParent()
			{}
		
		FGetSegmentResult(const FGetSegmentResult& src) :
			FPlayFabBaseModel(),
			Id(src.Id),
			Name(src.Name),
			ABTestParent(src.ABTestParent)
			{}
			
		FGetSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetSegmentResult()
        {
            readFromValue(obj);
        }
		
		~FGetSegmentResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetAllSegmentsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of segments for this title.
		TArray<FGetSegmentResult> Segments;
	
        FGetAllSegmentsResult() :
			FPlayFabBaseModel(),
			Segments()
			{}
		
		FGetAllSegmentsResult(const FGetAllSegmentsResult& src) :
			FPlayFabBaseModel(),
			Segments(src.Segments)
			{}
			
		FGetAllSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetAllSegmentsResult()
        {
            readFromValue(obj);
        }
		
		~FGetAllSegmentsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCatalogItemsRequest : public FPlayFabBaseModel
    {
		
		// [optional] Which catalog is being requested. If null, uses the default catalog.
		FString CatalogVersion;
	
        FGetCatalogItemsRequest() :
			FPlayFabBaseModel(),
			CatalogVersion()
			{}
		
		FGetCatalogItemsRequest(const FGetCatalogItemsRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion)
			{}
			
		FGetCatalogItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCatalogItemsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCatalogItemsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of items which can be purchased.
		TArray<FCatalogItem> Catalog;
	
        FGetCatalogItemsResult() :
			FPlayFabBaseModel(),
			Catalog()
			{}
		
		FGetCatalogItemsResult(const FGetCatalogItemsResult& src) :
			FPlayFabBaseModel(),
			Catalog(src.Catalog)
			{}
			
		FGetCatalogItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsResult()
        {
            readFromValue(obj);
        }
		
		~FGetCatalogItemsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCloudScriptRevisionRequest : public FPlayFabBaseModel
    {
		
		// [optional] Version number. If left null, defaults to the latest version
		OptionalInt32 Version;
		// [optional] Revision number. If left null, defaults to the latest revision
		OptionalInt32 Revision;
	
        FGetCloudScriptRevisionRequest() :
			FPlayFabBaseModel(),
			Version(),
			Revision()
			{}
		
		FGetCloudScriptRevisionRequest(const FGetCloudScriptRevisionRequest& src) :
			FPlayFabBaseModel(),
			Version(src.Version),
			Revision(src.Revision)
			{}
			
		FGetCloudScriptRevisionRequest(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptRevisionRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCloudScriptRevisionRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCloudScriptRevisionResult : public FPlayFabBaseModel
    {
		
		// Version number.
		int32 Version;
		// Revision number.
		int32 Revision;
		// Time this revision was created
		FDateTime CreatedAt;
		// [optional] List of Cloud Script files in this revision.
		TArray<FCloudScriptFile> Files;
		// True if this is the currently published revision
		bool IsPublished;
	
        FGetCloudScriptRevisionResult() :
			FPlayFabBaseModel(),
			Version(0),
			Revision(0),
			CreatedAt(0),
			Files(),
			IsPublished(false)
			{}
		
		FGetCloudScriptRevisionResult(const FGetCloudScriptRevisionResult& src) :
			FPlayFabBaseModel(),
			Version(src.Version),
			Revision(src.Revision),
			CreatedAt(src.CreatedAt),
			Files(src.Files),
			IsPublished(src.IsPublished)
			{}
			
		FGetCloudScriptRevisionResult(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptRevisionResult()
        {
            readFromValue(obj);
        }
		
		~FGetCloudScriptRevisionResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCloudScriptTaskInstanceResult : public FPlayFabBaseModel
    {
		
		// [optional] Status summary of the CloudScript task instance
		TSharedPtr<FCloudScriptTaskSummary> Summary;
		// [optional] Parameter of this task instance
		TSharedPtr<FCloudScriptTaskParameter> Parameter;
	
        FGetCloudScriptTaskInstanceResult() :
			FPlayFabBaseModel(),
			Summary(nullptr),
			Parameter(nullptr)
			{}
		
		FGetCloudScriptTaskInstanceResult(const FGetCloudScriptTaskInstanceResult& src) :
			FPlayFabBaseModel(),
			Summary(src.Summary.IsValid() ? MakeShareable(new FCloudScriptTaskSummary(*src.Summary)) : nullptr),
			Parameter(src.Parameter.IsValid() ? MakeShareable(new FCloudScriptTaskParameter(*src.Parameter)) : nullptr)
			{}
			
		FGetCloudScriptTaskInstanceResult(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptTaskInstanceResult()
        {
            readFromValue(obj);
        }
		
		~FGetCloudScriptTaskInstanceResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCloudScriptVersionsRequest : public FPlayFabBaseModel
    {
		
	
        FGetCloudScriptVersionsRequest() :
			FPlayFabBaseModel()
			{}
		
		FGetCloudScriptVersionsRequest(const FGetCloudScriptVersionsRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FGetCloudScriptVersionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptVersionsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCloudScriptVersionsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCloudScriptVersionsResult : public FPlayFabBaseModel
    {
		
		// [optional] List of versions
		TArray<FCloudScriptVersionStatus> Versions;
	
        FGetCloudScriptVersionsResult() :
			FPlayFabBaseModel(),
			Versions()
			{}
		
		FGetCloudScriptVersionsResult(const FGetCloudScriptVersionsResult& src) :
			FPlayFabBaseModel(),
			Versions(src.Versions)
			{}
			
		FGetCloudScriptVersionsResult(const TSharedPtr<FJsonObject>& obj) : FGetCloudScriptVersionsResult()
        {
            readFromValue(obj);
        }
		
		~FGetCloudScriptVersionsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetContentListRequest : public FPlayFabBaseModel
    {
		
		// [optional] Limits the response to keys that begin with the specified prefix. You can use prefixes to list contents under a folder, or for a specified version, etc.
		FString Prefix;
	
        FGetContentListRequest() :
			FPlayFabBaseModel(),
			Prefix()
			{}
		
		FGetContentListRequest(const FGetContentListRequest& src) :
			FPlayFabBaseModel(),
			Prefix(src.Prefix)
			{}
			
		FGetContentListRequest(const TSharedPtr<FJsonObject>& obj) : FGetContentListRequest()
        {
            readFromValue(obj);
        }
		
		~FGetContentListRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetContentListResult : public FPlayFabBaseModel
    {
		
		// Number of content items returned. We currently have a maximum of 1000 items limit.
		int32 ItemCount;
		// The total size of listed contents in bytes.
		uint32 TotalSize;
		// [optional] List of content items.
		TArray<FContentInfo> Contents;
	
        FGetContentListResult() :
			FPlayFabBaseModel(),
			ItemCount(0),
			TotalSize(0),
			Contents()
			{}
		
		FGetContentListResult(const FGetContentListResult& src) :
			FPlayFabBaseModel(),
			ItemCount(src.ItemCount),
			TotalSize(src.TotalSize),
			Contents(src.Contents)
			{}
			
		FGetContentListResult(const TSharedPtr<FJsonObject>& obj) : FGetContentListResult()
        {
            readFromValue(obj);
        }
		
		~FGetContentListResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetContentUploadUrlRequest : public FPlayFabBaseModel
    {
		
		// Key of the content item to upload, usually formatted as a path, e.g. images/a.png
		FString Key;
		// [optional] A standard MIME type describing the format of the contents. The same MIME type has to be set in the header when uploading the content. If not specified, the MIME type is 'binary/octet-stream' by default.
		FString ContentType;
	
        FGetContentUploadUrlRequest() :
			FPlayFabBaseModel(),
			Key(),
			ContentType()
			{}
		
		FGetContentUploadUrlRequest(const FGetContentUploadUrlRequest& src) :
			FPlayFabBaseModel(),
			Key(src.Key),
			ContentType(src.ContentType)
			{}
			
		FGetContentUploadUrlRequest(const TSharedPtr<FJsonObject>& obj) : FGetContentUploadUrlRequest()
        {
            readFromValue(obj);
        }
		
		~FGetContentUploadUrlRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetContentUploadUrlResult : public FPlayFabBaseModel
    {
		
		// [optional] URL for uploading content via HTTP PUT method. The URL will expire in 1 hour.
		FString URL;
	
        FGetContentUploadUrlResult() :
			FPlayFabBaseModel(),
			URL()
			{}
		
		FGetContentUploadUrlResult(const FGetContentUploadUrlResult& src) :
			FPlayFabBaseModel(),
			URL(src.URL)
			{}
			
		FGetContentUploadUrlResult(const TSharedPtr<FJsonObject>& obj) : FGetContentUploadUrlResult()
        {
            readFromValue(obj);
        }
		
		~FGetContentUploadUrlResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetDataReportRequest : public FPlayFabBaseModel
    {
		
		// Report name
		FString ReportName;
		// Reporting year (UTC)
		int32 Year;
		// Reporting month (UTC)
		int32 Month;
		// Reporting year (UTC)
		int32 Day;
	
        FGetDataReportRequest() :
			FPlayFabBaseModel(),
			ReportName(),
			Year(0),
			Month(0),
			Day(0)
			{}
		
		FGetDataReportRequest(const FGetDataReportRequest& src) :
			FPlayFabBaseModel(),
			ReportName(src.ReportName),
			Year(src.Year),
			Month(src.Month),
			Day(src.Day)
			{}
			
		FGetDataReportRequest(const TSharedPtr<FJsonObject>& obj) : FGetDataReportRequest()
        {
            readFromValue(obj);
        }
		
		~FGetDataReportRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetDataReportResult : public FPlayFabBaseModel
    {
		
		// [optional] The URL where the requested report can be downloaded.
		FString DownloadUrl;
	
        FGetDataReportResult() :
			FPlayFabBaseModel(),
			DownloadUrl()
			{}
		
		FGetDataReportResult(const FGetDataReportResult& src) :
			FPlayFabBaseModel(),
			DownloadUrl(src.DownloadUrl)
			{}
			
		FGetDataReportResult(const TSharedPtr<FJsonObject>& obj) : FGetDataReportResult()
        {
            readFromValue(obj);
        }
		
		~FGetDataReportResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetMatchmakerGameInfoRequest : public FPlayFabBaseModel
    {
		
		// unique identifier of the lobby for which info is being requested
		FString LobbyId;
	
        FGetMatchmakerGameInfoRequest() :
			FPlayFabBaseModel(),
			LobbyId()
			{}
		
		FGetMatchmakerGameInfoRequest(const FGetMatchmakerGameInfoRequest& src) :
			FPlayFabBaseModel(),
			LobbyId(src.LobbyId)
			{}
			
		FGetMatchmakerGameInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameInfoRequest()
        {
            readFromValue(obj);
        }
		
		~FGetMatchmakerGameInfoRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetMatchmakerGameInfoResult : public FPlayFabBaseModel
    {
		
		// [optional] unique identifier of the lobby 
		FString LobbyId;
		// [optional] unique identifier of the Game Server Instance for this lobby
		FString TitleId;
		// time when the Game Server Instance was created
		FDateTime StartTime;
		// [optional] time when Game Server Instance is currently scheduled to end
		OptionalTime EndTime;
		// [optional] game mode for this Game Server Instance
		FString Mode;
		// [optional] version identifier of the game server executable binary being run
		FString BuildVersion;
		// [optional] region in which the Game Server Instance is running
		Boxed<Region> pfRegion;
		// [optional] array of unique PlayFab identifiers for users currently connected to this Game Server Instance
		TArray<FString> Players;
		// [optional] IP address for this Game Server Instance
		FString ServerAddress;
		// communication port for this Game Server Instance
		uint32 ServerPort;
	
        FGetMatchmakerGameInfoResult() :
			FPlayFabBaseModel(),
			LobbyId(),
			TitleId(),
			StartTime(0),
			EndTime(),
			Mode(),
			BuildVersion(),
			pfRegion(),
			Players(),
			ServerAddress(),
			ServerPort(0)
			{}
		
		FGetMatchmakerGameInfoResult(const FGetMatchmakerGameInfoResult& src) :
			FPlayFabBaseModel(),
			LobbyId(src.LobbyId),
			TitleId(src.TitleId),
			StartTime(src.StartTime),
			EndTime(src.EndTime),
			Mode(src.Mode),
			BuildVersion(src.BuildVersion),
			pfRegion(src.pfRegion),
			Players(src.Players),
			ServerAddress(src.ServerAddress),
			ServerPort(src.ServerPort)
			{}
			
		FGetMatchmakerGameInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameInfoResult()
        {
            readFromValue(obj);
        }
		
		~FGetMatchmakerGameInfoResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetMatchmakerGameModesRequest : public FPlayFabBaseModel
    {
		
		// previously uploaded build version for which game modes are being requested
		FString BuildVersion;
	
        FGetMatchmakerGameModesRequest() :
			FPlayFabBaseModel(),
			BuildVersion()
			{}
		
		FGetMatchmakerGameModesRequest(const FGetMatchmakerGameModesRequest& src) :
			FPlayFabBaseModel(),
			BuildVersion(src.BuildVersion)
			{}
			
		FGetMatchmakerGameModesRequest(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameModesRequest()
        {
            readFromValue(obj);
        }
		
		~FGetMatchmakerGameModesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetMatchmakerGameModesResult : public FPlayFabBaseModel
    {
		
		// [optional] array of game modes available for the specified build
		TArray<FGameModeInfo> GameModes;
	
        FGetMatchmakerGameModesResult() :
			FPlayFabBaseModel(),
			GameModes()
			{}
		
		FGetMatchmakerGameModesResult(const FGetMatchmakerGameModesResult& src) :
			FPlayFabBaseModel(),
			GameModes(src.GameModes)
			{}
			
		FGetMatchmakerGameModesResult(const TSharedPtr<FJsonObject>& obj) : FGetMatchmakerGameModesResult()
        {
            readFromValue(obj);
        }
		
		~FGetMatchmakerGameModesResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerSegmentsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of segments the requested player currently belongs to.
		TArray<FGetSegmentResult> Segments;
	
        FGetPlayerSegmentsResult() :
			FPlayFabBaseModel(),
			Segments()
			{}
		
		FGetPlayerSegmentsResult(const FGetPlayerSegmentsResult& src) :
			FPlayFabBaseModel(),
			Segments(src.Segments)
			{}
			
		FGetPlayerSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSegmentsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerSegmentsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayersInSegmentRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for this segment.
		FString SegmentId;
		// [optional] Number of seconds to keep the continuation token active. After token expiration it is not possible to continue paging results. Default is 300 (5 minutes). Maximum is 1,800 (30 minutes).
		OptionalUint32 SecondsToLive;
		// [optional] Maximum number of profiles to load. Default is 1,000. Maximum is 10,000.
		OptionalUint32 MaxBatchSize;
		// [optional] Continuation token if retrieving subsequent pages of results.
		FString ContinuationToken;
	
        FGetPlayersInSegmentRequest() :
			FPlayFabBaseModel(),
			SegmentId(),
			SecondsToLive(),
			MaxBatchSize(),
			ContinuationToken()
			{}
		
		FGetPlayersInSegmentRequest(const FGetPlayersInSegmentRequest& src) :
			FPlayFabBaseModel(),
			SegmentId(src.SegmentId),
			SecondsToLive(src.SecondsToLive),
			MaxBatchSize(src.MaxBatchSize),
			ContinuationToken(src.ContinuationToken)
			{}
			
		FGetPlayersInSegmentRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayersInSegmentRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayersInSegmentRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum LoginIdentityProvider
	{
		LoginIdentityProviderUnknown,
		LoginIdentityProviderPlayFab,
		LoginIdentityProviderCustom,
		LoginIdentityProviderGameCenter,
		LoginIdentityProviderGooglePlay,
		LoginIdentityProviderSteam,
		LoginIdentityProviderXBoxLive,
		LoginIdentityProviderPSN,
		LoginIdentityProviderKongregate,
		LoginIdentityProviderFacebook,
		LoginIdentityProviderIOSDevice,
		LoginIdentityProviderAndroidDevice,
		LoginIdentityProviderTwitch
	};
	
	void writeLoginIdentityProviderEnumJSON(LoginIdentityProvider enumVal, JsonWriter& writer);
	LoginIdentityProvider readLoginIdentityProviderFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FPlayerLocation : public FPlayFabBaseModel
    {
		
		// The two-character continent code for this location
		ContinentCode pfContinentCode;
		// The two-character ISO 3166-1 country code for the country associated with the location
		CountryCode pfCountryCode;
		// [optional] City of the player's geographic location.
		FString City;
		// [optional] Latitude coordinate of the player's geographic location.
		OptionalDouble Latitude;
		// [optional] Longitude coordinate of the player's geographic location.
		OptionalDouble Longitude;
	
        FPlayerLocation() :
			FPlayFabBaseModel(),
			pfContinentCode(),
			pfCountryCode(),
			City(),
			Latitude(),
			Longitude()
			{}
		
		FPlayerLocation(const FPlayerLocation& src) :
			FPlayFabBaseModel(),
			pfContinentCode(src.pfContinentCode),
			pfCountryCode(src.pfCountryCode),
			City(src.City),
			Latitude(src.Latitude),
			Longitude(src.Longitude)
			{}
			
		FPlayerLocation(const TSharedPtr<FJsonObject>& obj) : FPlayerLocation()
        {
            readFromValue(obj);
        }
		
		~FPlayerLocation();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum PushNotificationPlatform
	{
		PushNotificationPlatformApplePushNotificationService,
		PushNotificationPlatformGoogleCloudMessaging
	};
	
	void writePushNotificationPlatformEnumJSON(PushNotificationPlatform enumVal, JsonWriter& writer);
	PushNotificationPlatform readPushNotificationPlatformFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FPushNotificationRegistration : public FPlayFabBaseModel
    {
		
		// [optional] Push notification platform
		Boxed<PushNotificationPlatform> Platform;
		// [optional] Notification configured endpoint
		FString NotificationEndpointARN;
	
        FPushNotificationRegistration() :
			FPlayFabBaseModel(),
			Platform(),
			NotificationEndpointARN()
			{}
		
		FPushNotificationRegistration(const FPushNotificationRegistration& src) :
			FPlayFabBaseModel(),
			Platform(src.Platform),
			NotificationEndpointARN(src.NotificationEndpointARN)
			{}
			
		FPushNotificationRegistration(const TSharedPtr<FJsonObject>& obj) : FPushNotificationRegistration()
        {
            readFromValue(obj);
        }
		
		~FPushNotificationRegistration();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPlayerLinkedAccount : public FPlayFabBaseModel
    {
		
		// [optional] Authentication platform
		Boxed<LoginIdentityProvider> Platform;
		// [optional] Platform user identifier
		FString PlatformUserId;
		// [optional] Linked account's username
		FString Username;
		// [optional] Linked account's email
		FString Email;
	
        FPlayerLinkedAccount() :
			FPlayFabBaseModel(),
			Platform(),
			PlatformUserId(),
			Username(),
			Email()
			{}
		
		FPlayerLinkedAccount(const FPlayerLinkedAccount& src) :
			FPlayFabBaseModel(),
			Platform(src.Platform),
			PlatformUserId(src.PlatformUserId),
			Username(src.Username),
			Email(src.Email)
			{}
			
		FPlayerLinkedAccount(const TSharedPtr<FJsonObject>& obj) : FPlayerLinkedAccount()
        {
            readFromValue(obj);
        }
		
		~FPlayerLinkedAccount();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPlayerStatistic : public FPlayFabBaseModel
    {
		
		// [optional] Statistic ID
		FString Id;
		// Statistic version (0 if not a versioned statistic)
		int32 StatisticVersion;
		// Current statistic value
		int32 StatisticValue;
		// [optional] Statistic name
		FString Name;
	
        FPlayerStatistic() :
			FPlayFabBaseModel(),
			Id(),
			StatisticVersion(0),
			StatisticValue(0),
			Name()
			{}
		
		FPlayerStatistic(const FPlayerStatistic& src) :
			FPlayFabBaseModel(),
			Id(src.Id),
			StatisticVersion(src.StatisticVersion),
			StatisticValue(src.StatisticValue),
			Name(src.Name)
			{}
			
		FPlayerStatistic(const TSharedPtr<FJsonObject>& obj) : FPlayerStatistic()
        {
            readFromValue(obj);
        }
		
		~FPlayerStatistic();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPlayerProfile : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab Player ID
		FString PlayerId;
		// [optional] Title ID this profile applies to
		FString TitleId;
		// [optional] Player Display Name
		FString DisplayName;
		// [optional] Publisher this player belongs to
		FString PublisherId;
		// [optional] Player account origination
		Boxed<LoginIdentityProvider> Origination;
		// [optional] Player record created
		OptionalTime Created;
		// [optional] Last login
		OptionalTime LastLogin;
		// [optional] Banned until UTC Date. If permanent ban this is set for 20 years after the original ban date.
		OptionalTime BannedUntil;
		// [optional] Dictionary of player's statistics using only the latest version's value
		TMap<FString, int32> Statistics;
		// [optional] A sum of player's total purchases in USD across all currencies.
		OptionalUint32 TotalValueToDateInUSD;
		// [optional] Dictionary of player's total purchases by currency.
		TMap<FString, uint32> ValuesToDate;
		// [optional] List of player's tags for segmentation.
		TArray<FString> Tags;
		// [optional] Dictionary of player's locations by type.
		TMap<FString, FPlayerLocation> Locations;
		// [optional] Dictionary of player's virtual currency balances
		TMap<FString, int32> VirtualCurrencyBalances;
		// [optional] Array of ad campaigns player has been attributed to
		TArray<FAdCampaignAttribution> AdCampaignAttributions;
		// [optional] Array of configured push notification end points
		TArray<FPushNotificationRegistration> PushNotificationRegistrations;
		// [optional] Array of third party accounts linked to this player
		TArray<FPlayerLinkedAccount> LinkedAccounts;
		// [optional] Array of player statistics
		TArray<FPlayerStatistic> PlayerStatistics;
	
        FPlayerProfile() :
			FPlayFabBaseModel(),
			PlayerId(),
			TitleId(),
			DisplayName(),
			PublisherId(),
			Origination(),
			Created(),
			LastLogin(),
			BannedUntil(),
			Statistics(),
			TotalValueToDateInUSD(),
			ValuesToDate(),
			Tags(),
			Locations(),
			VirtualCurrencyBalances(),
			AdCampaignAttributions(),
			PushNotificationRegistrations(),
			LinkedAccounts(),
			PlayerStatistics()
			{}
		
		FPlayerProfile(const FPlayerProfile& src) :
			FPlayFabBaseModel(),
			PlayerId(src.PlayerId),
			TitleId(src.TitleId),
			DisplayName(src.DisplayName),
			PublisherId(src.PublisherId),
			Origination(src.Origination),
			Created(src.Created),
			LastLogin(src.LastLogin),
			BannedUntil(src.BannedUntil),
			Statistics(src.Statistics),
			TotalValueToDateInUSD(src.TotalValueToDateInUSD),
			ValuesToDate(src.ValuesToDate),
			Tags(src.Tags),
			Locations(src.Locations),
			VirtualCurrencyBalances(src.VirtualCurrencyBalances),
			AdCampaignAttributions(src.AdCampaignAttributions),
			PushNotificationRegistrations(src.PushNotificationRegistrations),
			LinkedAccounts(src.LinkedAccounts),
			PlayerStatistics(src.PlayerStatistics)
			{}
			
		FPlayerProfile(const TSharedPtr<FJsonObject>& obj) : FPlayerProfile()
        {
            readFromValue(obj);
        }
		
		~FPlayerProfile();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayersInSegmentResult : public FPlayFabBaseModel
    {
		
		// Count of profiles matching this segment.
		int32 ProfilesInSegment;
		// [optional] Continuation token to use to retrieve subsequent pages of results. If token returns null there are no more results.
		FString ContinuationToken;
		// [optional] Array of player profiles in this segment.
		TArray<FPlayerProfile> PlayerProfiles;
	
        FGetPlayersInSegmentResult() :
			FPlayFabBaseModel(),
			ProfilesInSegment(0),
			ContinuationToken(),
			PlayerProfiles()
			{}
		
		FGetPlayersInSegmentResult(const FGetPlayersInSegmentResult& src) :
			FPlayFabBaseModel(),
			ProfilesInSegment(src.ProfilesInSegment),
			ContinuationToken(src.ContinuationToken),
			PlayerProfiles(src.PlayerProfiles)
			{}
			
		FGetPlayersInSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayersInSegmentResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayersInSegmentResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayersSegmentsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FGetPlayersSegmentsRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FGetPlayersSegmentsRequest(const FGetPlayersSegmentsRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FGetPlayersSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayersSegmentsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayersSegmentsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticDefinitionsRequest : public FPlayFabBaseModel
    {
		
	
        FGetPlayerStatisticDefinitionsRequest() :
			FPlayFabBaseModel()
			{}
		
		FGetPlayerStatisticDefinitionsRequest(const FGetPlayerStatisticDefinitionsRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FGetPlayerStatisticDefinitionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticDefinitionsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticDefinitionsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticDefinitionsResult : public FPlayFabBaseModel
    {
		
		// [optional] the player statistic definitions for the title
		TArray<FPlayerStatisticDefinition> Statistics;
	
        FGetPlayerStatisticDefinitionsResult() :
			FPlayFabBaseModel(),
			Statistics()
			{}
		
		FGetPlayerStatisticDefinitionsResult(const FGetPlayerStatisticDefinitionsResult& src) :
			FPlayFabBaseModel(),
			Statistics(src.Statistics)
			{}
			
		FGetPlayerStatisticDefinitionsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticDefinitionsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticDefinitionsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticVersionsRequest : public FPlayFabBaseModel
    {
		
		// [optional] unique name of the statistic
		FString StatisticName;
	
        FGetPlayerStatisticVersionsRequest() :
			FPlayFabBaseModel(),
			StatisticName()
			{}
		
		FGetPlayerStatisticVersionsRequest(const FGetPlayerStatisticVersionsRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName)
			{}
			
		FGetPlayerStatisticVersionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticVersionsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum StatisticVersionArchivalStatus
	{
		StatisticVersionArchivalStatusNotScheduled,
		StatisticVersionArchivalStatusScheduled,
		StatisticVersionArchivalStatusQueued,
		StatisticVersionArchivalStatusInProgress,
		StatisticVersionArchivalStatusComplete
	};
	
	void writeStatisticVersionArchivalStatusEnumJSON(StatisticVersionArchivalStatus enumVal, JsonWriter& writer);
	StatisticVersionArchivalStatus readStatisticVersionArchivalStatusFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FPlayerStatisticVersion : public FPlayFabBaseModel
    {
		
		// [optional] name of the statistic when the version became active
		FString StatisticName;
		// version of the statistic
		uint32 Version;
		// [optional] time at which the statistic version was scheduled to become active, based on the configured ResetInterval
		OptionalTime ScheduledActivationTime;
		// time when the statistic version became active
		FDateTime ActivationTime;
		// [optional] time at which the statistic version was scheduled to become inactive, based on the configured ResetInterval
		OptionalTime ScheduledDeactivationTime;
		// [optional] time when the statistic version became inactive due to statistic version incrementing
		OptionalTime DeactivationTime;
		// [optional] status of the process of saving player statistic values of the previous version to a downloadable archive
		Boxed<StatisticVersionArchivalStatus> ArchivalStatus;
		// [optional] URL for the downloadable archive of player statistic values, if available
		FString ArchiveDownloadUrl;
	
        FPlayerStatisticVersion() :
			FPlayFabBaseModel(),
			StatisticName(),
			Version(0),
			ScheduledActivationTime(),
			ActivationTime(0),
			ScheduledDeactivationTime(),
			DeactivationTime(),
			ArchivalStatus(),
			ArchiveDownloadUrl()
			{}
		
		FPlayerStatisticVersion(const FPlayerStatisticVersion& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			Version(src.Version),
			ScheduledActivationTime(src.ScheduledActivationTime),
			ActivationTime(src.ActivationTime),
			ScheduledDeactivationTime(src.ScheduledDeactivationTime),
			DeactivationTime(src.DeactivationTime),
			ArchivalStatus(src.ArchivalStatus),
			ArchiveDownloadUrl(src.ArchiveDownloadUrl)
			{}
			
		FPlayerStatisticVersion(const TSharedPtr<FJsonObject>& obj) : FPlayerStatisticVersion()
        {
            readFromValue(obj);
        }
		
		~FPlayerStatisticVersion();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticVersionsResult : public FPlayFabBaseModel
    {
		
		// [optional] version change history of the statistic
		TArray<FPlayerStatisticVersion> StatisticVersions;
	
        FGetPlayerStatisticVersionsResult() :
			FPlayFabBaseModel(),
			StatisticVersions()
			{}
		
		FGetPlayerStatisticVersionsResult(const FGetPlayerStatisticVersionsResult& src) :
			FPlayFabBaseModel(),
			StatisticVersions(src.StatisticVersions)
			{}
			
		FGetPlayerStatisticVersionsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticVersionsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerTagsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Optional namespace to filter results by
		FString Namespace;
	
        FGetPlayerTagsRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Namespace()
			{}
		
		FGetPlayerTagsRequest(const FGetPlayerTagsRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Namespace(src.Namespace)
			{}
			
		FGetPlayerTagsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerTagsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerTagsResult : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Canonical tags (including namespace and tag's name) for the requested user
		TArray<FString> Tags;
	
        FGetPlayerTagsResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Tags()
			{}
		
		FGetPlayerTagsResult(const FGetPlayerTagsResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Tags(src.Tags)
			{}
			
		FGetPlayerTagsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerTagsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPolicyRequest : public FPlayFabBaseModel
    {
		
		// [optional] The name of the policy to read. Only supported name is 'ApiPolicy'.
		FString PolicyName;
	
        FGetPolicyRequest() :
			FPlayFabBaseModel(),
			PolicyName()
			{}
		
		FGetPolicyRequest(const FGetPolicyRequest& src) :
			FPlayFabBaseModel(),
			PolicyName(src.PolicyName)
			{}
			
		FGetPolicyRequest(const TSharedPtr<FJsonObject>& obj) : FGetPolicyRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPolicyRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPermissionStatement : public FPlayFabBaseModel
    {
		
		// The resource this statements effects. The only supported resources look like 'pfrn:api--*' for all apis, or 'pfrn:api--/Client/ConfirmPurchase' for specific apis.
		FString Resource;
		// The action this statement effects. The only supported action is 'Execute'.
		FString Action;
		// The effect this statement will have. The only supported effect is 'Allow'.
		EffectType Effect;
		// The principal this statement will effect. The only supported principal is '*'.
		FString Principal;
		// [optional] A comment about the statement. Intended solely for bookeeping and debugging.
		FString Comment;
	
        FPermissionStatement() :
			FPlayFabBaseModel(),
			Resource(),
			Action(),
			Effect(),
			Principal(),
			Comment()
			{}
		
		FPermissionStatement(const FPermissionStatement& src) :
			FPlayFabBaseModel(),
			Resource(src.Resource),
			Action(src.Action),
			Effect(src.Effect),
			Principal(src.Principal),
			Comment(src.Comment)
			{}
			
		FPermissionStatement(const TSharedPtr<FJsonObject>& obj) : FPermissionStatement()
        {
            readFromValue(obj);
        }
		
		~FPermissionStatement();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPolicyResponse : public FPlayFabBaseModel
    {
		
		// [optional] The name of the policy read.
		FString PolicyName;
		// [optional] The statements in the requested policy.
		TArray<FPermissionStatement> Statements;
	
        FGetPolicyResponse() :
			FPlayFabBaseModel(),
			PolicyName(),
			Statements()
			{}
		
		FGetPolicyResponse(const FGetPolicyResponse& src) :
			FPlayFabBaseModel(),
			PolicyName(src.PolicyName),
			Statements(src.Statements)
			{}
			
		FGetPolicyResponse(const TSharedPtr<FJsonObject>& obj) : FGetPolicyResponse()
        {
            readFromValue(obj);
        }
		
		~FGetPolicyResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPublisherDataRequest : public FPlayFabBaseModel
    {
		
		//  array of keys to get back data from the Publisher data blob, set by the admin tools
		TArray<FString> Keys;
	
        FGetPublisherDataRequest() :
			FPlayFabBaseModel(),
			Keys()
			{}
		
		FGetPublisherDataRequest(const FGetPublisherDataRequest& src) :
			FPlayFabBaseModel(),
			Keys(src.Keys)
			{}
			
		FGetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPublisherDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPublisherDataResult : public FPlayFabBaseModel
    {
		
		// [optional] a dictionary object of key / value pairs
		TMap<FString, FString> Data;
	
        FGetPublisherDataResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPublisherDataResult(const FGetPublisherDataResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetPublisherDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetRandomResultTablesRequest : public FPlayFabBaseModel
    {
		
		// [optional] catalog version to fetch tables from. Use default catalog version if null
		FString CatalogVersion;
	
        FGetRandomResultTablesRequest() :
			FPlayFabBaseModel(),
			CatalogVersion()
			{}
		
		FGetRandomResultTablesRequest(const FGetRandomResultTablesRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion)
			{}
			
		FGetRandomResultTablesRequest(const TSharedPtr<FJsonObject>& obj) : FGetRandomResultTablesRequest()
        {
            readFromValue(obj);
        }
		
		~FGetRandomResultTablesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum ResultTableNodeType
	{
		ResultTableNodeTypeItemId,
		ResultTableNodeTypeTableId
	};
	
	void writeResultTableNodeTypeEnumJSON(ResultTableNodeType enumVal, JsonWriter& writer);
	ResultTableNodeType readResultTableNodeTypeFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FResultTableNode : public FPlayFabBaseModel
    {
		
		// Whether this entry in the table is an item or a link to another table
		ResultTableNodeType ResultItemType;
		// Either an ItemId, or the TableId of another random result table
		FString ResultItem;
		// How likely this is to be rolled - larger numbers add more weight
		int32 Weight;
	
        FResultTableNode() :
			FPlayFabBaseModel(),
			ResultItemType(),
			ResultItem(),
			Weight(0)
			{}
		
		FResultTableNode(const FResultTableNode& src) :
			FPlayFabBaseModel(),
			ResultItemType(src.ResultItemType),
			ResultItem(src.ResultItem),
			Weight(src.Weight)
			{}
			
		FResultTableNode(const TSharedPtr<FJsonObject>& obj) : FResultTableNode()
        {
            readFromValue(obj);
        }
		
		~FResultTableNode();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRandomResultTableListing : public FPlayFabBaseModel
    {
		
		// [optional] Catalog version this table is associated with
		FString CatalogVersion;
		// Unique name for this drop table
		FString TableId;
		// Child nodes that indicate what kind of drop table item this actually is.
		TArray<FResultTableNode> Nodes;
	
        FRandomResultTableListing() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			TableId(),
			Nodes()
			{}
		
		FRandomResultTableListing(const FRandomResultTableListing& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			TableId(src.TableId),
			Nodes(src.Nodes)
			{}
			
		FRandomResultTableListing(const TSharedPtr<FJsonObject>& obj) : FRandomResultTableListing()
        {
            readFromValue(obj);
        }
		
		~FRandomResultTableListing();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetRandomResultTablesResult : public FPlayFabBaseModel
    {
		
		// [optional] array of random result tables currently available
		TMap<FString, FRandomResultTableListing> Tables;
	
        FGetRandomResultTablesResult() :
			FPlayFabBaseModel(),
			Tables()
			{}
		
		FGetRandomResultTablesResult(const FGetRandomResultTablesResult& src) :
			FPlayFabBaseModel(),
			Tables(src.Tables)
			{}
			
		FGetRandomResultTablesResult(const TSharedPtr<FJsonObject>& obj) : FGetRandomResultTablesResult()
        {
            readFromValue(obj);
        }
		
		~FGetRandomResultTablesResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetServerBuildInfoRequest : public FPlayFabBaseModel
    {
		
		// unique identifier of the previously uploaded build executable for which information is being requested
		FString BuildId;
	
        FGetServerBuildInfoRequest() :
			FPlayFabBaseModel(),
			BuildId()
			{}
		
		FGetServerBuildInfoRequest(const FGetServerBuildInfoRequest& src) :
			FPlayFabBaseModel(),
			BuildId(src.BuildId)
			{}
			
		FGetServerBuildInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildInfoRequest()
        {
            readFromValue(obj);
        }
		
		~FGetServerBuildInfoRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetServerBuildInfoResult : public FPlayFabBaseModel
    {
		
		// [optional] unique identifier for this build executable
		FString BuildId;
		// [optional] array of regions where this build can used, when it is active
		TArray<Region> ActiveRegions;
		// maximum number of game server instances that can run on a single host machine
		int32 MaxGamesPerHost;
		// minimum capacity of additional game server instances that can be started before the autoscaling service starts new host machines (given the number of current running host machines and game server instances)
		int32 MinFreeGameSlots;
		// [optional] developer comment(s) for this build
		FString Comment;
		// time this build was last modified (or uploaded, if this build has never been modified)
		FDateTime Timestamp;
		// [optional] Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// [optional] the current status of the build validation and processing steps
		Boxed<GameBuildStatus> Status;
		// [optional] error message, if any, about this build
		FString ErrorMessage;
	
        FGetServerBuildInfoResult() :
			FPlayFabBaseModel(),
			BuildId(),
			ActiveRegions(),
			MaxGamesPerHost(0),
			MinFreeGameSlots(0),
			Comment(),
			Timestamp(0),
			TitleId(),
			Status(),
			ErrorMessage()
			{}
		
		FGetServerBuildInfoResult(const FGetServerBuildInfoResult& src) :
			FPlayFabBaseModel(),
			BuildId(src.BuildId),
			ActiveRegions(src.ActiveRegions),
			MaxGamesPerHost(src.MaxGamesPerHost),
			MinFreeGameSlots(src.MinFreeGameSlots),
			Comment(src.Comment),
			Timestamp(src.Timestamp),
			TitleId(src.TitleId),
			Status(src.Status),
			ErrorMessage(src.ErrorMessage)
			{}
			
		FGetServerBuildInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildInfoResult()
        {
            readFromValue(obj);
        }
		
		~FGetServerBuildInfoResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetServerBuildUploadURLRequest : public FPlayFabBaseModel
    {
		
		// unique identifier of the game server build to upload
		FString BuildId;
	
        FGetServerBuildUploadURLRequest() :
			FPlayFabBaseModel(),
			BuildId()
			{}
		
		FGetServerBuildUploadURLRequest(const FGetServerBuildUploadURLRequest& src) :
			FPlayFabBaseModel(),
			BuildId(src.BuildId)
			{}
			
		FGetServerBuildUploadURLRequest(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildUploadURLRequest()
        {
            readFromValue(obj);
        }
		
		~FGetServerBuildUploadURLRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetServerBuildUploadURLResult : public FPlayFabBaseModel
    {
		
		// [optional] pre-authorized URL for uploading the game server build package
		FString URL;
	
        FGetServerBuildUploadURLResult() :
			FPlayFabBaseModel(),
			URL()
			{}
		
		FGetServerBuildUploadURLResult(const FGetServerBuildUploadURLResult& src) :
			FPlayFabBaseModel(),
			URL(src.URL)
			{}
			
		FGetServerBuildUploadURLResult(const TSharedPtr<FJsonObject>& obj) : FGetServerBuildUploadURLResult()
        {
            readFromValue(obj);
        }
		
		~FGetServerBuildUploadURLResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetStoreItemsRequest : public FPlayFabBaseModel
    {
		
		// [optional] catalog version to store items from. Use default catalog version if null
		FString CatalogVersion;
		// Unqiue identifier for the store which is being requested.
		FString StoreId;
	
        FGetStoreItemsRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			StoreId()
			{}
		
		FGetStoreItemsRequest(const FGetStoreItemsRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			StoreId(src.StoreId)
			{}
			
		FGetStoreItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetStoreItemsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetStoreItemsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStoreItem : public FPlayFabBaseModel
    {
		
		// Unique identifier of the item as it exists in the catalog - note that this must exactly match the ItemId from the catalog
		FString ItemId;
		// [optional] Override prices for this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
		TMap<FString, uint32> VirtualCurrencyPrices;
		// [optional] Override prices for this item for specific currencies
		TMap<FString, uint32> RealCurrencyPrices;
		// [optional] Store specific custom data. The data only exists as part of this store; it is not transferred to item instances
		FMultitypeVar CustomData;
		// [optional] Intended display position for this item. Note that 0 is the first position
		OptionalUint32 DisplayPosition;
	
        FStoreItem() :
			FPlayFabBaseModel(),
			ItemId(),
			VirtualCurrencyPrices(),
			RealCurrencyPrices(),
			CustomData(),
			DisplayPosition()
			{}
		
		FStoreItem(const FStoreItem& src) :
			FPlayFabBaseModel(),
			ItemId(src.ItemId),
			VirtualCurrencyPrices(src.VirtualCurrencyPrices),
			RealCurrencyPrices(src.RealCurrencyPrices),
			CustomData(src.CustomData),
			DisplayPosition(src.DisplayPosition)
			{}
			
		FStoreItem(const TSharedPtr<FJsonObject>& obj) : FStoreItem()
        {
            readFromValue(obj);
        }
		
		~FStoreItem();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum SourceType
	{
		SourceTypeAdmin,
		SourceTypeBackEnd,
		SourceTypeGameClient,
		SourceTypeGameServer,
		SourceTypePartner
	};
	
	void writeSourceTypeEnumJSON(SourceType enumVal, JsonWriter& writer);
	SourceType readSourceTypeFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FStoreMarketingModel : public FPlayFabBaseModel
    {
		
		// [optional] Display name of a store as it will appear to users.
		FString DisplayName;
		// [optional] Tagline for a store.
		FString Description;
		// [optional] Custom data about a store.
		FMultitypeVar Metadata;
	
        FStoreMarketingModel() :
			FPlayFabBaseModel(),
			DisplayName(),
			Description(),
			Metadata()
			{}
		
		FStoreMarketingModel(const FStoreMarketingModel& src) :
			FPlayFabBaseModel(),
			DisplayName(src.DisplayName),
			Description(src.Description),
			Metadata(src.Metadata)
			{}
			
		FStoreMarketingModel(const TSharedPtr<FJsonObject>& obj) : FStoreMarketingModel()
        {
            readFromValue(obj);
        }
		
		~FStoreMarketingModel();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetStoreItemsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of items which can be purchased from this store.
		TArray<FStoreItem> Store;
		// [optional] How the store was last updated (Admin or a third party).
		Boxed<SourceType> Source;
		// [optional] The base catalog that this store is a part of.
		FString CatalogVersion;
		// [optional] The ID of this store.
		FString StoreId;
		// [optional] Additional data about the store.
		TSharedPtr<FStoreMarketingModel> MarketingData;
	
        FGetStoreItemsResult() :
			FPlayFabBaseModel(),
			Store(),
			Source(),
			CatalogVersion(),
			StoreId(),
			MarketingData(nullptr)
			{}
		
		FGetStoreItemsResult(const FGetStoreItemsResult& src) :
			FPlayFabBaseModel(),
			Store(src.Store),
			Source(src.Source),
			CatalogVersion(src.CatalogVersion),
			StoreId(src.StoreId),
			MarketingData(src.MarketingData.IsValid() ? MakeShareable(new FStoreMarketingModel(*src.MarketingData)) : nullptr)
			{}
			
		FGetStoreItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetStoreItemsResult()
        {
            readFromValue(obj);
        }
		
		~FGetStoreItemsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTaskInstanceRequest : public FPlayFabBaseModel
    {
		
		// ID of the requested task instance.
		FString TaskInstanceId;
	
        FGetTaskInstanceRequest() :
			FPlayFabBaseModel(),
			TaskInstanceId()
			{}
		
		FGetTaskInstanceRequest(const FGetTaskInstanceRequest& src) :
			FPlayFabBaseModel(),
			TaskInstanceId(src.TaskInstanceId)
			{}
			
		FGetTaskInstanceRequest(const TSharedPtr<FJsonObject>& obj) : FGetTaskInstanceRequest()
        {
            readFromValue(obj);
        }
		
		~FGetTaskInstanceRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTaskInstancesRequest : public FPlayFabBaseModel
    {
		
		// [optional] Name or ID of the task whose instances are being queried. If not specified, return all task instances that satisfy conditions set by other filters.
		TSharedPtr<FNameIdentifier> TaskIdentifier;
		// [optional] Optional filter for task instances that are of a specific status.
		Boxed<TaskInstanceStatus> StatusFilter;
		// [optional] Optional range-from filter for task instances' StartedAt timestamp.
		OptionalTime StartedAtRangeFrom;
		// [optional] Optional range-to filter for task instances' StartedAt timestamp.
		OptionalTime StartedAtRangeTo;
	
        FGetTaskInstancesRequest() :
			FPlayFabBaseModel(),
			TaskIdentifier(nullptr),
			StatusFilter(),
			StartedAtRangeFrom(),
			StartedAtRangeTo()
			{}
		
		FGetTaskInstancesRequest(const FGetTaskInstancesRequest& src) :
			FPlayFabBaseModel(),
			TaskIdentifier(src.TaskIdentifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.TaskIdentifier)) : nullptr),
			StatusFilter(src.StatusFilter),
			StartedAtRangeFrom(src.StartedAtRangeFrom),
			StartedAtRangeTo(src.StartedAtRangeTo)
			{}
			
		FGetTaskInstancesRequest(const TSharedPtr<FJsonObject>& obj) : FGetTaskInstancesRequest()
        {
            readFromValue(obj);
        }
		
		~FGetTaskInstancesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum ScheduledTaskType
	{
		ScheduledTaskTypeCloudScript,
		ScheduledTaskTypeActionsOnPlayerSegment
	};
	
	void writeScheduledTaskTypeEnumJSON(ScheduledTaskType enumVal, JsonWriter& writer);
	ScheduledTaskType readScheduledTaskTypeFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FTaskInstanceBasicSummary : public FPlayFabBaseModel
    {
		
		// [optional] ID of the task instance.
		FString TaskInstanceId;
		// [optional] Identifier of the task this instance belongs to.
		TSharedPtr<FNameIdentifier> TaskIdentifier;
		// UTC timestamp when the task started.
		FDateTime StartedAt;
		// [optional] UTC timestamp when the task completed.
		OptionalTime CompletedAt;
		// [optional] Current status of the task instance.
		Boxed<TaskInstanceStatus> Status;
		// [optional] Progress represented as percentage.
		OptionalDouble PercentComplete;
		// [optional] Estimated time remaining in seconds.
		OptionalDouble EstimatedSecondsRemaining;
		// [optional] If manually scheduled, ID of user who scheduled the task.
		FString ScheduledByUserId;
		// [optional] Type of the task.
		Boxed<ScheduledTaskType> Type;
	
        FTaskInstanceBasicSummary() :
			FPlayFabBaseModel(),
			TaskInstanceId(),
			TaskIdentifier(nullptr),
			StartedAt(0),
			CompletedAt(),
			Status(),
			PercentComplete(),
			EstimatedSecondsRemaining(),
			ScheduledByUserId(),
			Type()
			{}
		
		FTaskInstanceBasicSummary(const FTaskInstanceBasicSummary& src) :
			FPlayFabBaseModel(),
			TaskInstanceId(src.TaskInstanceId),
			TaskIdentifier(src.TaskIdentifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.TaskIdentifier)) : nullptr),
			StartedAt(src.StartedAt),
			CompletedAt(src.CompletedAt),
			Status(src.Status),
			PercentComplete(src.PercentComplete),
			EstimatedSecondsRemaining(src.EstimatedSecondsRemaining),
			ScheduledByUserId(src.ScheduledByUserId),
			Type(src.Type)
			{}
			
		FTaskInstanceBasicSummary(const TSharedPtr<FJsonObject>& obj) : FTaskInstanceBasicSummary()
        {
            readFromValue(obj);
        }
		
		~FTaskInstanceBasicSummary();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTaskInstancesResult : public FPlayFabBaseModel
    {
		
		// [optional] Basic status summaries of the queried task instances. Empty If no task instances meets the filter criteria. To get detailed status summary, use Get*TaskInstance API according to task type (e.g. GetActionsOnPlayersInSegmentTaskInstance).
		TArray<FTaskInstanceBasicSummary> Summaries;
	
        FGetTaskInstancesResult() :
			FPlayFabBaseModel(),
			Summaries()
			{}
		
		FGetTaskInstancesResult(const FGetTaskInstancesResult& src) :
			FPlayFabBaseModel(),
			Summaries(src.Summaries)
			{}
			
		FGetTaskInstancesResult(const TSharedPtr<FJsonObject>& obj) : FGetTaskInstancesResult()
        {
            readFromValue(obj);
        }
		
		~FGetTaskInstancesResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTasksRequest : public FPlayFabBaseModel
    {
		
		// [optional] Provide either the task ID or the task name to get a specific task. If not specified, return all defined tasks.
		TSharedPtr<FNameIdentifier> Identifier;
	
        FGetTasksRequest() :
			FPlayFabBaseModel(),
			Identifier(nullptr)
			{}
		
		FGetTasksRequest(const FGetTasksRequest& src) :
			FPlayFabBaseModel(),
			Identifier(src.Identifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.Identifier)) : nullptr)
			{}
			
		FGetTasksRequest(const TSharedPtr<FJsonObject>& obj) : FGetTasksRequest()
        {
            readFromValue(obj);
        }
		
		~FGetTasksRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FScheduledTask : public FPlayFabBaseModel
    {
		
		// [optional] ID of the task
		FString TaskId;
		// [optional] Name of the task. This is a unique identifier for tasks in the title.
		FString Name;
		// [optional] Description the task
		FString Description;
		// [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
		FString Schedule;
		// Whether the schedule is active. Inactive schedule will not trigger task execution.
		bool IsActive;
		// [optional] Task type.
		Boxed<ScheduledTaskType> Type;
		// [optional] Task parameter. Different types of task have different parameter structure. See each task type's create API documentation for the details.
		FMultitypeVar Parameter;
		// [optional] UTC time of last run
		OptionalTime LastRunTime;
		// [optional] UTC time of next run
		OptionalTime NextRunTime;
	
        FScheduledTask() :
			FPlayFabBaseModel(),
			TaskId(),
			Name(),
			Description(),
			Schedule(),
			IsActive(false),
			Type(),
			Parameter(),
			LastRunTime(),
			NextRunTime()
			{}
		
		FScheduledTask(const FScheduledTask& src) :
			FPlayFabBaseModel(),
			TaskId(src.TaskId),
			Name(src.Name),
			Description(src.Description),
			Schedule(src.Schedule),
			IsActive(src.IsActive),
			Type(src.Type),
			Parameter(src.Parameter),
			LastRunTime(src.LastRunTime),
			NextRunTime(src.NextRunTime)
			{}
			
		FScheduledTask(const TSharedPtr<FJsonObject>& obj) : FScheduledTask()
        {
            readFromValue(obj);
        }
		
		~FScheduledTask();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTasksResult : public FPlayFabBaseModel
    {
		
		// [optional] Result tasks. Empty if there is no task found.
		TArray<FScheduledTask> Tasks;
	
        FGetTasksResult() :
			FPlayFabBaseModel(),
			Tasks()
			{}
		
		FGetTasksResult(const FGetTasksResult& src) :
			FPlayFabBaseModel(),
			Tasks(src.Tasks)
			{}
			
		FGetTasksResult(const TSharedPtr<FJsonObject>& obj) : FGetTasksResult()
        {
            readFromValue(obj);
        }
		
		~FGetTasksResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTitleDataRequest : public FPlayFabBaseModel
    {
		
		// [optional] Specific keys to search for in the title data (leave null to get all keys)
		TArray<FString> Keys;
	
        FGetTitleDataRequest() :
			FPlayFabBaseModel(),
			Keys()
			{}
		
		FGetTitleDataRequest(const FGetTitleDataRequest& src) :
			FPlayFabBaseModel(),
			Keys(src.Keys)
			{}
			
		FGetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetTitleDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTitleDataResult : public FPlayFabBaseModel
    {
		
		// [optional] a dictionary object of key / value pairs
		TMap<FString, FString> Data;
	
        FGetTitleDataResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetTitleDataResult(const FGetTitleDataResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetTitleDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserBansRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FGetUserBansRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FGetUserBansRequest(const FGetUserBansRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FGetUserBansRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserBansRequest()
        {
            readFromValue(obj);
        }
		
		~FGetUserBansRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserBansResult : public FPlayFabBaseModel
    {
		
		// [optional] Information about the bans
		TArray<FBanInfo> BanData;
	
        FGetUserBansResult() :
			FPlayFabBaseModel(),
			BanData()
			{}
		
		FGetUserBansResult(const FGetUserBansResult& src) :
			FPlayFabBaseModel(),
			BanData(src.BanData)
			{}
			
		FGetUserBansResult(const TSharedPtr<FJsonObject>& obj) : FGetUserBansResult()
        {
            readFromValue(obj);
        }
		
		~FGetUserBansResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserDataRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Specific keys to search for in the custom user data.
		TArray<FString> Keys;
		// [optional] The version that currently exists according to the caller. The call will return the data for all of the keys if the version in the system is greater than this.
		OptionalUint32 IfChangedFromDataVersion;
	
        FGetUserDataRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Keys(),
			IfChangedFromDataVersion()
			{}
		
		FGetUserDataRequest(const FGetUserDataRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Keys(src.Keys),
			IfChangedFromDataVersion(src.IfChangedFromDataVersion)
			{}
			
		FGetUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetUserDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum UserDataPermission
	{
		UserDataPermissionPrivate,
		UserDataPermissionPublic
	};
	
	void writeUserDataPermissionEnumJSON(UserDataPermission enumVal, JsonWriter& writer);
	UserDataPermission readUserDataPermissionFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FUserDataRecord : public FPlayFabBaseModel
    {
		
		// [optional] Data stored for the specified user data key.
		FString Value;
		// Timestamp for when this data was last updated.
		FDateTime LastUpdated;
		// [optional] Indicates whether this data can be read by all users (public) or only the user (private). This is used for GetUserData requests being made by one player about another player.
		Boxed<UserDataPermission> Permission;
	
        FUserDataRecord() :
			FPlayFabBaseModel(),
			Value(),
			LastUpdated(0),
			Permission()
			{}
		
		FUserDataRecord(const FUserDataRecord& src) :
			FPlayFabBaseModel(),
			Value(src.Value),
			LastUpdated(src.LastUpdated),
			Permission(src.Permission)
			{}
			
		FUserDataRecord(const TSharedPtr<FJsonObject>& obj) : FUserDataRecord()
        {
            readFromValue(obj);
        }
		
		~FUserDataRecord();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserDataResult : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier of the user whose custom data is being returned.
		FString PlayFabId;
		// Indicates the current version of the data that has been set. This is incremented with every set call for that type of data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
		uint32 DataVersion;
		// [optional] User specific data for this title.
		TMap<FString, FUserDataRecord> Data;
	
        FGetUserDataResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			DataVersion(0),
			Data()
			{}
		
		FGetUserDataResult(const FGetUserDataResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			DataVersion(src.DataVersion),
			Data(src.Data)
			{}
			
		FGetUserDataResult(const TSharedPtr<FJsonObject>& obj) : FGetUserDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetUserDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserInventoryRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FGetUserInventoryRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FGetUserInventoryRequest(const FGetUserInventoryRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FGetUserInventoryRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryRequest()
        {
            readFromValue(obj);
        }
		
		~FGetUserInventoryRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FItemInstance : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the inventory item, as defined in the catalog.
		FString ItemId;
		// [optional] Unique item identifier for this specific instance of the item.
		FString ItemInstanceId;
		// [optional] Class name for the inventory item, as defined in the catalog.
		FString ItemClass;
		// [optional] Timestamp for when this instance was purchased.
		OptionalTime PurchaseDate;
		// [optional] Timestamp for when this instance will expire.
		OptionalTime Expiration;
		// [optional] Total number of remaining uses, if this is a consumable item.
		OptionalInt32 RemainingUses;
		// [optional] The number of uses that were added or removed to this item in this call.
		OptionalInt32 UsesIncrementedBy;
		// [optional] Game specific comment associated with this instance when it was added to the user inventory.
		FString Annotation;
		// [optional] Catalog version for the inventory item, when this instance was created.
		FString CatalogVersion;
		// [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or container.
		FString BundleParent;
		// [optional] CatalogItem.DisplayName at the time this item was purchased.
		FString DisplayName;
		// [optional] Currency type for the cost of the catalog item.
		FString UnitCurrency;
		// Cost of the catalog item in the given currency.
		uint32 UnitPrice;
		// [optional] Array of unique items that were awarded when this catalog item was purchased.
		TArray<FString> BundleContents;
		// [optional] A set of custom key-value pairs on the inventory item.
		TMap<FString, FString> CustomData;
	
        FItemInstance() :
			FPlayFabBaseModel(),
			ItemId(),
			ItemInstanceId(),
			ItemClass(),
			PurchaseDate(),
			Expiration(),
			RemainingUses(),
			UsesIncrementedBy(),
			Annotation(),
			CatalogVersion(),
			BundleParent(),
			DisplayName(),
			UnitCurrency(),
			UnitPrice(0),
			BundleContents(),
			CustomData()
			{}
		
		FItemInstance(const FItemInstance& src) :
			FPlayFabBaseModel(),
			ItemId(src.ItemId),
			ItemInstanceId(src.ItemInstanceId),
			ItemClass(src.ItemClass),
			PurchaseDate(src.PurchaseDate),
			Expiration(src.Expiration),
			RemainingUses(src.RemainingUses),
			UsesIncrementedBy(src.UsesIncrementedBy),
			Annotation(src.Annotation),
			CatalogVersion(src.CatalogVersion),
			BundleParent(src.BundleParent),
			DisplayName(src.DisplayName),
			UnitCurrency(src.UnitCurrency),
			UnitPrice(src.UnitPrice),
			BundleContents(src.BundleContents),
			CustomData(src.CustomData)
			{}
			
		FItemInstance(const TSharedPtr<FJsonObject>& obj) : FItemInstance()
        {
            readFromValue(obj);
        }
		
		~FItemInstance();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FVirtualCurrencyRechargeTime : public FPlayFabBaseModel
    {
		
		// Time remaining (in seconds) before the next recharge increment of the virtual currency.
		int32 SecondsToRecharge;
		// Server timestamp in UTC indicating the next time the virtual currency will be incremented.
		FDateTime RechargeTime;
		// Maximum value to which the regenerating currency will automatically increment. Note that it can exceed this value through use of the AddUserVirtualCurrency API call. However, it will not regenerate automatically until it has fallen below this value.
		int32 RechargeMax;
	
        FVirtualCurrencyRechargeTime() :
			FPlayFabBaseModel(),
			SecondsToRecharge(0),
			RechargeTime(0),
			RechargeMax(0)
			{}
		
		FVirtualCurrencyRechargeTime(const FVirtualCurrencyRechargeTime& src) :
			FPlayFabBaseModel(),
			SecondsToRecharge(src.SecondsToRecharge),
			RechargeTime(src.RechargeTime),
			RechargeMax(src.RechargeMax)
			{}
			
		FVirtualCurrencyRechargeTime(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyRechargeTime()
        {
            readFromValue(obj);
        }
		
		~FVirtualCurrencyRechargeTime();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserInventoryResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Array of inventory items belonging to the user.
		TArray<FItemInstance> Inventory;
		// [optional] Array of virtual currency balance(s) belonging to the user.
		TMap<FString, int32> VirtualCurrency;
		// [optional] Array of remaining times and timestamps for virtual currencies.
		TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
	
        FGetUserInventoryResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Inventory(),
			VirtualCurrency(),
			VirtualCurrencyRechargeTimes()
			{}
		
		FGetUserInventoryResult(const FGetUserInventoryResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Inventory(src.Inventory),
			VirtualCurrency(src.VirtualCurrency),
			VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes)
			{}
			
		FGetUserInventoryResult(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryResult()
        {
            readFromValue(obj);
        }
		
		~FGetUserInventoryResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantedItemInstance : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// Result of this operation.
		bool Result;
		// [optional] Unique identifier for the inventory item, as defined in the catalog.
		FString ItemId;
		// [optional] Unique item identifier for this specific instance of the item.
		FString ItemInstanceId;
		// [optional] Class name for the inventory item, as defined in the catalog.
		FString ItemClass;
		// [optional] Timestamp for when this instance was purchased.
		OptionalTime PurchaseDate;
		// [optional] Timestamp for when this instance will expire.
		OptionalTime Expiration;
		// [optional] Total number of remaining uses, if this is a consumable item.
		OptionalInt32 RemainingUses;
		// [optional] The number of uses that were added or removed to this item in this call.
		OptionalInt32 UsesIncrementedBy;
		// [optional] Game specific comment associated with this instance when it was added to the user inventory.
		FString Annotation;
		// [optional] Catalog version for the inventory item, when this instance was created.
		FString CatalogVersion;
		// [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or container.
		FString BundleParent;
		// [optional] CatalogItem.DisplayName at the time this item was purchased.
		FString DisplayName;
		// [optional] Currency type for the cost of the catalog item.
		FString UnitCurrency;
		// Cost of the catalog item in the given currency.
		uint32 UnitPrice;
		// [optional] Array of unique items that were awarded when this catalog item was purchased.
		TArray<FString> BundleContents;
		// [optional] A set of custom key-value pairs on the inventory item.
		TMap<FString, FString> CustomData;
	
        FGrantedItemInstance() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			Result(false),
			ItemId(),
			ItemInstanceId(),
			ItemClass(),
			PurchaseDate(),
			Expiration(),
			RemainingUses(),
			UsesIncrementedBy(),
			Annotation(),
			CatalogVersion(),
			BundleParent(),
			DisplayName(),
			UnitCurrency(),
			UnitPrice(0),
			BundleContents(),
			CustomData()
			{}
		
		FGrantedItemInstance(const FGrantedItemInstance& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			Result(src.Result),
			ItemId(src.ItemId),
			ItemInstanceId(src.ItemInstanceId),
			ItemClass(src.ItemClass),
			PurchaseDate(src.PurchaseDate),
			Expiration(src.Expiration),
			RemainingUses(src.RemainingUses),
			UsesIncrementedBy(src.UsesIncrementedBy),
			Annotation(src.Annotation),
			CatalogVersion(src.CatalogVersion),
			BundleParent(src.BundleParent),
			DisplayName(src.DisplayName),
			UnitCurrency(src.UnitCurrency),
			UnitPrice(src.UnitPrice),
			BundleContents(src.BundleContents),
			CustomData(src.CustomData)
			{}
			
		FGrantedItemInstance(const TSharedPtr<FJsonObject>& obj) : FGrantedItemInstance()
        {
            readFromValue(obj);
        }
		
		~FGrantedItemInstance();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FItemGrant : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique identifier of the catalog item to be granted to the user.
		FString ItemId;
		// [optional] String detailing any additional information concerning this operation.
		FString Annotation;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
	
        FItemGrant() :
			FPlayFabBaseModel(),
			PlayFabId(),
			ItemId(),
			Annotation(),
			CharacterId(),
			Data(),
			KeysToRemove()
			{}
		
		FItemGrant(const FItemGrant& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			ItemId(src.ItemId),
			Annotation(src.Annotation),
			CharacterId(src.CharacterId),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove)
			{}
			
		FItemGrant(const TSharedPtr<FJsonObject>& obj) : FItemGrant()
        {
            readFromValue(obj);
        }
		
		~FItemGrant();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantItemsToUsersRequest : public FPlayFabBaseModel
    {
		
		// [optional] Catalog version from which items are to be granted.
		FString CatalogVersion;
		// Array of items to grant and the users to whom the items are to be granted.
		TArray<FItemGrant> ItemGrants;
	
        FGrantItemsToUsersRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			ItemGrants()
			{}
		
		FGrantItemsToUsersRequest(const FGrantItemsToUsersRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			ItemGrants(src.ItemGrants)
			{}
			
		FGrantItemsToUsersRequest(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUsersRequest()
        {
            readFromValue(obj);
        }
		
		~FGrantItemsToUsersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantItemsToUsersResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of items granted to users.
		TArray<FGrantedItemInstance> ItemGrantResults;
	
        FGrantItemsToUsersResult() :
			FPlayFabBaseModel(),
			ItemGrantResults()
			{}
		
		FGrantItemsToUsersResult(const FGrantItemsToUsersResult& src) :
			FPlayFabBaseModel(),
			ItemGrantResults(src.ItemGrantResults)
			{}
			
		FGrantItemsToUsersResult(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUsersResult()
        {
            readFromValue(obj);
        }
		
		~FGrantItemsToUsersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FIncrementPlayerStatisticVersionRequest : public FPlayFabBaseModel
    {
		
		// [optional] unique name of the statistic
		FString StatisticName;
	
        FIncrementPlayerStatisticVersionRequest() :
			FPlayFabBaseModel(),
			StatisticName()
			{}
		
		FIncrementPlayerStatisticVersionRequest(const FIncrementPlayerStatisticVersionRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName)
			{}
			
		FIncrementPlayerStatisticVersionRequest(const TSharedPtr<FJsonObject>& obj) : FIncrementPlayerStatisticVersionRequest()
        {
            readFromValue(obj);
        }
		
		~FIncrementPlayerStatisticVersionRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FIncrementPlayerStatisticVersionResult : public FPlayFabBaseModel
    {
		
		// [optional] version change history of the statistic
		TSharedPtr<FPlayerStatisticVersion> StatisticVersion;
	
        FIncrementPlayerStatisticVersionResult() :
			FPlayFabBaseModel(),
			StatisticVersion(nullptr)
			{}
		
		FIncrementPlayerStatisticVersionResult(const FIncrementPlayerStatisticVersionResult& src) :
			FPlayFabBaseModel(),
			StatisticVersion(src.StatisticVersion.IsValid() ? MakeShareable(new FPlayerStatisticVersion(*src.StatisticVersion)) : nullptr)
			{}
			
		FIncrementPlayerStatisticVersionResult(const TSharedPtr<FJsonObject>& obj) : FIncrementPlayerStatisticVersionResult()
        {
            readFromValue(obj);
        }
		
		~FIncrementPlayerStatisticVersionResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FListBuildsRequest : public FPlayFabBaseModel
    {
		
	
        FListBuildsRequest() :
			FPlayFabBaseModel()
			{}
		
		FListBuildsRequest(const FListBuildsRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FListBuildsRequest(const TSharedPtr<FJsonObject>& obj) : FListBuildsRequest()
        {
            readFromValue(obj);
        }
		
		~FListBuildsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FListBuildsResult : public FPlayFabBaseModel
    {
		
		// [optional] array of uploaded game server builds
		TArray<FGetServerBuildInfoResult> Builds;
	
        FListBuildsResult() :
			FPlayFabBaseModel(),
			Builds()
			{}
		
		FListBuildsResult(const FListBuildsResult& src) :
			FPlayFabBaseModel(),
			Builds(src.Builds)
			{}
			
		FListBuildsResult(const TSharedPtr<FJsonObject>& obj) : FListBuildsResult()
        {
            readFromValue(obj);
        }
		
		~FListBuildsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FListVirtualCurrencyTypesRequest : public FPlayFabBaseModel
    {
		
	
        FListVirtualCurrencyTypesRequest() :
			FPlayFabBaseModel()
			{}
		
		FListVirtualCurrencyTypesRequest(const FListVirtualCurrencyTypesRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FListVirtualCurrencyTypesRequest(const TSharedPtr<FJsonObject>& obj) : FListVirtualCurrencyTypesRequest()
        {
            readFromValue(obj);
        }
		
		~FListVirtualCurrencyTypesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FListVirtualCurrencyTypesResult : public FPlayFabBaseModel
    {
		
		// [optional] List of virtual currency names defined for this title
		TArray<FVirtualCurrencyData> VirtualCurrencies;
	
        FListVirtualCurrencyTypesResult() :
			FPlayFabBaseModel(),
			VirtualCurrencies()
			{}
		
		FListVirtualCurrencyTypesResult(const FListVirtualCurrencyTypesResult& src) :
			FPlayFabBaseModel(),
			VirtualCurrencies(src.VirtualCurrencies)
			{}
			
		FListVirtualCurrencyTypesResult(const TSharedPtr<FJsonObject>& obj) : FListVirtualCurrencyTypesResult()
        {
            readFromValue(obj);
        }
		
		~FListVirtualCurrencyTypesResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLookupUserAccountInfoRequest : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] User email address attached to their account
		FString Email;
		// [optional] PlayFab username for the account (3-20 characters)
		FString Username;
		// [optional] Title specific username to match against existing user accounts
		FString TitleDisplayName;
	
        FLookupUserAccountInfoRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Email(),
			Username(),
			TitleDisplayName()
			{}
		
		FLookupUserAccountInfoRequest(const FLookupUserAccountInfoRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Email(src.Email),
			Username(src.Username),
			TitleDisplayName(src.TitleDisplayName)
			{}
			
		FLookupUserAccountInfoRequest(const TSharedPtr<FJsonObject>& obj) : FLookupUserAccountInfoRequest()
        {
            readFromValue(obj);
        }
		
		~FLookupUserAccountInfoRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum UserOrigination
	{
		UserOriginationOrganic,
		UserOriginationSteam,
		UserOriginationGoogle,
		UserOriginationAmazon,
		UserOriginationFacebook,
		UserOriginationKongregate,
		UserOriginationGamersFirst,
		UserOriginationUnknown,
		UserOriginationIOS,
		UserOriginationLoadTest,
		UserOriginationAndroid,
		UserOriginationPSN,
		UserOriginationGameCenter,
		UserOriginationCustomId,
		UserOriginationXboxLive,
		UserOriginationParse,
		UserOriginationTwitch
	};
	
	void writeUserOriginationEnumJSON(UserOrigination enumVal, JsonWriter& writer);
	UserOrigination readUserOriginationFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FUserTitleInfo : public FPlayFabBaseModel
    {
		
		// [optional] name of the user, as it is displayed in-game
		FString DisplayName;
		// [optional] source by which the user first joined the game, if known
		Boxed<UserOrigination> Origination;
		// timestamp indicating when the user was first associated with this game (this can differ significantly from when the user first registered with PlayFab)
		FDateTime Created;
		// [optional] timestamp for the last user login for this title
		OptionalTime LastLogin;
		// [optional] timestamp indicating when the user first signed into this game (this can differ from the Created timestamp, as other events, such as issuing a beta key to the user, can associate the title to the user)
		OptionalTime FirstLogin;
		// [optional] boolean indicating whether or not the user is currently banned for a title
		OptionalBool isBanned;
	
        FUserTitleInfo() :
			FPlayFabBaseModel(),
			DisplayName(),
			Origination(),
			Created(0),
			LastLogin(),
			FirstLogin(),
			isBanned()
			{}
		
		FUserTitleInfo(const FUserTitleInfo& src) :
			FPlayFabBaseModel(),
			DisplayName(src.DisplayName),
			Origination(src.Origination),
			Created(src.Created),
			LastLogin(src.LastLogin),
			FirstLogin(src.FirstLogin),
			isBanned(src.isBanned)
			{}
			
		FUserTitleInfo(const TSharedPtr<FJsonObject>& obj) : FUserTitleInfo()
        {
            readFromValue(obj);
        }
		
		~FUserTitleInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserPrivateAccountInfo : public FPlayFabBaseModel
    {
		
		// [optional] user email address
		FString Email;
	
        FUserPrivateAccountInfo() :
			FPlayFabBaseModel(),
			Email()
			{}
		
		FUserPrivateAccountInfo(const FUserPrivateAccountInfo& src) :
			FPlayFabBaseModel(),
			Email(src.Email)
			{}
			
		FUserPrivateAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserPrivateAccountInfo()
        {
            readFromValue(obj);
        }
		
		~FUserPrivateAccountInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserFacebookInfo : public FPlayFabBaseModel
    {
		
		// [optional] Facebook identifier
		FString FacebookId;
		// [optional] Facebook full name
		FString FullName;
	
        FUserFacebookInfo() :
			FPlayFabBaseModel(),
			FacebookId(),
			FullName()
			{}
		
		FUserFacebookInfo(const FUserFacebookInfo& src) :
			FPlayFabBaseModel(),
			FacebookId(src.FacebookId),
			FullName(src.FullName)
			{}
			
		FUserFacebookInfo(const TSharedPtr<FJsonObject>& obj) : FUserFacebookInfo()
        {
            readFromValue(obj);
        }
		
		~FUserFacebookInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum TitleActivationStatus
	{
		TitleActivationStatusNone,
		TitleActivationStatusActivatedTitleKey,
		TitleActivationStatusPendingSteam,
		TitleActivationStatusActivatedSteam,
		TitleActivationStatusRevokedSteam
	};
	
	void writeTitleActivationStatusEnumJSON(TitleActivationStatus enumVal, JsonWriter& writer);
	TitleActivationStatus readTitleActivationStatusFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FUserSteamInfo : public FPlayFabBaseModel
    {
		
		// [optional] Steam identifier
		FString SteamId;
		// [optional] the country in which the player resides, from Steam data
		FString SteamCountry;
		// [optional] currency type set in the user Steam account
		Boxed<Currency> SteamCurrency;
		// [optional] what stage of game ownership the user is listed as being in, from Steam
		Boxed<TitleActivationStatus> SteamActivationStatus;
	
        FUserSteamInfo() :
			FPlayFabBaseModel(),
			SteamId(),
			SteamCountry(),
			SteamCurrency(),
			SteamActivationStatus()
			{}
		
		FUserSteamInfo(const FUserSteamInfo& src) :
			FPlayFabBaseModel(),
			SteamId(src.SteamId),
			SteamCountry(src.SteamCountry),
			SteamCurrency(src.SteamCurrency),
			SteamActivationStatus(src.SteamActivationStatus)
			{}
			
		FUserSteamInfo(const TSharedPtr<FJsonObject>& obj) : FUserSteamInfo()
        {
            readFromValue(obj);
        }
		
		~FUserSteamInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserGameCenterInfo : public FPlayFabBaseModel
    {
		
		// [optional] Gamecenter identifier
		FString GameCenterId;
	
        FUserGameCenterInfo() :
			FPlayFabBaseModel(),
			GameCenterId()
			{}
		
		FUserGameCenterInfo(const FUserGameCenterInfo& src) :
			FPlayFabBaseModel(),
			GameCenterId(src.GameCenterId)
			{}
			
		FUserGameCenterInfo(const TSharedPtr<FJsonObject>& obj) : FUserGameCenterInfo()
        {
            readFromValue(obj);
        }
		
		~FUserGameCenterInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserIosDeviceInfo : public FPlayFabBaseModel
    {
		
		// [optional] iOS device ID
		FString IosDeviceId;
	
        FUserIosDeviceInfo() :
			FPlayFabBaseModel(),
			IosDeviceId()
			{}
		
		FUserIosDeviceInfo(const FUserIosDeviceInfo& src) :
			FPlayFabBaseModel(),
			IosDeviceId(src.IosDeviceId)
			{}
			
		FUserIosDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserIosDeviceInfo()
        {
            readFromValue(obj);
        }
		
		~FUserIosDeviceInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserAndroidDeviceInfo : public FPlayFabBaseModel
    {
		
		// [optional] Android device ID
		FString AndroidDeviceId;
	
        FUserAndroidDeviceInfo() :
			FPlayFabBaseModel(),
			AndroidDeviceId()
			{}
		
		FUserAndroidDeviceInfo(const FUserAndroidDeviceInfo& src) :
			FPlayFabBaseModel(),
			AndroidDeviceId(src.AndroidDeviceId)
			{}
			
		FUserAndroidDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserAndroidDeviceInfo()
        {
            readFromValue(obj);
        }
		
		~FUserAndroidDeviceInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserKongregateInfo : public FPlayFabBaseModel
    {
		
		// [optional] Kongregate ID
		FString KongregateId;
		// [optional] Kongregate Username
		FString KongregateName;
	
        FUserKongregateInfo() :
			FPlayFabBaseModel(),
			KongregateId(),
			KongregateName()
			{}
		
		FUserKongregateInfo(const FUserKongregateInfo& src) :
			FPlayFabBaseModel(),
			KongregateId(src.KongregateId),
			KongregateName(src.KongregateName)
			{}
			
		FUserKongregateInfo(const TSharedPtr<FJsonObject>& obj) : FUserKongregateInfo()
        {
            readFromValue(obj);
        }
		
		~FUserKongregateInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserTwitchInfo : public FPlayFabBaseModel
    {
		
		// [optional] Twitch ID
		FString TwitchId;
		// [optional] Twitch Username
		FString TwitchUserName;
	
        FUserTwitchInfo() :
			FPlayFabBaseModel(),
			TwitchId(),
			TwitchUserName()
			{}
		
		FUserTwitchInfo(const FUserTwitchInfo& src) :
			FPlayFabBaseModel(),
			TwitchId(src.TwitchId),
			TwitchUserName(src.TwitchUserName)
			{}
			
		FUserTwitchInfo(const TSharedPtr<FJsonObject>& obj) : FUserTwitchInfo()
        {
            readFromValue(obj);
        }
		
		~FUserTwitchInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserPsnInfo : public FPlayFabBaseModel
    {
		
		// [optional] PSN account ID
		FString PsnAccountId;
		// [optional] PSN online ID
		FString PsnOnlineId;
	
        FUserPsnInfo() :
			FPlayFabBaseModel(),
			PsnAccountId(),
			PsnOnlineId()
			{}
		
		FUserPsnInfo(const FUserPsnInfo& src) :
			FPlayFabBaseModel(),
			PsnAccountId(src.PsnAccountId),
			PsnOnlineId(src.PsnOnlineId)
			{}
			
		FUserPsnInfo(const TSharedPtr<FJsonObject>& obj) : FUserPsnInfo()
        {
            readFromValue(obj);
        }
		
		~FUserPsnInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserGoogleInfo : public FPlayFabBaseModel
    {
		
		// [optional] Google ID
		FString GoogleId;
		// [optional] Email address of the Google account
		FString GoogleEmail;
		// [optional] Locale of the Google account
		FString GoogleLocale;
		// [optional] Gender information of the Google account
		FString GoogleGender;
	
        FUserGoogleInfo() :
			FPlayFabBaseModel(),
			GoogleId(),
			GoogleEmail(),
			GoogleLocale(),
			GoogleGender()
			{}
		
		FUserGoogleInfo(const FUserGoogleInfo& src) :
			FPlayFabBaseModel(),
			GoogleId(src.GoogleId),
			GoogleEmail(src.GoogleEmail),
			GoogleLocale(src.GoogleLocale),
			GoogleGender(src.GoogleGender)
			{}
			
		FUserGoogleInfo(const TSharedPtr<FJsonObject>& obj) : FUserGoogleInfo()
        {
            readFromValue(obj);
        }
		
		~FUserGoogleInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserXboxInfo : public FPlayFabBaseModel
    {
		
		// [optional] XBox user ID
		FString XboxUserId;
	
        FUserXboxInfo() :
			FPlayFabBaseModel(),
			XboxUserId()
			{}
		
		FUserXboxInfo(const FUserXboxInfo& src) :
			FPlayFabBaseModel(),
			XboxUserId(src.XboxUserId)
			{}
			
		FUserXboxInfo(const TSharedPtr<FJsonObject>& obj) : FUserXboxInfo()
        {
            readFromValue(obj);
        }
		
		~FUserXboxInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserCustomIdInfo : public FPlayFabBaseModel
    {
		
		// [optional] Custom ID
		FString CustomId;
	
        FUserCustomIdInfo() :
			FPlayFabBaseModel(),
			CustomId()
			{}
		
		FUserCustomIdInfo(const FUserCustomIdInfo& src) :
			FPlayFabBaseModel(),
			CustomId(src.CustomId)
			{}
			
		FUserCustomIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserCustomIdInfo()
        {
            readFromValue(obj);
        }
		
		~FUserCustomIdInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserAccountInfo : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the user account
		FString PlayFabId;
		// Timestamp indicating when the user account was created
		FDateTime Created;
		// [optional] User account name in the PlayFab service
		FString Username;
		// [optional] Title-specific information for the user account
		TSharedPtr<FUserTitleInfo> TitleInfo;
		// [optional] Personal information for the user which is considered more sensitive
		TSharedPtr<FUserPrivateAccountInfo> PrivateInfo;
		// [optional] User Facebook information, if a Facebook account has been linked
		TSharedPtr<FUserFacebookInfo> FacebookInfo;
		// [optional] User Steam information, if a Steam account has been linked
		TSharedPtr<FUserSteamInfo> SteamInfo;
		// [optional] User Gamecenter information, if a Gamecenter account has been linked
		TSharedPtr<FUserGameCenterInfo> GameCenterInfo;
		// [optional] User iOS device information, if an iOS device has been linked
		TSharedPtr<FUserIosDeviceInfo> IosDeviceInfo;
		// [optional] User Android device information, if an Android device has been linked
		TSharedPtr<FUserAndroidDeviceInfo> AndroidDeviceInfo;
		// [optional] User Kongregate account information, if a Kongregate account has been linked
		TSharedPtr<FUserKongregateInfo> KongregateInfo;
		// [optional] User Twitch account information, if a Twitch account has been linked
		TSharedPtr<FUserTwitchInfo> TwitchInfo;
		// [optional] User PSN account information, if a PSN account has been linked
		TSharedPtr<FUserPsnInfo> PsnInfo;
		// [optional] User Google account information, if a Google account has been linked
		TSharedPtr<FUserGoogleInfo> GoogleInfo;
		// [optional] User XBox account information, if a XBox account has been linked
		TSharedPtr<FUserXboxInfo> XboxInfo;
		// [optional] Custom ID information, if a custom ID has been assigned
		TSharedPtr<FUserCustomIdInfo> CustomIdInfo;
	
        FUserAccountInfo() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Created(0),
			Username(),
			TitleInfo(nullptr),
			PrivateInfo(nullptr),
			FacebookInfo(nullptr),
			SteamInfo(nullptr),
			GameCenterInfo(nullptr),
			IosDeviceInfo(nullptr),
			AndroidDeviceInfo(nullptr),
			KongregateInfo(nullptr),
			TwitchInfo(nullptr),
			PsnInfo(nullptr),
			GoogleInfo(nullptr),
			XboxInfo(nullptr),
			CustomIdInfo(nullptr)
			{}
		
		FUserAccountInfo(const FUserAccountInfo& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Created(src.Created),
			Username(src.Username),
			TitleInfo(src.TitleInfo.IsValid() ? MakeShareable(new FUserTitleInfo(*src.TitleInfo)) : nullptr),
			PrivateInfo(src.PrivateInfo.IsValid() ? MakeShareable(new FUserPrivateAccountInfo(*src.PrivateInfo)) : nullptr),
			FacebookInfo(src.FacebookInfo.IsValid() ? MakeShareable(new FUserFacebookInfo(*src.FacebookInfo)) : nullptr),
			SteamInfo(src.SteamInfo.IsValid() ? MakeShareable(new FUserSteamInfo(*src.SteamInfo)) : nullptr),
			GameCenterInfo(src.GameCenterInfo.IsValid() ? MakeShareable(new FUserGameCenterInfo(*src.GameCenterInfo)) : nullptr),
			IosDeviceInfo(src.IosDeviceInfo.IsValid() ? MakeShareable(new FUserIosDeviceInfo(*src.IosDeviceInfo)) : nullptr),
			AndroidDeviceInfo(src.AndroidDeviceInfo.IsValid() ? MakeShareable(new FUserAndroidDeviceInfo(*src.AndroidDeviceInfo)) : nullptr),
			KongregateInfo(src.KongregateInfo.IsValid() ? MakeShareable(new FUserKongregateInfo(*src.KongregateInfo)) : nullptr),
			TwitchInfo(src.TwitchInfo.IsValid() ? MakeShareable(new FUserTwitchInfo(*src.TwitchInfo)) : nullptr),
			PsnInfo(src.PsnInfo.IsValid() ? MakeShareable(new FUserPsnInfo(*src.PsnInfo)) : nullptr),
			GoogleInfo(src.GoogleInfo.IsValid() ? MakeShareable(new FUserGoogleInfo(*src.GoogleInfo)) : nullptr),
			XboxInfo(src.XboxInfo.IsValid() ? MakeShareable(new FUserXboxInfo(*src.XboxInfo)) : nullptr),
			CustomIdInfo(src.CustomIdInfo.IsValid() ? MakeShareable(new FUserCustomIdInfo(*src.CustomIdInfo)) : nullptr)
			{}
			
		FUserAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserAccountInfo()
        {
            readFromValue(obj);
        }
		
		~FUserAccountInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLookupUserAccountInfoResult : public FPlayFabBaseModel
    {
		
		// [optional] User info for the user matching the request
		TSharedPtr<FUserAccountInfo> UserInfo;
	
        FLookupUserAccountInfoResult() :
			FPlayFabBaseModel(),
			UserInfo(nullptr)
			{}
		
		FLookupUserAccountInfoResult(const FLookupUserAccountInfoResult& src) :
			FPlayFabBaseModel(),
			UserInfo(src.UserInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.UserInfo)) : nullptr)
			{}
			
		FLookupUserAccountInfoResult(const TSharedPtr<FJsonObject>& obj) : FLookupUserAccountInfoResult()
        {
            readFromValue(obj);
        }
		
		~FLookupUserAccountInfoResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FModifyMatchmakerGameModesRequest : public FPlayFabBaseModel
    {
		
		// previously uploaded build version for which game modes are being specified
		FString BuildVersion;
		// array of game modes (Note: this will replace all game modes for the indicated build version)
		TArray<FGameModeInfo> GameModes;
	
        FModifyMatchmakerGameModesRequest() :
			FPlayFabBaseModel(),
			BuildVersion(),
			GameModes()
			{}
		
		FModifyMatchmakerGameModesRequest(const FModifyMatchmakerGameModesRequest& src) :
			FPlayFabBaseModel(),
			BuildVersion(src.BuildVersion),
			GameModes(src.GameModes)
			{}
			
		FModifyMatchmakerGameModesRequest(const TSharedPtr<FJsonObject>& obj) : FModifyMatchmakerGameModesRequest()
        {
            readFromValue(obj);
        }
		
		~FModifyMatchmakerGameModesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FModifyMatchmakerGameModesResult : public FPlayFabBaseModel
    {
		
	
        FModifyMatchmakerGameModesResult() :
			FPlayFabBaseModel()
			{}
		
		FModifyMatchmakerGameModesResult(const FModifyMatchmakerGameModesResult& src) :
			FPlayFabBaseModel()
			{}
			
		FModifyMatchmakerGameModesResult(const TSharedPtr<FJsonObject>& obj) : FModifyMatchmakerGameModesResult()
        {
            readFromValue(obj);
        }
		
		~FModifyMatchmakerGameModesResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FModifyServerBuildRequest : public FPlayFabBaseModel
    {
		
		// unique identifier of the previously uploaded build executable to be updated
		FString BuildId;
		// [optional] new timestamp
		OptionalTime Timestamp;
		// [optional] array of regions where this build can used, when it is active
		TArray<Region> ActiveRegions;
		// maximum number of game server instances that can run on a single host machine
		int32 MaxGamesPerHost;
		// minimum capacity of additional game server instances that can be started before the autoscaling service starts new host machines (given the number of current running host machines and game server instances)
		int32 MinFreeGameSlots;
		// [optional] appended to the end of the command line when starting game servers
		FString CommandLineTemplate;
		// [optional] path to the game server executable. Defaults to gameserver.exe
		FString ExecutablePath;
		// [optional] developer comment(s) for this build
		FString Comment;
	
        FModifyServerBuildRequest() :
			FPlayFabBaseModel(),
			BuildId(),
			Timestamp(),
			ActiveRegions(),
			MaxGamesPerHost(0),
			MinFreeGameSlots(0),
			CommandLineTemplate(),
			ExecutablePath(),
			Comment()
			{}
		
		FModifyServerBuildRequest(const FModifyServerBuildRequest& src) :
			FPlayFabBaseModel(),
			BuildId(src.BuildId),
			Timestamp(src.Timestamp),
			ActiveRegions(src.ActiveRegions),
			MaxGamesPerHost(src.MaxGamesPerHost),
			MinFreeGameSlots(src.MinFreeGameSlots),
			CommandLineTemplate(src.CommandLineTemplate),
			ExecutablePath(src.ExecutablePath),
			Comment(src.Comment)
			{}
			
		FModifyServerBuildRequest(const TSharedPtr<FJsonObject>& obj) : FModifyServerBuildRequest()
        {
            readFromValue(obj);
        }
		
		~FModifyServerBuildRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FModifyServerBuildResult : public FPlayFabBaseModel
    {
		
		// [optional] unique identifier for this build executable
		FString BuildId;
		// [optional] array of regions where this build can used, when it is active
		TArray<Region> ActiveRegions;
		// maximum number of game server instances that can run on a single host machine
		int32 MaxGamesPerHost;
		// minimum capacity of additional game server instances that can be started before the autoscaling service starts new host machines (given the number of current running host machines and game server instances)
		int32 MinFreeGameSlots;
		// [optional] appended to the end of the command line when starting game servers
		FString CommandLineTemplate;
		// [optional] path to the game server executable. Defaults to gameserver.exe
		FString ExecutablePath;
		// [optional] developer comment(s) for this build
		FString Comment;
		// time this build was last modified (or uploaded, if this build has never been modified)
		FDateTime Timestamp;
		// [optional] Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// [optional] the current status of the build validation and processing steps
		Boxed<GameBuildStatus> Status;
	
        FModifyServerBuildResult() :
			FPlayFabBaseModel(),
			BuildId(),
			ActiveRegions(),
			MaxGamesPerHost(0),
			MinFreeGameSlots(0),
			CommandLineTemplate(),
			ExecutablePath(),
			Comment(),
			Timestamp(0),
			TitleId(),
			Status()
			{}
		
		FModifyServerBuildResult(const FModifyServerBuildResult& src) :
			FPlayFabBaseModel(),
			BuildId(src.BuildId),
			ActiveRegions(src.ActiveRegions),
			MaxGamesPerHost(src.MaxGamesPerHost),
			MinFreeGameSlots(src.MinFreeGameSlots),
			CommandLineTemplate(src.CommandLineTemplate),
			ExecutablePath(src.ExecutablePath),
			Comment(src.Comment),
			Timestamp(src.Timestamp),
			TitleId(src.TitleId),
			Status(src.Status)
			{}
			
		FModifyServerBuildResult(const TSharedPtr<FJsonObject>& obj) : FModifyServerBuildResult()
        {
            readFromValue(obj);
        }
		
		~FModifyServerBuildResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FModifyUserVirtualCurrencyResult : public FPlayFabBaseModel
    {
		
		// [optional] User currency was subtracted from.
		FString PlayFabId;
		// [optional] Name of the virtual currency which was modified.
		FString VirtualCurrency;
		// Amount added or subtracted from the user's virtual currency. Maximum VC balance is Int32 (2,147,483,647). Any increase over this value will be discarded.
		int32 BalanceChange;
		// Balance of the virtual currency after modification.
		int32 Balance;
	
        FModifyUserVirtualCurrencyResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			VirtualCurrency(),
			BalanceChange(0),
			Balance(0)
			{}
		
		FModifyUserVirtualCurrencyResult(const FModifyUserVirtualCurrencyResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			VirtualCurrency(src.VirtualCurrency),
			BalanceChange(src.BalanceChange),
			Balance(src.Balance)
			{}
			
		FModifyUserVirtualCurrencyResult(const TSharedPtr<FJsonObject>& obj) : FModifyUserVirtualCurrencyResult()
        {
            readFromValue(obj);
        }
		
		~FModifyUserVirtualCurrencyResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRandomResultTable : public FPlayFabBaseModel
    {
		
		// Unique name for this drop table
		FString TableId;
		// Child nodes that indicate what kind of drop table item this actually is.
		TArray<FResultTableNode> Nodes;
	
        FRandomResultTable() :
			FPlayFabBaseModel(),
			TableId(),
			Nodes()
			{}
		
		FRandomResultTable(const FRandomResultTable& src) :
			FPlayFabBaseModel(),
			TableId(src.TableId),
			Nodes(src.Nodes)
			{}
			
		FRandomResultTable(const TSharedPtr<FJsonObject>& obj) : FRandomResultTable()
        {
            readFromValue(obj);
        }
		
		~FRandomResultTable();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRefundPurchaseRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique order ID for the purchase in question.
		FString OrderId;
		// [optional] Reason for refund. In the case of Facebook this must match one of their refund or dispute resolution enums (See: https://developers.facebook.com/docs/payments/implementation-guide/handling-disputes-refunds)
		FString Reason;
	
        FRefundPurchaseRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			OrderId(),
			Reason()
			{}
		
		FRefundPurchaseRequest(const FRefundPurchaseRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			OrderId(src.OrderId),
			Reason(src.Reason)
			{}
			
		FRefundPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FRefundPurchaseRequest()
        {
            readFromValue(obj);
        }
		
		~FRefundPurchaseRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRefundPurchaseResponse : public FPlayFabBaseModel
    {
		
		// [optional] The order's updated purchase status.
		FString PurchaseStatus;
	
        FRefundPurchaseResponse() :
			FPlayFabBaseModel(),
			PurchaseStatus()
			{}
		
		FRefundPurchaseResponse(const FRefundPurchaseResponse& src) :
			FPlayFabBaseModel(),
			PurchaseStatus(src.PurchaseStatus)
			{}
			
		FRefundPurchaseResponse(const TSharedPtr<FJsonObject>& obj) : FRefundPurchaseResponse()
        {
            readFromValue(obj);
        }
		
		~FRefundPurchaseResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemovePlayerTagRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique tag for player profile.
		FString TagName;
	
        FRemovePlayerTagRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			TagName()
			{}
		
		FRemovePlayerTagRequest(const FRemovePlayerTagRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			TagName(src.TagName)
			{}
			
		FRemovePlayerTagRequest(const TSharedPtr<FJsonObject>& obj) : FRemovePlayerTagRequest()
        {
            readFromValue(obj);
        }
		
		~FRemovePlayerTagRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemovePlayerTagResult : public FPlayFabBaseModel
    {
		
	
        FRemovePlayerTagResult() :
			FPlayFabBaseModel()
			{}
		
		FRemovePlayerTagResult(const FRemovePlayerTagResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRemovePlayerTagResult(const TSharedPtr<FJsonObject>& obj) : FRemovePlayerTagResult()
        {
            readFromValue(obj);
        }
		
		~FRemovePlayerTagResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveServerBuildRequest : public FPlayFabBaseModel
    {
		
		// unique identifier of the previously uploaded build executable to be removed
		FString BuildId;
	
        FRemoveServerBuildRequest() :
			FPlayFabBaseModel(),
			BuildId()
			{}
		
		FRemoveServerBuildRequest(const FRemoveServerBuildRequest& src) :
			FPlayFabBaseModel(),
			BuildId(src.BuildId)
			{}
			
		FRemoveServerBuildRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveServerBuildRequest()
        {
            readFromValue(obj);
        }
		
		~FRemoveServerBuildRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveServerBuildResult : public FPlayFabBaseModel
    {
		
	
        FRemoveServerBuildResult() :
			FPlayFabBaseModel()
			{}
		
		FRemoveServerBuildResult(const FRemoveServerBuildResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRemoveServerBuildResult(const TSharedPtr<FJsonObject>& obj) : FRemoveServerBuildResult()
        {
            readFromValue(obj);
        }
		
		~FRemoveServerBuildResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveVirtualCurrencyTypesRequest : public FPlayFabBaseModel
    {
		
		// List of virtual currencies to delete
		TArray<FVirtualCurrencyData> VirtualCurrencies;
	
        FRemoveVirtualCurrencyTypesRequest() :
			FPlayFabBaseModel(),
			VirtualCurrencies()
			{}
		
		FRemoveVirtualCurrencyTypesRequest(const FRemoveVirtualCurrencyTypesRequest& src) :
			FPlayFabBaseModel(),
			VirtualCurrencies(src.VirtualCurrencies)
			{}
			
		FRemoveVirtualCurrencyTypesRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveVirtualCurrencyTypesRequest()
        {
            readFromValue(obj);
        }
		
		~FRemoveVirtualCurrencyTypesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FResetCharacterStatisticsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
	
        FResetCharacterStatisticsRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId()
			{}
		
		FResetCharacterStatisticsRequest(const FResetCharacterStatisticsRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId)
			{}
			
		FResetCharacterStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FResetCharacterStatisticsRequest()
        {
            readFromValue(obj);
        }
		
		~FResetCharacterStatisticsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FResetCharacterStatisticsResult : public FPlayFabBaseModel
    {
		
	
        FResetCharacterStatisticsResult() :
			FPlayFabBaseModel()
			{}
		
		FResetCharacterStatisticsResult(const FResetCharacterStatisticsResult& src) :
			FPlayFabBaseModel()
			{}
			
		FResetCharacterStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FResetCharacterStatisticsResult()
        {
            readFromValue(obj);
        }
		
		~FResetCharacterStatisticsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserCredentials : public FPlayFabBaseModel
    {
		
		// Username of user to reset
		FString Username;
		// [optional] Password for the PlayFab account
		FString Password;
	
        FUserCredentials() :
			FPlayFabBaseModel(),
			Username(),
			Password()
			{}
		
		FUserCredentials(const FUserCredentials& src) :
			FPlayFabBaseModel(),
			Username(src.Username),
			Password(src.Password)
			{}
			
		FUserCredentials(const TSharedPtr<FJsonObject>& obj) : FUserCredentials()
        {
            readFromValue(obj);
        }
		
		~FUserCredentials();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FResetUsersRequest : public FPlayFabBaseModel
    {
		
		// Array of users to reset
		TArray<FUserCredentials> Users;
	
        FResetUsersRequest() :
			FPlayFabBaseModel(),
			Users()
			{}
		
		FResetUsersRequest(const FResetUsersRequest& src) :
			FPlayFabBaseModel(),
			Users(src.Users)
			{}
			
		FResetUsersRequest(const TSharedPtr<FJsonObject>& obj) : FResetUsersRequest()
        {
            readFromValue(obj);
        }
		
		~FResetUsersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FResetUserStatisticsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FResetUserStatisticsRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FResetUserStatisticsRequest(const FResetUserStatisticsRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FResetUserStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FResetUserStatisticsRequest()
        {
            readFromValue(obj);
        }
		
		~FResetUserStatisticsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FResetUserStatisticsResult : public FPlayFabBaseModel
    {
		
	
        FResetUserStatisticsResult() :
			FPlayFabBaseModel()
			{}
		
		FResetUserStatisticsResult(const FResetUserStatisticsResult& src) :
			FPlayFabBaseModel()
			{}
			
		FResetUserStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FResetUserStatisticsResult()
        {
            readFromValue(obj);
        }
		
		~FResetUserStatisticsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum ResolutionOutcome
	{
		ResolutionOutcomeRevoke,
		ResolutionOutcomeReinstate,
		ResolutionOutcomeManual
	};
	
	void writeResolutionOutcomeEnumJSON(ResolutionOutcome enumVal, JsonWriter& writer);
	ResolutionOutcome readResolutionOutcomeFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FResolvePurchaseDisputeRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique order ID for the purchase in question.
		FString OrderId;
		// [optional] Reason for refund. In the case of Facebook this must match one of their refund or dispute resolution enums (See: https://developers.facebook.com/docs/payments/implementation-guide/handling-disputes-refunds)
		FString Reason;
		// Enum for the desired purchase result state after notifying the payment provider. Valid values are Revoke, Reinstate and Manual. Manual will cause no change to the order state.
		ResolutionOutcome Outcome;
	
        FResolvePurchaseDisputeRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			OrderId(),
			Reason(),
			Outcome()
			{}
		
		FResolvePurchaseDisputeRequest(const FResolvePurchaseDisputeRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			OrderId(src.OrderId),
			Reason(src.Reason),
			Outcome(src.Outcome)
			{}
			
		FResolvePurchaseDisputeRequest(const TSharedPtr<FJsonObject>& obj) : FResolvePurchaseDisputeRequest()
        {
            readFromValue(obj);
        }
		
		~FResolvePurchaseDisputeRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FResolvePurchaseDisputeResponse : public FPlayFabBaseModel
    {
		
		// [optional] The order's updated purchase status.
		FString PurchaseStatus;
	
        FResolvePurchaseDisputeResponse() :
			FPlayFabBaseModel(),
			PurchaseStatus()
			{}
		
		FResolvePurchaseDisputeResponse(const FResolvePurchaseDisputeResponse& src) :
			FPlayFabBaseModel(),
			PurchaseStatus(src.PurchaseStatus)
			{}
			
		FResolvePurchaseDisputeResponse(const TSharedPtr<FJsonObject>& obj) : FResolvePurchaseDisputeResponse()
        {
            readFromValue(obj);
        }
		
		~FResolvePurchaseDisputeResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeAllBansForUserRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FRevokeAllBansForUserRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FRevokeAllBansForUserRequest(const FRevokeAllBansForUserRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FRevokeAllBansForUserRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeAllBansForUserRequest()
        {
            readFromValue(obj);
        }
		
		~FRevokeAllBansForUserRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeAllBansForUserResult : public FPlayFabBaseModel
    {
		
		// [optional] Information on the bans that were revoked.
		TArray<FBanInfo> BanData;
	
        FRevokeAllBansForUserResult() :
			FPlayFabBaseModel(),
			BanData()
			{}
		
		FRevokeAllBansForUserResult(const FRevokeAllBansForUserResult& src) :
			FPlayFabBaseModel(),
			BanData(src.BanData)
			{}
			
		FRevokeAllBansForUserResult(const TSharedPtr<FJsonObject>& obj) : FRevokeAllBansForUserResult()
        {
            readFromValue(obj);
        }
		
		~FRevokeAllBansForUserResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeBansRequest : public FPlayFabBaseModel
    {
		
		// Ids of the bans to be revoked. Maximum 100.
		TArray<FString> BanIds;
	
        FRevokeBansRequest() :
			FPlayFabBaseModel(),
			BanIds()
			{}
		
		FRevokeBansRequest(const FRevokeBansRequest& src) :
			FPlayFabBaseModel(),
			BanIds(src.BanIds)
			{}
			
		FRevokeBansRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeBansRequest()
        {
            readFromValue(obj);
        }
		
		~FRevokeBansRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeBansResult : public FPlayFabBaseModel
    {
		
		// [optional] Information on the bans that were revoked
		TArray<FBanInfo> BanData;
	
        FRevokeBansResult() :
			FPlayFabBaseModel(),
			BanData()
			{}
		
		FRevokeBansResult(const FRevokeBansResult& src) :
			FPlayFabBaseModel(),
			BanData(src.BanData)
			{}
			
		FRevokeBansResult(const TSharedPtr<FJsonObject>& obj) : FRevokeBansResult()
        {
            readFromValue(obj);
        }
		
		~FRevokeBansResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeInventoryItemRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// Unique PlayFab assigned instance identifier of the item
		FString ItemInstanceId;
	
        FRevokeInventoryItemRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			ItemInstanceId()
			{}
		
		FRevokeInventoryItemRequest(const FRevokeInventoryItemRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			ItemInstanceId(src.ItemInstanceId)
			{}
			
		FRevokeInventoryItemRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItemRequest()
        {
            readFromValue(obj);
        }
		
		~FRevokeInventoryItemRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeInventoryResult : public FPlayFabBaseModel
    {
		
	
        FRevokeInventoryResult() :
			FPlayFabBaseModel()
			{}
		
		FRevokeInventoryResult(const FRevokeInventoryResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRevokeInventoryResult(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryResult()
        {
            readFromValue(obj);
        }
		
		~FRevokeInventoryResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRunTaskRequest : public FPlayFabBaseModel
    {
		
		// [optional] Provide either the task ID or the task name to run a task.
		TSharedPtr<FNameIdentifier> Identifier;
	
        FRunTaskRequest() :
			FPlayFabBaseModel(),
			Identifier(nullptr)
			{}
		
		FRunTaskRequest(const FRunTaskRequest& src) :
			FPlayFabBaseModel(),
			Identifier(src.Identifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.Identifier)) : nullptr)
			{}
			
		FRunTaskRequest(const TSharedPtr<FJsonObject>& obj) : FRunTaskRequest()
        {
            readFromValue(obj);
        }
		
		~FRunTaskRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRunTaskResult : public FPlayFabBaseModel
    {
		
		// [optional] ID of the task instance that is started. This can be used in Get*TaskInstance (e.g. GetCloudScriptTaskInstance) API call to retrieve status for the task instance.
		FString TaskInstanceId;
	
        FRunTaskResult() :
			FPlayFabBaseModel(),
			TaskInstanceId()
			{}
		
		FRunTaskResult(const FRunTaskResult& src) :
			FPlayFabBaseModel(),
			TaskInstanceId(src.TaskInstanceId)
			{}
			
		FRunTaskResult(const TSharedPtr<FJsonObject>& obj) : FRunTaskResult()
        {
            readFromValue(obj);
        }
		
		~FRunTaskResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSendAccountRecoveryEmailRequest : public FPlayFabBaseModel
    {
		
		// User email address attached to their account
		FString Email;
	
        FSendAccountRecoveryEmailRequest() :
			FPlayFabBaseModel(),
			Email()
			{}
		
		FSendAccountRecoveryEmailRequest(const FSendAccountRecoveryEmailRequest& src) :
			FPlayFabBaseModel(),
			Email(src.Email)
			{}
			
		FSendAccountRecoveryEmailRequest(const TSharedPtr<FJsonObject>& obj) : FSendAccountRecoveryEmailRequest()
        {
            readFromValue(obj);
        }
		
		~FSendAccountRecoveryEmailRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSendAccountRecoveryEmailResult : public FPlayFabBaseModel
    {
		
	
        FSendAccountRecoveryEmailResult() :
			FPlayFabBaseModel()
			{}
		
		FSendAccountRecoveryEmailResult(const FSendAccountRecoveryEmailResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSendAccountRecoveryEmailResult(const TSharedPtr<FJsonObject>& obj) : FSendAccountRecoveryEmailResult()
        {
            readFromValue(obj);
        }
		
		~FSendAccountRecoveryEmailResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetPublishedRevisionRequest : public FPlayFabBaseModel
    {
		
		// Version number
		int32 Version;
		// Revision to make the current published revision
		int32 Revision;
	
        FSetPublishedRevisionRequest() :
			FPlayFabBaseModel(),
			Version(0),
			Revision(0)
			{}
		
		FSetPublishedRevisionRequest(const FSetPublishedRevisionRequest& src) :
			FPlayFabBaseModel(),
			Version(src.Version),
			Revision(src.Revision)
			{}
			
		FSetPublishedRevisionRequest(const TSharedPtr<FJsonObject>& obj) : FSetPublishedRevisionRequest()
        {
            readFromValue(obj);
        }
		
		~FSetPublishedRevisionRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetPublishedRevisionResult : public FPlayFabBaseModel
    {
		
	
        FSetPublishedRevisionResult() :
			FPlayFabBaseModel()
			{}
		
		FSetPublishedRevisionResult(const FSetPublishedRevisionResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSetPublishedRevisionResult(const TSharedPtr<FJsonObject>& obj) : FSetPublishedRevisionResult()
        {
            readFromValue(obj);
        }
		
		~FSetPublishedRevisionResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetPublisherDataRequest : public FPlayFabBaseModel
    {
		
		// key we want to set a value on (note, this is additive - will only replace an existing key's value if they are the same name.) Keys are trimmed of whitespace. Keys may not begin with the '!' character.
		FString Key;
		// [optional] new value to set. Set to null to remove a value
		FString Value;
	
        FSetPublisherDataRequest() :
			FPlayFabBaseModel(),
			Key(),
			Value()
			{}
		
		FSetPublisherDataRequest(const FSetPublisherDataRequest& src) :
			FPlayFabBaseModel(),
			Key(src.Key),
			Value(src.Value)
			{}
			
		FSetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetPublisherDataRequest()
        {
            readFromValue(obj);
        }
		
		~FSetPublisherDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetPublisherDataResult : public FPlayFabBaseModel
    {
		
	
        FSetPublisherDataResult() :
			FPlayFabBaseModel()
			{}
		
		FSetPublisherDataResult(const FSetPublisherDataResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FSetPublisherDataResult()
        {
            readFromValue(obj);
        }
		
		~FSetPublisherDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetTitleDataRequest : public FPlayFabBaseModel
    {
		
		// key we want to set a value on (note, this is additive - will only replace an existing key's value if they are the same name.) Keys are trimmed of whitespace. Keys may not begin with the '!' character.
		FString Key;
		// [optional] new value to set. Set to null to remove a value
		FString Value;
	
        FSetTitleDataRequest() :
			FPlayFabBaseModel(),
			Key(),
			Value()
			{}
		
		FSetTitleDataRequest(const FSetTitleDataRequest& src) :
			FPlayFabBaseModel(),
			Key(src.Key),
			Value(src.Value)
			{}
			
		FSetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataRequest()
        {
            readFromValue(obj);
        }
		
		~FSetTitleDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetTitleDataResult : public FPlayFabBaseModel
    {
		
	
        FSetTitleDataResult() :
			FPlayFabBaseModel()
			{}
		
		FSetTitleDataResult(const FSetTitleDataResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataResult()
        {
            readFromValue(obj);
        }
		
		~FSetTitleDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetupPushNotificationRequest : public FPlayFabBaseModel
    {
		
		// name of the application sending the message (application names must be made up of only uppercase and lowercase ASCII letters, numbers, underscores, hyphens, and periods, and must be between 1 and 256 characters long)
		FString Name;
		// supported notification platforms are Apple Push Notification Service (APNS and APNS_SANDBOX) for iOS and Google Cloud Messaging (GCM) for Android
		FString Platform;
		// [optional] for APNS, this is the PlatformPrincipal (SSL Certificate)
		FString Key;
		// Credential is the Private Key for APNS/APNS_SANDBOX, and the API Key for GCM
		FString Credential;
		// replace any existing ARN with the newly generated one. If this is set to false, an error will be returned if notifications have already setup for this platform.
		bool OverwriteOldARN;
	
        FSetupPushNotificationRequest() :
			FPlayFabBaseModel(),
			Name(),
			Platform(),
			Key(),
			Credential(),
			OverwriteOldARN(false)
			{}
		
		FSetupPushNotificationRequest(const FSetupPushNotificationRequest& src) :
			FPlayFabBaseModel(),
			Name(src.Name),
			Platform(src.Platform),
			Key(src.Key),
			Credential(src.Credential),
			OverwriteOldARN(src.OverwriteOldARN)
			{}
			
		FSetupPushNotificationRequest(const TSharedPtr<FJsonObject>& obj) : FSetupPushNotificationRequest()
        {
            readFromValue(obj);
        }
		
		~FSetupPushNotificationRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetupPushNotificationResult : public FPlayFabBaseModel
    {
		
		// [optional] Amazon Resource Name for the created notification topic.
		FString ARN;
	
        FSetupPushNotificationResult() :
			FPlayFabBaseModel(),
			ARN()
			{}
		
		FSetupPushNotificationResult(const FSetupPushNotificationResult& src) :
			FPlayFabBaseModel(),
			ARN(src.ARN)
			{}
			
		FSetupPushNotificationResult(const TSharedPtr<FJsonObject>& obj) : FSetupPushNotificationResult()
        {
            readFromValue(obj);
        }
		
		~FSetupPushNotificationResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSubtractUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
		
		// PlayFab unique identifier of the user whose virtual currency balance is to be decreased.
		FString PlayFabId;
		// Name of the virtual currency which is to be decremented.
		FString VirtualCurrency;
		// Amount to be subtracted from the user balance of the specified virtual currency.
		int32 Amount;
	
        FSubtractUserVirtualCurrencyRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			VirtualCurrency(),
			Amount(0)
			{}
		
		FSubtractUserVirtualCurrencyRequest(const FSubtractUserVirtualCurrencyRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			VirtualCurrency(src.VirtualCurrency),
			Amount(src.Amount)
			{}
			
		FSubtractUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FSubtractUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }
		
		~FSubtractUserVirtualCurrencyRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateBanRequest : public FPlayFabBaseModel
    {
		
		// The id of the ban to be updated.
		FString BanId;
		// [optional] The updated reason for the ban to be updated. Maximum 140 characters. Null for no change.
		FString Reason;
		// [optional] The updated expiration date for the ban. Null for no change.
		OptionalTime Expires;
		// [optional] The updated IP address for the ban. Null for no change.
		FString IPAddress;
		// [optional] The updated MAC address for the ban. Null for no change.
		FString MACAddress;
		// [optional] Whether to make this ban permanent. Set to true to make this ban permanent. This will not modify Active state.
		OptionalBool Permanent;
		// [optional] The updated active state for the ban. Null for no change.
		OptionalBool Active;
	
        FUpdateBanRequest() :
			FPlayFabBaseModel(),
			BanId(),
			Reason(),
			Expires(),
			IPAddress(),
			MACAddress(),
			Permanent(),
			Active()
			{}
		
		FUpdateBanRequest(const FUpdateBanRequest& src) :
			FPlayFabBaseModel(),
			BanId(src.BanId),
			Reason(src.Reason),
			Expires(src.Expires),
			IPAddress(src.IPAddress),
			MACAddress(src.MACAddress),
			Permanent(src.Permanent),
			Active(src.Active)
			{}
			
		FUpdateBanRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBanRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateBanRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateBansRequest : public FPlayFabBaseModel
    {
		
		// List of bans to be updated. Maximum 100.
		TArray<FUpdateBanRequest> Bans;
	
        FUpdateBansRequest() :
			FPlayFabBaseModel(),
			Bans()
			{}
		
		FUpdateBansRequest(const FUpdateBansRequest& src) :
			FPlayFabBaseModel(),
			Bans(src.Bans)
			{}
			
		FUpdateBansRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBansRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateBansRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateBansResult : public FPlayFabBaseModel
    {
		
		// [optional] Information on the bans that were updated
		TArray<FBanInfo> BanData;
	
        FUpdateBansResult() :
			FPlayFabBaseModel(),
			BanData()
			{}
		
		FUpdateBansResult(const FUpdateBansResult& src) :
			FPlayFabBaseModel(),
			BanData(src.BanData)
			{}
			
		FUpdateBansResult(const TSharedPtr<FJsonObject>& obj) : FUpdateBansResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateBansResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCatalogItemsRequest : public FPlayFabBaseModel
    {
		
		// [optional] Which catalog is being updated. If null, uses the default catalog.
		FString CatalogVersion;
		// [optional] Should this catalog be set as the default catalog. Defaults to true. If there is currently no default catalog, this will always set it.
		OptionalBool SetAsDefaultCatalog;
		// [optional] Array of catalog items to be submitted. Note that while CatalogItem has a parameter for CatalogVersion, it is not required and ignored in this call.
		TArray<FCatalogItem> Catalog;
	
        FUpdateCatalogItemsRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			SetAsDefaultCatalog(),
			Catalog()
			{}
		
		FUpdateCatalogItemsRequest(const FUpdateCatalogItemsRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			SetAsDefaultCatalog(src.SetAsDefaultCatalog),
			Catalog(src.Catalog)
			{}
			
		FUpdateCatalogItemsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCatalogItemsRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateCatalogItemsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCatalogItemsResult : public FPlayFabBaseModel
    {
		
	
        FUpdateCatalogItemsResult() :
			FPlayFabBaseModel()
			{}
		
		FUpdateCatalogItemsResult(const FUpdateCatalogItemsResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUpdateCatalogItemsResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCatalogItemsResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateCatalogItemsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCloudScriptRequest : public FPlayFabBaseModel
    {
		
		// List of Cloud Script files to upload to create the new revision. Must have at least one file.
		TArray<FCloudScriptFile> Files;
		// Immediately publish the new revision
		bool Publish;
		// [optional] PlayFab user ID of the developer initiating the request.
		FString DeveloperPlayFabId;
	
        FUpdateCloudScriptRequest() :
			FPlayFabBaseModel(),
			Files(),
			Publish(false),
			DeveloperPlayFabId()
			{}
		
		FUpdateCloudScriptRequest(const FUpdateCloudScriptRequest& src) :
			FPlayFabBaseModel(),
			Files(src.Files),
			Publish(src.Publish),
			DeveloperPlayFabId(src.DeveloperPlayFabId)
			{}
			
		FUpdateCloudScriptRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCloudScriptRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateCloudScriptRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCloudScriptResult : public FPlayFabBaseModel
    {
		
		// Cloud Script version updated
		int32 Version;
		// New revision number created
		int32 Revision;
	
        FUpdateCloudScriptResult() :
			FPlayFabBaseModel(),
			Version(0),
			Revision(0)
			{}
		
		FUpdateCloudScriptResult(const FUpdateCloudScriptResult& src) :
			FPlayFabBaseModel(),
			Version(src.Version),
			Revision(src.Revision)
			{}
			
		FUpdateCloudScriptResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCloudScriptResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateCloudScriptResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdatePlayerStatisticDefinitionRequest : public FPlayFabBaseModel
    {
		
		// unique name of the statistic
		FString StatisticName;
		// [optional] interval at which the values of the statistic for all players are reset (changes are effective at the next occurance of the new interval boundary)
		Boxed<StatisticResetIntervalOption> VersionChangeInterval;
		// [optional] the aggregation method to use in updating the statistic (defaults to last)
		Boxed<StatisticAggregationMethod> AggregationMethod;
	
        FUpdatePlayerStatisticDefinitionRequest() :
			FPlayFabBaseModel(),
			StatisticName(),
			VersionChangeInterval(),
			AggregationMethod()
			{}
		
		FUpdatePlayerStatisticDefinitionRequest(const FUpdatePlayerStatisticDefinitionRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			VersionChangeInterval(src.VersionChangeInterval),
			AggregationMethod(src.AggregationMethod)
			{}
			
		FUpdatePlayerStatisticDefinitionRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticDefinitionRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdatePlayerStatisticDefinitionRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdatePlayerStatisticDefinitionResult : public FPlayFabBaseModel
    {
		
		// [optional] updated statistic definition
		TSharedPtr<FPlayerStatisticDefinition> Statistic;
	
        FUpdatePlayerStatisticDefinitionResult() :
			FPlayFabBaseModel(),
			Statistic(nullptr)
			{}
		
		FUpdatePlayerStatisticDefinitionResult(const FUpdatePlayerStatisticDefinitionResult& src) :
			FPlayFabBaseModel(),
			Statistic(src.Statistic.IsValid() ? MakeShareable(new FPlayerStatisticDefinition(*src.Statistic)) : nullptr)
			{}
			
		FUpdatePlayerStatisticDefinitionResult(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticDefinitionResult()
        {
            readFromValue(obj);
        }
		
		~FUpdatePlayerStatisticDefinitionResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdatePolicyRequest : public FPlayFabBaseModel
    {
		
		// The name of the policy being updated. Only supported name is 'ApiPolicy'
		FString PolicyName;
		// The new statements to include in the policy.
		TArray<FPermissionStatement> Statements;
		// Whether to overwrite or append to the existing policy.
		bool OverwritePolicy;
	
        FUpdatePolicyRequest() :
			FPlayFabBaseModel(),
			PolicyName(),
			Statements(),
			OverwritePolicy(false)
			{}
		
		FUpdatePolicyRequest(const FUpdatePolicyRequest& src) :
			FPlayFabBaseModel(),
			PolicyName(src.PolicyName),
			Statements(src.Statements),
			OverwritePolicy(src.OverwritePolicy)
			{}
			
		FUpdatePolicyRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePolicyRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdatePolicyRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdatePolicyResponse : public FPlayFabBaseModel
    {
		
		// [optional] The name of the policy that was updated.
		FString PolicyName;
		// [optional] The statements included in the new version of the policy.
		TArray<FPermissionStatement> Statements;
	
        FUpdatePolicyResponse() :
			FPlayFabBaseModel(),
			PolicyName(),
			Statements()
			{}
		
		FUpdatePolicyResponse(const FUpdatePolicyResponse& src) :
			FPlayFabBaseModel(),
			PolicyName(src.PolicyName),
			Statements(src.Statements)
			{}
			
		FUpdatePolicyResponse(const TSharedPtr<FJsonObject>& obj) : FUpdatePolicyResponse()
        {
            readFromValue(obj);
        }
		
		~FUpdatePolicyResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateRandomResultTablesRequest : public FPlayFabBaseModel
    {
		
		// [optional] which catalog is being updated. If null, update the current default catalog version
		FString CatalogVersion;
		// [optional] array of random result tables to make available (Note: specifying an existing TableId will result in overwriting that table, while any others will be added to the available set)
		TArray<FRandomResultTable> Tables;
	
        FUpdateRandomResultTablesRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			Tables()
			{}
		
		FUpdateRandomResultTablesRequest(const FUpdateRandomResultTablesRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			Tables(src.Tables)
			{}
			
		FUpdateRandomResultTablesRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateRandomResultTablesRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateRandomResultTablesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateRandomResultTablesResult : public FPlayFabBaseModel
    {
		
	
        FUpdateRandomResultTablesResult() :
			FPlayFabBaseModel()
			{}
		
		FUpdateRandomResultTablesResult(const FUpdateRandomResultTablesResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUpdateRandomResultTablesResult(const TSharedPtr<FJsonObject>& obj) : FUpdateRandomResultTablesResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateRandomResultTablesResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateStoreItemsRequest : public FPlayFabBaseModel
    {
		
		// [optional] Catalog version of the store to update. If null, uses the default catalog.
		FString CatalogVersion;
		// Unique identifier for the store which is to be updated
		FString StoreId;
		// [optional] Additional data about the store
		TSharedPtr<FStoreMarketingModel> MarketingData;
		// [optional] Array of store items - references to catalog items, with specific pricing - to be added
		TArray<FStoreItem> Store;
	
        FUpdateStoreItemsRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			StoreId(),
			MarketingData(nullptr),
			Store()
			{}
		
		FUpdateStoreItemsRequest(const FUpdateStoreItemsRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			StoreId(src.StoreId),
			MarketingData(src.MarketingData.IsValid() ? MakeShareable(new FStoreMarketingModel(*src.MarketingData)) : nullptr),
			Store(src.Store)
			{}
			
		FUpdateStoreItemsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateStoreItemsRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateStoreItemsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateStoreItemsResult : public FPlayFabBaseModel
    {
		
	
        FUpdateStoreItemsResult() :
			FPlayFabBaseModel()
			{}
		
		FUpdateStoreItemsResult(const FUpdateStoreItemsResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUpdateStoreItemsResult(const TSharedPtr<FJsonObject>& obj) : FUpdateStoreItemsResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateStoreItemsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateTaskRequest : public FPlayFabBaseModel
    {
		
		// [optional] Specify either the task ID or the name of the task to be updated.
		TSharedPtr<FNameIdentifier> Identifier;
		// Name of the task. This is a unique identifier for tasks in the title.
		FString Name;
		// [optional] Description the task
		FString Description;
		// [optional] Cron expression for the run schedule of the task. The expression should be in UTC.
		FString Schedule;
		// Whether the schedule is active. Inactive schedule will not trigger task execution.
		bool IsActive;
		// Task type.
		ScheduledTaskType Type;
		// [optional] Parameter object specific to the task type. See each task type's create API documentation for details.
		FMultitypeVar Parameter;
	
        FUpdateTaskRequest() :
			FPlayFabBaseModel(),
			Identifier(nullptr),
			Name(),
			Description(),
			Schedule(),
			IsActive(false),
			Type(),
			Parameter()
			{}
		
		FUpdateTaskRequest(const FUpdateTaskRequest& src) :
			FPlayFabBaseModel(),
			Identifier(src.Identifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.Identifier)) : nullptr),
			Name(src.Name),
			Description(src.Description),
			Schedule(src.Schedule),
			IsActive(src.IsActive),
			Type(src.Type),
			Parameter(src.Parameter)
			{}
			
		FUpdateTaskRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateTaskRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateTaskRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserDataRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
		// [optional] Permission to be applied to all user data keys written in this request. Defaults to "private" if not set.
		Boxed<UserDataPermission> Permission;
	
        FUpdateUserDataRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Data(),
			KeysToRemove(),
			Permission()
			{}
		
		FUpdateUserDataRequest(const FUpdateUserDataRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove),
			Permission(src.Permission)
			{}
			
		FUpdateUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserDataResult : public FPlayFabBaseModel
    {
		
		// Indicates the current version of the data that has been set. This is incremented with every set call for that type of data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
		uint32 DataVersion;
	
        FUpdateUserDataResult() :
			FPlayFabBaseModel(),
			DataVersion(0)
			{}
		
		FUpdateUserDataResult(const FUpdateUserDataResult& src) :
			FPlayFabBaseModel(),
			DataVersion(src.DataVersion)
			{}
			
		FUpdateUserDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserInternalDataRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
	
        FUpdateUserInternalDataRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Data(),
			KeysToRemove()
			{}
		
		FUpdateUserInternalDataRequest(const FUpdateUserInternalDataRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove)
			{}
			
		FUpdateUserInternalDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserInternalDataRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserInternalDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserTitleDisplayNameRequest : public FPlayFabBaseModel
    {
		
		// PlayFab unique identifier of the user whose title specific display name is to be changed
		FString PlayFabId;
		// new title display name for the user - must be between 3 and 25 characters
		FString DisplayName;
	
        FUpdateUserTitleDisplayNameRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			DisplayName()
			{}
		
		FUpdateUserTitleDisplayNameRequest(const FUpdateUserTitleDisplayNameRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			DisplayName(src.DisplayName)
			{}
			
		FUpdateUserTitleDisplayNameRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserTitleDisplayNameRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserTitleDisplayNameRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserTitleDisplayNameResult : public FPlayFabBaseModel
    {
		
		// [optional] current title display name for the user (this will be the original display name if the rename attempt failed)
		FString DisplayName;
	
        FUpdateUserTitleDisplayNameResult() :
			FPlayFabBaseModel(),
			DisplayName()
			{}
		
		FUpdateUserTitleDisplayNameResult(const FUpdateUserTitleDisplayNameResult& src) :
			FPlayFabBaseModel(),
			DisplayName(src.DisplayName)
			{}
			
		FUpdateUserTitleDisplayNameResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserTitleDisplayNameResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserTitleDisplayNameResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	

}
}

