// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#pragma once

#include "Core/PlayFabBaseModel.h"

namespace PlayFab
{
namespace ClientModels
{

	
	struct PLAYFAB_API FAcceptTradeRequest : public FPlayFabBaseModel
    {
		
		// Player who opened the trade.
		FString OfferingPlayerId;
		// Trade identifier.
		FString TradeId;
		// [optional] Items from the accepting player's or guild's inventory in exchange for the offered items in the trade. In the case of a gift, this will be null.
		TArray<FString> AcceptedInventoryInstanceIds;
	
        FAcceptTradeRequest() :
			FPlayFabBaseModel(),
			OfferingPlayerId(),
			TradeId(),
			AcceptedInventoryInstanceIds()
			{}
		
		FAcceptTradeRequest(const FAcceptTradeRequest& src) :
			FPlayFabBaseModel(),
			OfferingPlayerId(src.OfferingPlayerId),
			TradeId(src.TradeId),
			AcceptedInventoryInstanceIds(src.AcceptedInventoryInstanceIds)
			{}
			
		FAcceptTradeRequest(const TSharedPtr<FJsonObject>& obj) : FAcceptTradeRequest()
        {
            readFromValue(obj);
        }
		
		~FAcceptTradeRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum TradeStatus
	{
		TradeStatusInvalid,
		TradeStatusOpening,
		TradeStatusOpen,
		TradeStatusAccepting,
		TradeStatusAccepted,
		TradeStatusFilled,
		TradeStatusCancelled
	};
	
	void writeTradeStatusEnumJSON(TradeStatus enumVal, JsonWriter& writer);
	TradeStatus readTradeStatusFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FTradeInfo : public FPlayFabBaseModel
    {
		
		// [optional] Describes the current state of this trade.
		Boxed<TradeStatus> Status;
		// [optional] The identifier for this trade.
		FString TradeId;
		// [optional] The PlayFabId for the offering player.
		FString OfferingPlayerId;
		// [optional] The itemInstance Ids that are being offered.
		TArray<FString> OfferedInventoryInstanceIds;
		// [optional] The catalogItem Ids of the item instances being offered.
		TArray<FString> OfferedCatalogItemIds;
		// [optional] The catalogItem Ids requested in exchange.
		TArray<FString> RequestedCatalogItemIds;
		// [optional] An optional list of players allowed to complete this trade.  If null, anybody can complete the trade.
		TArray<FString> AllowedPlayerIds;
		// [optional] The PlayFab ID of the player who accepted the trade. If null, no one has accepted the trade.
		FString AcceptedPlayerId;
		// [optional] Item instances from the accepting player that are used to fulfill the trade. If null, no one has accepted the trade.
		TArray<FString> AcceptedInventoryInstanceIds;
		// [optional] The UTC time when this trade was created.
		OptionalTime OpenedAt;
		// [optional] If set, The UTC time when this trade was fulfilled.
		OptionalTime FilledAt;
		// [optional] If set, The UTC time when this trade was canceled.
		OptionalTime CancelledAt;
		// [optional] If set, The UTC time when this trade was made invalid.
		OptionalTime InvalidatedAt;
	
        FTradeInfo() :
			FPlayFabBaseModel(),
			Status(),
			TradeId(),
			OfferingPlayerId(),
			OfferedInventoryInstanceIds(),
			OfferedCatalogItemIds(),
			RequestedCatalogItemIds(),
			AllowedPlayerIds(),
			AcceptedPlayerId(),
			AcceptedInventoryInstanceIds(),
			OpenedAt(),
			FilledAt(),
			CancelledAt(),
			InvalidatedAt()
			{}
		
		FTradeInfo(const FTradeInfo& src) :
			FPlayFabBaseModel(),
			Status(src.Status),
			TradeId(src.TradeId),
			OfferingPlayerId(src.OfferingPlayerId),
			OfferedInventoryInstanceIds(src.OfferedInventoryInstanceIds),
			OfferedCatalogItemIds(src.OfferedCatalogItemIds),
			RequestedCatalogItemIds(src.RequestedCatalogItemIds),
			AllowedPlayerIds(src.AllowedPlayerIds),
			AcceptedPlayerId(src.AcceptedPlayerId),
			AcceptedInventoryInstanceIds(src.AcceptedInventoryInstanceIds),
			OpenedAt(src.OpenedAt),
			FilledAt(src.FilledAt),
			CancelledAt(src.CancelledAt),
			InvalidatedAt(src.InvalidatedAt)
			{}
			
		FTradeInfo(const TSharedPtr<FJsonObject>& obj) : FTradeInfo()
        {
            readFromValue(obj);
        }
		
		~FTradeInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAcceptTradeResponse : public FPlayFabBaseModel
    {
		
		// [optional] Details about trade which was just accepted.
		TSharedPtr<FTradeInfo> Trade;
	
        FAcceptTradeResponse() :
			FPlayFabBaseModel(),
			Trade(nullptr)
			{}
		
		FAcceptTradeResponse(const FAcceptTradeResponse& src) :
			FPlayFabBaseModel(),
			Trade(src.Trade.IsValid() ? MakeShareable(new FTradeInfo(*src.Trade)) : nullptr)
			{}
			
		FAcceptTradeResponse(const TSharedPtr<FJsonObject>& obj) : FAcceptTradeResponse()
        {
            readFromValue(obj);
        }
		
		~FAcceptTradeResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddFriendRequest : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab identifier of the user to attempt to add to the local user's friend list.
		FString FriendPlayFabId;
		// [optional] PlayFab username of the user to attempt to add to the local user's friend list.
		FString FriendUsername;
		// [optional] Email address of the user to attempt to add to the local user's friend list.
		FString FriendEmail;
		// [optional] Title-specific display name of the user to attempt to add to the local user's friend list.
		FString FriendTitleDisplayName;
	
        FAddFriendRequest() :
			FPlayFabBaseModel(),
			FriendPlayFabId(),
			FriendUsername(),
			FriendEmail(),
			FriendTitleDisplayName()
			{}
		
		FAddFriendRequest(const FAddFriendRequest& src) :
			FPlayFabBaseModel(),
			FriendPlayFabId(src.FriendPlayFabId),
			FriendUsername(src.FriendUsername),
			FriendEmail(src.FriendEmail),
			FriendTitleDisplayName(src.FriendTitleDisplayName)
			{}
			
		FAddFriendRequest(const TSharedPtr<FJsonObject>& obj) : FAddFriendRequest()
        {
            readFromValue(obj);
        }
		
		~FAddFriendRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddFriendResult : public FPlayFabBaseModel
    {
		
		// True if the friend request was processed successfully.
		bool Created;
	
        FAddFriendResult() :
			FPlayFabBaseModel(),
			Created(false)
			{}
		
		FAddFriendResult(const FAddFriendResult& src) :
			FPlayFabBaseModel(),
			Created(src.Created)
			{}
			
		FAddFriendResult(const TSharedPtr<FJsonObject>& obj) : FAddFriendResult()
        {
            readFromValue(obj);
        }
		
		~FAddFriendResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGenericServiceId : public FPlayFabBaseModel
    {
		
		// Name of the service for which the player has a unique identifier.
		FString ServiceName;
		// Unique identifier of the player in that service.
		FString UserId;
	
        FGenericServiceId() :
			FPlayFabBaseModel(),
			ServiceName(),
			UserId()
			{}
		
		FGenericServiceId(const FGenericServiceId& src) :
			FPlayFabBaseModel(),
			ServiceName(src.ServiceName),
			UserId(src.UserId)
			{}
			
		FGenericServiceId(const TSharedPtr<FJsonObject>& obj) : FGenericServiceId()
        {
            readFromValue(obj);
        }
		
		~FGenericServiceId();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddGenericIDRequest : public FPlayFabBaseModel
    {
		
		// Generic service identifier to add to the player account.
		FGenericServiceId GenericId;
	
        FAddGenericIDRequest() :
			FPlayFabBaseModel(),
			GenericId()
			{}
		
		FAddGenericIDRequest(const FAddGenericIDRequest& src) :
			FPlayFabBaseModel(),
			GenericId(src.GenericId)
			{}
			
		FAddGenericIDRequest(const TSharedPtr<FJsonObject>& obj) : FAddGenericIDRequest()
        {
            readFromValue(obj);
        }
		
		~FAddGenericIDRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddGenericIDResult : public FPlayFabBaseModel
    {
		
	
        FAddGenericIDResult() :
			FPlayFabBaseModel()
			{}
		
		FAddGenericIDResult(const FAddGenericIDResult& src) :
			FPlayFabBaseModel()
			{}
			
		FAddGenericIDResult(const TSharedPtr<FJsonObject>& obj) : FAddGenericIDResult()
        {
            readFromValue(obj);
        }
		
		~FAddGenericIDResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddSharedGroupMembersRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the shared group.
		FString SharedGroupId;
		// An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
		TArray<FString> PlayFabIds;
	
        FAddSharedGroupMembersRequest() :
			FPlayFabBaseModel(),
			SharedGroupId(),
			PlayFabIds()
			{}
		
		FAddSharedGroupMembersRequest(const FAddSharedGroupMembersRequest& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId),
			PlayFabIds(src.PlayFabIds)
			{}
			
		FAddSharedGroupMembersRequest(const TSharedPtr<FJsonObject>& obj) : FAddSharedGroupMembersRequest()
        {
            readFromValue(obj);
        }
		
		~FAddSharedGroupMembersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddSharedGroupMembersResult : public FPlayFabBaseModel
    {
		
	
        FAddSharedGroupMembersResult() :
			FPlayFabBaseModel()
			{}
		
		FAddSharedGroupMembersResult(const FAddSharedGroupMembersResult& src) :
			FPlayFabBaseModel()
			{}
			
		FAddSharedGroupMembersResult(const TSharedPtr<FJsonObject>& obj) : FAddSharedGroupMembersResult()
        {
            readFromValue(obj);
        }
		
		~FAddSharedGroupMembersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddUsernamePasswordRequest : public FPlayFabBaseModel
    {
		
		// PlayFab username for the account (3-20 characters)
		FString Username;
		// User email address attached to their account
		FString Email;
		// Password for the PlayFab account (6-100 characters)
		FString Password;
	
        FAddUsernamePasswordRequest() :
			FPlayFabBaseModel(),
			Username(),
			Email(),
			Password()
			{}
		
		FAddUsernamePasswordRequest(const FAddUsernamePasswordRequest& src) :
			FPlayFabBaseModel(),
			Username(src.Username),
			Email(src.Email),
			Password(src.Password)
			{}
			
		FAddUsernamePasswordRequest(const TSharedPtr<FJsonObject>& obj) : FAddUsernamePasswordRequest()
        {
            readFromValue(obj);
        }
		
		~FAddUsernamePasswordRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddUsernamePasswordResult : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique user name.
		FString Username;
	
        FAddUsernamePasswordResult() :
			FPlayFabBaseModel(),
			Username()
			{}
		
		FAddUsernamePasswordResult(const FAddUsernamePasswordResult& src) :
			FPlayFabBaseModel(),
			Username(src.Username)
			{}
			
		FAddUsernamePasswordResult(const TSharedPtr<FJsonObject>& obj) : FAddUsernamePasswordResult()
        {
            readFromValue(obj);
        }
		
		~FAddUsernamePasswordResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
		
		// Name of the virtual currency which is to be incremented.
		FString VirtualCurrency;
		// Amount to be added to the user balance of the specified virtual currency.
		int32 Amount;
	
        FAddUserVirtualCurrencyRequest() :
			FPlayFabBaseModel(),
			VirtualCurrency(),
			Amount(0)
			{}
		
		FAddUserVirtualCurrencyRequest(const FAddUserVirtualCurrencyRequest& src) :
			FPlayFabBaseModel(),
			VirtualCurrency(src.VirtualCurrency),
			Amount(src.Amount)
			{}
			
		FAddUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FAddUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }
		
		~FAddUserVirtualCurrencyRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAndroidDevicePushNotificationRegistrationRequest : public FPlayFabBaseModel
    {
		
		// Registration ID provided by the Google Cloud Messaging service when the title registered to receive push notifications (see the GCM documentation, here: http://developer.android.com/google/gcm/client.html).
		FString DeviceToken;
		// [optional] If true, send a test push message immediately after sucessful registration. Defaults to false.
		OptionalBool SendPushNotificationConfirmation;
		// [optional] Message to display when confirming push notification.
		FString ConfirmationMessage;
	
        FAndroidDevicePushNotificationRegistrationRequest() :
			FPlayFabBaseModel(),
			DeviceToken(),
			SendPushNotificationConfirmation(),
			ConfirmationMessage()
			{}
		
		FAndroidDevicePushNotificationRegistrationRequest(const FAndroidDevicePushNotificationRegistrationRequest& src) :
			FPlayFabBaseModel(),
			DeviceToken(src.DeviceToken),
			SendPushNotificationConfirmation(src.SendPushNotificationConfirmation),
			ConfirmationMessage(src.ConfirmationMessage)
			{}
			
		FAndroidDevicePushNotificationRegistrationRequest(const TSharedPtr<FJsonObject>& obj) : FAndroidDevicePushNotificationRegistrationRequest()
        {
            readFromValue(obj);
        }
		
		~FAndroidDevicePushNotificationRegistrationRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAndroidDevicePushNotificationRegistrationResult : public FPlayFabBaseModel
    {
		
	
        FAndroidDevicePushNotificationRegistrationResult() :
			FPlayFabBaseModel()
			{}
		
		FAndroidDevicePushNotificationRegistrationResult(const FAndroidDevicePushNotificationRegistrationResult& src) :
			FPlayFabBaseModel()
			{}
			
		FAndroidDevicePushNotificationRegistrationResult(const TSharedPtr<FJsonObject>& obj) : FAndroidDevicePushNotificationRegistrationResult()
        {
            readFromValue(obj);
        }
		
		~FAndroidDevicePushNotificationRegistrationResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAttributeInstallRequest : public FPlayFabBaseModel
    {
		
		// [optional] The IdentifierForAdvertisers for iOS Devices.
		FString Idfa;
		// [optional] The android advertising id. This field is deprecated in favor of Adid for clarity.
		FString Android_Id;
		// [optional] The adid for this device.
		FString Adid;
	
        FAttributeInstallRequest() :
			FPlayFabBaseModel(),
			Idfa(),
			Android_Id(),
			Adid()
			{}
		
		FAttributeInstallRequest(const FAttributeInstallRequest& src) :
			FPlayFabBaseModel(),
			Idfa(src.Idfa),
			Android_Id(src.Android_Id),
			Adid(src.Adid)
			{}
			
		FAttributeInstallRequest(const TSharedPtr<FJsonObject>& obj) : FAttributeInstallRequest()
        {
            readFromValue(obj);
        }
		
		~FAttributeInstallRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAttributeInstallResult : public FPlayFabBaseModel
    {
		
	
        FAttributeInstallResult() :
			FPlayFabBaseModel()
			{}
		
		FAttributeInstallResult(const FAttributeInstallResult& src) :
			FPlayFabBaseModel()
			{}
			
		FAttributeInstallResult(const TSharedPtr<FJsonObject>& obj) : FAttributeInstallResult()
        {
            readFromValue(obj);
        }
		
		~FAttributeInstallResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCancelTradeRequest : public FPlayFabBaseModel
    {
		
		// Trade identifier.
		FString TradeId;
	
        FCancelTradeRequest() :
			FPlayFabBaseModel(),
			TradeId()
			{}
		
		FCancelTradeRequest(const FCancelTradeRequest& src) :
			FPlayFabBaseModel(),
			TradeId(src.TradeId)
			{}
			
		FCancelTradeRequest(const TSharedPtr<FJsonObject>& obj) : FCancelTradeRequest()
        {
            readFromValue(obj);
        }
		
		~FCancelTradeRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCancelTradeResponse : public FPlayFabBaseModel
    {
		
		// [optional] Details about trade which was just canceled.
		TSharedPtr<FTradeInfo> Trade;
	
        FCancelTradeResponse() :
			FPlayFabBaseModel(),
			Trade(nullptr)
			{}
		
		FCancelTradeResponse(const FCancelTradeResponse& src) :
			FPlayFabBaseModel(),
			Trade(src.Trade.IsValid() ? MakeShareable(new FTradeInfo(*src.Trade)) : nullptr)
			{}
			
		FCancelTradeResponse(const TSharedPtr<FJsonObject>& obj) : FCancelTradeResponse()
        {
            readFromValue(obj);
        }
		
		~FCancelTradeResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCartItem : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the catalog item.
		FString ItemId;
		// [optional] Class name to which catalog item belongs.
		FString ItemClass;
		// [optional] Unique instance identifier for this catalog item.
		FString ItemInstanceId;
		// [optional] Display name for the catalog item.
		FString DisplayName;
		// [optional] Description of the catalog item.
		FString Description;
		// [optional] Cost of the catalog item for each applicable virtual currency.
		TMap<FString, uint32> VirtualCurrencyPrices;
		// [optional] Cost of the catalog item for each applicable real world currency.
		TMap<FString, uint32> RealCurrencyPrices;
		// [optional] Amount of each applicable virtual currency which will be received as a result of purchasing this catalog item.
		TMap<FString, uint32> VCAmount;
	
        FCartItem() :
			FPlayFabBaseModel(),
			ItemId(),
			ItemClass(),
			ItemInstanceId(),
			DisplayName(),
			Description(),
			VirtualCurrencyPrices(),
			RealCurrencyPrices(),
			VCAmount()
			{}
		
		FCartItem(const FCartItem& src) :
			FPlayFabBaseModel(),
			ItemId(src.ItemId),
			ItemClass(src.ItemClass),
			ItemInstanceId(src.ItemInstanceId),
			DisplayName(src.DisplayName),
			Description(src.Description),
			VirtualCurrencyPrices(src.VirtualCurrencyPrices),
			RealCurrencyPrices(src.RealCurrencyPrices),
			VCAmount(src.VCAmount)
			{}
			
		FCartItem(const TSharedPtr<FJsonObject>& obj) : FCartItem()
        {
            readFromValue(obj);
        }
		
		~FCartItem();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItemConsumableInfo : public FPlayFabBaseModel
    {
		
		// [optional] number of times this object can be used, after which it will be removed from the player inventory
		OptionalUint32 UsageCount;
		// [optional] duration in seconds for how long the item will remain in the player inventory - once elapsed, the item will be removed (recommended minimum value is 5 seconds, as lower values can cause the item to expire before operations depending on this item's details have completed)
		OptionalUint32 UsagePeriod;
		// [optional] all inventory item instances in the player inventory sharing a non-null UsagePeriodGroup have their UsagePeriod values added together, and share the result - when that period has elapsed, all the items in the group will be removed
		FString UsagePeriodGroup;
	
        FCatalogItemConsumableInfo() :
			FPlayFabBaseModel(),
			UsageCount(),
			UsagePeriod(),
			UsagePeriodGroup()
			{}
		
		FCatalogItemConsumableInfo(const FCatalogItemConsumableInfo& src) :
			FPlayFabBaseModel(),
			UsageCount(src.UsageCount),
			UsagePeriod(src.UsagePeriod),
			UsagePeriodGroup(src.UsagePeriodGroup)
			{}
			
		FCatalogItemConsumableInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemConsumableInfo()
        {
            readFromValue(obj);
        }
		
		~FCatalogItemConsumableInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItemContainerInfo : public FPlayFabBaseModel
    {
		
		// [optional] ItemId for the catalog item used to unlock the container, if any (if not specified, a call to UnlockContainerItem will open the container, adding the contents to the player inventory and currency balances)
		FString KeyItemId;
		// [optional] unique ItemId values for all items which will be added to the player inventory, once the container has been unlocked
		TArray<FString> ItemContents;
		// [optional] unique TableId values for all RandomResultTable objects which are part of the container (once unlocked, random tables will be resolved and add the relevant items to the player inventory)
		TArray<FString> ResultTableContents;
		// [optional] virtual currency types and balances which will be added to the player inventory when the container is unlocked
		TMap<FString, uint32> VirtualCurrencyContents;
	
        FCatalogItemContainerInfo() :
			FPlayFabBaseModel(),
			KeyItemId(),
			ItemContents(),
			ResultTableContents(),
			VirtualCurrencyContents()
			{}
		
		FCatalogItemContainerInfo(const FCatalogItemContainerInfo& src) :
			FPlayFabBaseModel(),
			KeyItemId(src.KeyItemId),
			ItemContents(src.ItemContents),
			ResultTableContents(src.ResultTableContents),
			VirtualCurrencyContents(src.VirtualCurrencyContents)
			{}
			
		FCatalogItemContainerInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemContainerInfo()
        {
            readFromValue(obj);
        }
		
		~FCatalogItemContainerInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItemBundleInfo : public FPlayFabBaseModel
    {
		
		// [optional] unique ItemId values for all items which will be added to the player inventory when the bundle is added
		TArray<FString> BundledItems;
		// [optional] unique TableId values for all RandomResultTable objects which are part of the bundle (random tables will be resolved and add the relevant items to the player inventory when the bundle is added)
		TArray<FString> BundledResultTables;
		// [optional] virtual currency types and balances which will be added to the player inventory when the bundle is added
		TMap<FString, uint32> BundledVirtualCurrencies;
	
        FCatalogItemBundleInfo() :
			FPlayFabBaseModel(),
			BundledItems(),
			BundledResultTables(),
			BundledVirtualCurrencies()
			{}
		
		FCatalogItemBundleInfo(const FCatalogItemBundleInfo& src) :
			FPlayFabBaseModel(),
			BundledItems(src.BundledItems),
			BundledResultTables(src.BundledResultTables),
			BundledVirtualCurrencies(src.BundledVirtualCurrencies)
			{}
			
		FCatalogItemBundleInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemBundleInfo()
        {
            readFromValue(obj);
        }
		
		~FCatalogItemBundleInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItem : public FPlayFabBaseModel
    {
		
		// unique identifier for this item
		FString ItemId;
		// [optional] class to which the item belongs
		FString ItemClass;
		// [optional] catalog version for this item
		FString CatalogVersion;
		// [optional] text name for the item, to show in-game
		FString DisplayName;
		// [optional] text description of item, to show in-game
		FString Description;
		// [optional] price of this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
		TMap<FString, uint32> VirtualCurrencyPrices;
		// [optional] override prices for this item for specific currencies
		TMap<FString, uint32> RealCurrencyPrices;
		// [optional] list of item tags
		TArray<FString> Tags;
		// [optional] game specific custom data
		FString CustomData;
		// [optional] defines the consumable properties (number of uses, timeout) for the item
		TSharedPtr<FCatalogItemConsumableInfo> Consumable;
		// [optional] defines the container properties for the item - what items it contains, including random drop tables and virtual currencies, and what item (if any) is required to open it via the UnlockContainerItem API
		TSharedPtr<FCatalogItemContainerInfo> Container;
		// [optional] defines the bundle properties for the item - bundles are items which contain other items, including random drop tables and virtual currencies
		TSharedPtr<FCatalogItemBundleInfo> Bundle;
		// if true, then an item instance of this type can be used to grant a character to a user.
		bool CanBecomeCharacter;
		// if true, then only one item instance of this type will exist and its remaininguses will be incremented instead. RemainingUses will cap out at Int32.Max (2,147,483,647). All subsequent increases will be discarded
		bool IsStackable;
		// if true, then an item instance of this type can be traded between players using the trading APIs
		bool IsTradable;
		// [optional] URL to the item image. For Facebook purchase to display the image on the item purchase page, this must be set to an HTTP URL.
		FString ItemImageUrl;
		// BETA: If true, then only a fixed number can ever be granted.
		bool IsLimitedEdition;
		// If the item has IsLImitedEdition set to true, and this is the first time this ItemId has been defined as a limited edition item, this value determines the total number of instances to allocate for the title. Once this limit has been reached, no more instances of this ItemId can be created, and attempts to purchase or grant it will return a Result of false for that ItemId. If the item has already been defined to have a limited edition count, or if this value is less than zero, it will be ignored.
		int32 InitialLimitedEditionCount;
	
        FCatalogItem() :
			FPlayFabBaseModel(),
			ItemId(),
			ItemClass(),
			CatalogVersion(),
			DisplayName(),
			Description(),
			VirtualCurrencyPrices(),
			RealCurrencyPrices(),
			Tags(),
			CustomData(),
			Consumable(nullptr),
			Container(nullptr),
			Bundle(nullptr),
			CanBecomeCharacter(false),
			IsStackable(false),
			IsTradable(false),
			ItemImageUrl(),
			IsLimitedEdition(false),
			InitialLimitedEditionCount(0)
			{}
		
		FCatalogItem(const FCatalogItem& src) :
			FPlayFabBaseModel(),
			ItemId(src.ItemId),
			ItemClass(src.ItemClass),
			CatalogVersion(src.CatalogVersion),
			DisplayName(src.DisplayName),
			Description(src.Description),
			VirtualCurrencyPrices(src.VirtualCurrencyPrices),
			RealCurrencyPrices(src.RealCurrencyPrices),
			Tags(src.Tags),
			CustomData(src.CustomData),
			Consumable(src.Consumable.IsValid() ? MakeShareable(new FCatalogItemConsumableInfo(*src.Consumable)) : nullptr),
			Container(src.Container.IsValid() ? MakeShareable(new FCatalogItemContainerInfo(*src.Container)) : nullptr),
			Bundle(src.Bundle.IsValid() ? MakeShareable(new FCatalogItemBundleInfo(*src.Bundle)) : nullptr),
			CanBecomeCharacter(src.CanBecomeCharacter),
			IsStackable(src.IsStackable),
			IsTradable(src.IsTradable),
			ItemImageUrl(src.ItemImageUrl),
			IsLimitedEdition(src.IsLimitedEdition),
			InitialLimitedEditionCount(src.InitialLimitedEditionCount)
			{}
			
		FCatalogItem(const TSharedPtr<FJsonObject>& obj) : FCatalogItem()
        {
            readFromValue(obj);
        }
		
		~FCatalogItem();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FItemInstance : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the inventory item, as defined in the catalog.
		FString ItemId;
		// [optional] Unique item identifier for this specific instance of the item.
		FString ItemInstanceId;
		// [optional] Class name for the inventory item, as defined in the catalog.
		FString ItemClass;
		// [optional] Timestamp for when this instance was purchased.
		OptionalTime PurchaseDate;
		// [optional] Timestamp for when this instance will expire.
		OptionalTime Expiration;
		// [optional] Total number of remaining uses, if this is a consumable item.
		OptionalInt32 RemainingUses;
		// [optional] The number of uses that were added or removed to this item in this call.
		OptionalInt32 UsesIncrementedBy;
		// [optional] Game specific comment associated with this instance when it was added to the user inventory.
		FString Annotation;
		// [optional] Catalog version for the inventory item, when this instance was created.
		FString CatalogVersion;
		// [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or container.
		FString BundleParent;
		// [optional] CatalogItem.DisplayName at the time this item was purchased.
		FString DisplayName;
		// [optional] Currency type for the cost of the catalog item.
		FString UnitCurrency;
		// Cost of the catalog item in the given currency.
		uint32 UnitPrice;
		// [optional] Array of unique items that were awarded when this catalog item was purchased.
		TArray<FString> BundleContents;
		// [optional] A set of custom key-value pairs on the inventory item.
		TMap<FString, FString> CustomData;
	
        FItemInstance() :
			FPlayFabBaseModel(),
			ItemId(),
			ItemInstanceId(),
			ItemClass(),
			PurchaseDate(),
			Expiration(),
			RemainingUses(),
			UsesIncrementedBy(),
			Annotation(),
			CatalogVersion(),
			BundleParent(),
			DisplayName(),
			UnitCurrency(),
			UnitPrice(0),
			BundleContents(),
			CustomData()
			{}
		
		FItemInstance(const FItemInstance& src) :
			FPlayFabBaseModel(),
			ItemId(src.ItemId),
			ItemInstanceId(src.ItemInstanceId),
			ItemClass(src.ItemClass),
			PurchaseDate(src.PurchaseDate),
			Expiration(src.Expiration),
			RemainingUses(src.RemainingUses),
			UsesIncrementedBy(src.UsesIncrementedBy),
			Annotation(src.Annotation),
			CatalogVersion(src.CatalogVersion),
			BundleParent(src.BundleParent),
			DisplayName(src.DisplayName),
			UnitCurrency(src.UnitCurrency),
			UnitPrice(src.UnitPrice),
			BundleContents(src.BundleContents),
			CustomData(src.CustomData)
			{}
			
		FItemInstance(const TSharedPtr<FJsonObject>& obj) : FItemInstance()
        {
            readFromValue(obj);
        }
		
		~FItemInstance();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCharacterInventory : public FPlayFabBaseModel
    {
		
		// [optional] The id of this character.
		FString CharacterId;
		// [optional] The inventory of this character.
		TArray<FItemInstance> Inventory;
	
        FCharacterInventory() :
			FPlayFabBaseModel(),
			CharacterId(),
			Inventory()
			{}
		
		FCharacterInventory(const FCharacterInventory& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			Inventory(src.Inventory)
			{}
			
		FCharacterInventory(const TSharedPtr<FJsonObject>& obj) : FCharacterInventory()
        {
            readFromValue(obj);
        }
		
		~FCharacterInventory();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCharacterLeaderboardEntry : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier of the user for this leaderboard entry.
		FString PlayFabId;
		// [optional] PlayFab unique identifier of the character that belongs to the user for this leaderboard entry.
		FString CharacterId;
		// [optional] Title-specific display name of the character for this leaderboard entry.
		FString CharacterName;
		// [optional] Title-specific display name of the user for this leaderboard entry.
		FString DisplayName;
		// [optional] Name of the character class for this entry.
		FString CharacterType;
		// Specific value of the user's statistic.
		int32 StatValue;
		// User's overall position in the leaderboard.
		int32 Position;
	
        FCharacterLeaderboardEntry() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			CharacterName(),
			DisplayName(),
			CharacterType(),
			StatValue(0),
			Position(0)
			{}
		
		FCharacterLeaderboardEntry(const FCharacterLeaderboardEntry& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			CharacterName(src.CharacterName),
			DisplayName(src.DisplayName),
			CharacterType(src.CharacterType),
			StatValue(src.StatValue),
			Position(src.Position)
			{}
			
		FCharacterLeaderboardEntry(const TSharedPtr<FJsonObject>& obj) : FCharacterLeaderboardEntry()
        {
            readFromValue(obj);
        }
		
		~FCharacterLeaderboardEntry();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCharacterResult : public FPlayFabBaseModel
    {
		
		// [optional] The id for this character on this player.
		FString CharacterId;
		// [optional] The name of this character.
		FString CharacterName;
		// [optional] The type-string that was given to this character on creation.
		FString CharacterType;
	
        FCharacterResult() :
			FPlayFabBaseModel(),
			CharacterId(),
			CharacterName(),
			CharacterType()
			{}
		
		FCharacterResult(const FCharacterResult& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			CharacterName(src.CharacterName),
			CharacterType(src.CharacterType)
			{}
			
		FCharacterResult(const TSharedPtr<FJsonObject>& obj) : FCharacterResult()
        {
            readFromValue(obj);
        }
		
		~FCharacterResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum CloudScriptRevisionOption
	{
		CloudScriptRevisionOptionLive,
		CloudScriptRevisionOptionLatest,
		CloudScriptRevisionOptionSpecific
	};
	
	void writeCloudScriptRevisionOptionEnumJSON(CloudScriptRevisionOption enumVal, JsonWriter& writer);
	CloudScriptRevisionOption readCloudScriptRevisionOptionFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FContainer_Dictionary_String_String : public FPlayFabBaseModel
    {
		
		// [optional] Content of data
		TMap<FString, FString> Data;
	
        FContainer_Dictionary_String_String() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FContainer_Dictionary_String_String(const FContainer_Dictionary_String_String& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FContainer_Dictionary_String_String(const TSharedPtr<FJsonObject>& obj) : FContainer_Dictionary_String_String()
        {
            readFromValue(obj);
        }
		
		~FContainer_Dictionary_String_String();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCollectionFilter : public FPlayFabBaseModel
    {
		
		// [optional] List of Include rules, with any of which if a collection matches, it is included by the filter, unless it is excluded by one of the Exclude rule
		TArray<FContainer_Dictionary_String_String> Includes;
		// [optional] List of Exclude rules, with any of which if a collection matches, it is excluded by the filter.
		TArray<FContainer_Dictionary_String_String> Excludes;
	
        FCollectionFilter() :
			FPlayFabBaseModel(),
			Includes(),
			Excludes()
			{}
		
		FCollectionFilter(const FCollectionFilter& src) :
			FPlayFabBaseModel(),
			Includes(src.Includes),
			Excludes(src.Excludes)
			{}
			
		FCollectionFilter(const TSharedPtr<FJsonObject>& obj) : FCollectionFilter()
        {
            readFromValue(obj);
        }
		
		~FCollectionFilter();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FConfirmPurchaseRequest : public FPlayFabBaseModel
    {
		
		// Purchase order identifier returned from StartPurchase.
		FString OrderId;
	
        FConfirmPurchaseRequest() :
			FPlayFabBaseModel(),
			OrderId()
			{}
		
		FConfirmPurchaseRequest(const FConfirmPurchaseRequest& src) :
			FPlayFabBaseModel(),
			OrderId(src.OrderId)
			{}
			
		FConfirmPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FConfirmPurchaseRequest()
        {
            readFromValue(obj);
        }
		
		~FConfirmPurchaseRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FConfirmPurchaseResult : public FPlayFabBaseModel
    {
		
		// [optional] Purchase order identifier.
		FString OrderId;
		// Date and time of the purchase.
		FDateTime PurchaseDate;
		// [optional] Array of items purchased.
		TArray<FItemInstance> Items;
	
        FConfirmPurchaseResult() :
			FPlayFabBaseModel(),
			OrderId(),
			PurchaseDate(0),
			Items()
			{}
		
		FConfirmPurchaseResult(const FConfirmPurchaseResult& src) :
			FPlayFabBaseModel(),
			OrderId(src.OrderId),
			PurchaseDate(src.PurchaseDate),
			Items(src.Items)
			{}
			
		FConfirmPurchaseResult(const TSharedPtr<FJsonObject>& obj) : FConfirmPurchaseResult()
        {
            readFromValue(obj);
        }
		
		~FConfirmPurchaseResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FConsumeItemRequest : public FPlayFabBaseModel
    {
		
		// Unique instance identifier of the item to be consumed.
		FString ItemInstanceId;
		// Number of uses to consume from the item.
		int32 ConsumeCount;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
	
        FConsumeItemRequest() :
			FPlayFabBaseModel(),
			ItemInstanceId(),
			ConsumeCount(0),
			CharacterId()
			{}
		
		FConsumeItemRequest(const FConsumeItemRequest& src) :
			FPlayFabBaseModel(),
			ItemInstanceId(src.ItemInstanceId),
			ConsumeCount(src.ConsumeCount),
			CharacterId(src.CharacterId)
			{}
			
		FConsumeItemRequest(const TSharedPtr<FJsonObject>& obj) : FConsumeItemRequest()
        {
            readFromValue(obj);
        }
		
		~FConsumeItemRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FConsumeItemResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique instance identifier of the item with uses consumed.
		FString ItemInstanceId;
		// Number of uses remaining on the item.
		int32 RemainingUses;
	
        FConsumeItemResult() :
			FPlayFabBaseModel(),
			ItemInstanceId(),
			RemainingUses(0)
			{}
		
		FConsumeItemResult(const FConsumeItemResult& src) :
			FPlayFabBaseModel(),
			ItemInstanceId(src.ItemInstanceId),
			RemainingUses(src.RemainingUses)
			{}
			
		FConsumeItemResult(const TSharedPtr<FJsonObject>& obj) : FConsumeItemResult()
        {
            readFromValue(obj);
        }
		
		~FConsumeItemResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCreateSharedGroupRequest : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the shared group (a random identifier will be assigned, if one is not specified).
		FString SharedGroupId;
	
        FCreateSharedGroupRequest() :
			FPlayFabBaseModel(),
			SharedGroupId()
			{}
		
		FCreateSharedGroupRequest(const FCreateSharedGroupRequest& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId)
			{}
			
		FCreateSharedGroupRequest(const TSharedPtr<FJsonObject>& obj) : FCreateSharedGroupRequest()
        {
            readFromValue(obj);
        }
		
		~FCreateSharedGroupRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCreateSharedGroupResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the shared group.
		FString SharedGroupId;
	
        FCreateSharedGroupResult() :
			FPlayFabBaseModel(),
			SharedGroupId()
			{}
		
		FCreateSharedGroupResult(const FCreateSharedGroupResult& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId)
			{}
			
		FCreateSharedGroupResult(const TSharedPtr<FJsonObject>& obj) : FCreateSharedGroupResult()
        {
            readFromValue(obj);
        }
		
		~FCreateSharedGroupResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum Currency
	{
		CurrencyAED,
		CurrencyAFN,
		CurrencyALL,
		CurrencyAMD,
		CurrencyANG,
		CurrencyAOA,
		CurrencyARS,
		CurrencyAUD,
		CurrencyAWG,
		CurrencyAZN,
		CurrencyBAM,
		CurrencyBBD,
		CurrencyBDT,
		CurrencyBGN,
		CurrencyBHD,
		CurrencyBIF,
		CurrencyBMD,
		CurrencyBND,
		CurrencyBOB,
		CurrencyBRL,
		CurrencyBSD,
		CurrencyBTN,
		CurrencyBWP,
		CurrencyBYR,
		CurrencyBZD,
		CurrencyCAD,
		CurrencyCDF,
		CurrencyCHF,
		CurrencyCLP,
		CurrencyCNY,
		CurrencyCOP,
		CurrencyCRC,
		CurrencyCUC,
		CurrencyCUP,
		CurrencyCVE,
		CurrencyCZK,
		CurrencyDJF,
		CurrencyDKK,
		CurrencyDOP,
		CurrencyDZD,
		CurrencyEGP,
		CurrencyERN,
		CurrencyETB,
		CurrencyEUR,
		CurrencyFJD,
		CurrencyFKP,
		CurrencyGBP,
		CurrencyGEL,
		CurrencyGGP,
		CurrencyGHS,
		CurrencyGIP,
		CurrencyGMD,
		CurrencyGNF,
		CurrencyGTQ,
		CurrencyGYD,
		CurrencyHKD,
		CurrencyHNL,
		CurrencyHRK,
		CurrencyHTG,
		CurrencyHUF,
		CurrencyIDR,
		CurrencyILS,
		CurrencyIMP,
		CurrencyINR,
		CurrencyIQD,
		CurrencyIRR,
		CurrencyISK,
		CurrencyJEP,
		CurrencyJMD,
		CurrencyJOD,
		CurrencyJPY,
		CurrencyKES,
		CurrencyKGS,
		CurrencyKHR,
		CurrencyKMF,
		CurrencyKPW,
		CurrencyKRW,
		CurrencyKWD,
		CurrencyKYD,
		CurrencyKZT,
		CurrencyLAK,
		CurrencyLBP,
		CurrencyLKR,
		CurrencyLRD,
		CurrencyLSL,
		CurrencyLYD,
		CurrencyMAD,
		CurrencyMDL,
		CurrencyMGA,
		CurrencyMKD,
		CurrencyMMK,
		CurrencyMNT,
		CurrencyMOP,
		CurrencyMRO,
		CurrencyMUR,
		CurrencyMVR,
		CurrencyMWK,
		CurrencyMXN,
		CurrencyMYR,
		CurrencyMZN,
		CurrencyNAD,
		CurrencyNGN,
		CurrencyNIO,
		CurrencyNOK,
		CurrencyNPR,
		CurrencyNZD,
		CurrencyOMR,
		CurrencyPAB,
		CurrencyPEN,
		CurrencyPGK,
		CurrencyPHP,
		CurrencyPKR,
		CurrencyPLN,
		CurrencyPYG,
		CurrencyQAR,
		CurrencyRON,
		CurrencyRSD,
		CurrencyRUB,
		CurrencyRWF,
		CurrencySAR,
		CurrencySBD,
		CurrencySCR,
		CurrencySDG,
		CurrencySEK,
		CurrencySGD,
		CurrencySHP,
		CurrencySLL,
		CurrencySOS,
		CurrencySPL,
		CurrencySRD,
		CurrencySTD,
		CurrencySVC,
		CurrencySYP,
		CurrencySZL,
		CurrencyTHB,
		CurrencyTJS,
		CurrencyTMT,
		CurrencyTND,
		CurrencyTOP,
		CurrencyTRY,
		CurrencyTTD,
		CurrencyTVD,
		CurrencyTWD,
		CurrencyTZS,
		CurrencyUAH,
		CurrencyUGX,
		CurrencyUSD,
		CurrencyUYU,
		CurrencyUZS,
		CurrencyVEF,
		CurrencyVND,
		CurrencyVUV,
		CurrencyWST,
		CurrencyXAF,
		CurrencyXCD,
		CurrencyXDR,
		CurrencyXOF,
		CurrencyXPF,
		CurrencyYER,
		CurrencyZAR,
		CurrencyZMW,
		CurrencyZWD
	};
	
	void writeCurrencyEnumJSON(Currency enumVal, JsonWriter& writer);
	Currency readCurrencyFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	enum Region
	{
		RegionUSCentral,
		RegionUSEast,
		RegionEUWest,
		RegionSingapore,
		RegionJapan,
		RegionBrazil,
		RegionAustralia
	};
	
	void writeRegionEnumJSON(Region enumVal, JsonWriter& writer);
	Region readRegionFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FCurrentGamesRequest : public FPlayFabBaseModel
    {
		
		// [optional] Region to check for Game Server Instances.
		Boxed<Region> pfRegion;
		// [optional] Build to match against.
		FString BuildVersion;
		// [optional] Game mode to look for.
		FString GameMode;
		// [optional] Statistic name to find statistic-based matches.
		FString StatisticName;
		// [optional] Filter to include and/or exclude Game Server Instances associated with certain tags.
		TSharedPtr<FCollectionFilter> TagFilter;
	
        FCurrentGamesRequest() :
			FPlayFabBaseModel(),
			pfRegion(),
			BuildVersion(),
			GameMode(),
			StatisticName(),
			TagFilter(nullptr)
			{}
		
		FCurrentGamesRequest(const FCurrentGamesRequest& src) :
			FPlayFabBaseModel(),
			pfRegion(src.pfRegion),
			BuildVersion(src.BuildVersion),
			GameMode(src.GameMode),
			StatisticName(src.StatisticName),
			TagFilter(src.TagFilter.IsValid() ? MakeShareable(new FCollectionFilter(*src.TagFilter)) : nullptr)
			{}
			
		FCurrentGamesRequest(const TSharedPtr<FJsonObject>& obj) : FCurrentGamesRequest()
        {
            readFromValue(obj);
        }
		
		~FCurrentGamesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum GameInstanceState
	{
		GameInstanceStateOpen,
		GameInstanceStateClosed
	};
	
	void writeGameInstanceStateEnumJSON(GameInstanceState enumVal, JsonWriter& writer);
	GameInstanceState readGameInstanceStateFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FGameInfo : public FPlayFabBaseModel
    {
		
		// [optional] region to which this server is associated
		Boxed<Region> pfRegion;
		// [optional] unique lobby identifier for this game server
		FString LobbyID;
		// [optional] build version this server is running
		FString BuildVersion;
		// [optional] game mode this server is running
		FString GameMode;
		// [optional] stastic used to match this game in player statistic matchmaking
		FString StatisticName;
		// [optional] maximum players this server can support
		OptionalInt32 MaxPlayers;
		// [optional] array of current player IDs on this server
		TArray<FString> PlayerUserIds;
		// duration in seconds this server has been running
		uint32 RunTime;
		// [optional] game specific string denoting server configuration
		Boxed<GameInstanceState> GameServerState;
		// [optional] game session custom data
		FString GameServerData;
		// [optional] game session tags
		TMap<FString, FString> Tags;
		// [optional] last heartbeat of the game server instance, used in external game server provider mode
		OptionalTime LastHeartbeat;
		// [optional] IP address of the server
		FString ServerHostname;
		// [optional] port number to use for non-http communications with the server
		OptionalInt32 ServerPort;
	
        FGameInfo() :
			FPlayFabBaseModel(),
			pfRegion(),
			LobbyID(),
			BuildVersion(),
			GameMode(),
			StatisticName(),
			MaxPlayers(),
			PlayerUserIds(),
			RunTime(0),
			GameServerState(),
			GameServerData(),
			Tags(),
			LastHeartbeat(),
			ServerHostname(),
			ServerPort()
			{}
		
		FGameInfo(const FGameInfo& src) :
			FPlayFabBaseModel(),
			pfRegion(src.pfRegion),
			LobbyID(src.LobbyID),
			BuildVersion(src.BuildVersion),
			GameMode(src.GameMode),
			StatisticName(src.StatisticName),
			MaxPlayers(src.MaxPlayers),
			PlayerUserIds(src.PlayerUserIds),
			RunTime(src.RunTime),
			GameServerState(src.GameServerState),
			GameServerData(src.GameServerData),
			Tags(src.Tags),
			LastHeartbeat(src.LastHeartbeat),
			ServerHostname(src.ServerHostname),
			ServerPort(src.ServerPort)
			{}
			
		FGameInfo(const TSharedPtr<FJsonObject>& obj) : FGameInfo()
        {
            readFromValue(obj);
        }
		
		~FGameInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCurrentGamesResult : public FPlayFabBaseModel
    {
		
		// [optional] array of games found
		TArray<FGameInfo> Games;
		// total number of players across all servers
		int32 PlayerCount;
		// number of games running
		int32 GameCount;
	
        FCurrentGamesResult() :
			FPlayFabBaseModel(),
			Games(),
			PlayerCount(0),
			GameCount(0)
			{}
		
		FCurrentGamesResult(const FCurrentGamesResult& src) :
			FPlayFabBaseModel(),
			Games(src.Games),
			PlayerCount(src.PlayerCount),
			GameCount(src.GameCount)
			{}
			
		FCurrentGamesResult(const TSharedPtr<FJsonObject>& obj) : FCurrentGamesResult()
        {
            readFromValue(obj);
        }
		
		~FCurrentGamesResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FEmptyResult : public FPlayFabBaseModel
    {
		
	
        FEmptyResult() :
			FPlayFabBaseModel()
			{}
		
		FEmptyResult(const FEmptyResult& src) :
			FPlayFabBaseModel()
			{}
			
		FEmptyResult(const TSharedPtr<FJsonObject>& obj) : FEmptyResult()
        {
            readFromValue(obj);
        }
		
		~FEmptyResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FExecuteCloudScriptRequest : public FPlayFabBaseModel
    {
		
		// The name of the CloudScript function to execute
		FString FunctionName;
		// [optional] Object that is passed in to the function as the first argument
		FMultitypeVar FunctionParameter;
		// [optional] Option for which revision of the CloudScript to execute. 'Latest' executes the most recently created revision, 'Live' executes the current live, published revision, and 'Specific' executes the specified revision. The default value is 'Specific', if the SpeificRevision parameter is specified, otherwise it is 'Live'.
		Boxed<CloudScriptRevisionOption> RevisionSelection;
		// [optional] The specivic revision to execute, when RevisionSelection is set to 'Specific'
		OptionalInt32 SpecificRevision;
		// [optional] Generate a 'player_executed_cloudscript' PlayStream event containing the results of the function execution and other contextual information. This event will show up in the PlayStream debugger console for the player in Game Manager.
		OptionalBool GeneratePlayStreamEvent;
	
        FExecuteCloudScriptRequest() :
			FPlayFabBaseModel(),
			FunctionName(),
			FunctionParameter(),
			RevisionSelection(),
			SpecificRevision(),
			GeneratePlayStreamEvent()
			{}
		
		FExecuteCloudScriptRequest(const FExecuteCloudScriptRequest& src) :
			FPlayFabBaseModel(),
			FunctionName(src.FunctionName),
			FunctionParameter(src.FunctionParameter),
			RevisionSelection(src.RevisionSelection),
			SpecificRevision(src.SpecificRevision),
			GeneratePlayStreamEvent(src.GeneratePlayStreamEvent)
			{}
			
		FExecuteCloudScriptRequest(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptRequest()
        {
            readFromValue(obj);
        }
		
		~FExecuteCloudScriptRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLogStatement : public FPlayFabBaseModel
    {
		
		// [optional] 'Debug', 'Info', or 'Error'
		FString Level;
		// [optional] undefined
		FString Message;
		// [optional] Optional object accompanying the message as contextual information
		FMultitypeVar Data;
	
        FLogStatement() :
			FPlayFabBaseModel(),
			Level(),
			Message(),
			Data()
			{}
		
		FLogStatement(const FLogStatement& src) :
			FPlayFabBaseModel(),
			Level(src.Level),
			Message(src.Message),
			Data(src.Data)
			{}
			
		FLogStatement(const TSharedPtr<FJsonObject>& obj) : FLogStatement()
        {
            readFromValue(obj);
        }
		
		~FLogStatement();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FScriptExecutionError : public FPlayFabBaseModel
    {
		
		// [optional] Error code, such as CloudScriptNotFound, JavascriptException, CloudScriptFunctionArgumentSizeExceeded, CloudScriptAPIRequestCountExceeded, CloudScriptAPIRequestError, or CloudScriptHTTPRequestError
		FString Error;
		// [optional] Details about the error
		FString Message;
		// [optional] Point during the execution of the script at which the error occurred, if any
		FString StackTrace;
	
        FScriptExecutionError() :
			FPlayFabBaseModel(),
			Error(),
			Message(),
			StackTrace()
			{}
		
		FScriptExecutionError(const FScriptExecutionError& src) :
			FPlayFabBaseModel(),
			Error(src.Error),
			Message(src.Message),
			StackTrace(src.StackTrace)
			{}
			
		FScriptExecutionError(const TSharedPtr<FJsonObject>& obj) : FScriptExecutionError()
        {
            readFromValue(obj);
        }
		
		~FScriptExecutionError();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FExecuteCloudScriptResult : public FPlayFabBaseModel
    {
		
		// [optional] The name of the function that executed
		FString FunctionName;
		// The revision of the CloudScript that executed
		int32 Revision;
		// [optional] The object returned from the CloudScript function, if any
		FMultitypeVar FunctionResult;
		// [optional] Entries logged during the function execution. These include both entries logged in the function code using log.info() and log.error() and error entries for API and HTTP request failures.
		TArray<FLogStatement> Logs;
		// undefined
		double ExecutionTimeSeconds;
		// Processor time consumed while executing the function. This does not include time spent waiting on API calls or HTTP requests.
		double ProcessorTimeSeconds;
		// undefined
		uint32 MemoryConsumedBytes;
		// Number of PlayFab API requests issued by the CloudScript function
		int32 APIRequestsIssued;
		// Number of external HTTP requests issued by the CloudScript function
		int32 HttpRequestsIssued;
		// [optional] Information about the error, if any, that occured during execution
		TSharedPtr<FScriptExecutionError> Error;
	
        FExecuteCloudScriptResult() :
			FPlayFabBaseModel(),
			FunctionName(),
			Revision(0),
			FunctionResult(),
			Logs(),
			ExecutionTimeSeconds(0),
			ProcessorTimeSeconds(0),
			MemoryConsumedBytes(0),
			APIRequestsIssued(0),
			HttpRequestsIssued(0),
			Error(nullptr)
			{}
		
		FExecuteCloudScriptResult(const FExecuteCloudScriptResult& src) :
			FPlayFabBaseModel(),
			FunctionName(src.FunctionName),
			Revision(src.Revision),
			FunctionResult(src.FunctionResult),
			Logs(src.Logs),
			ExecutionTimeSeconds(src.ExecutionTimeSeconds),
			ProcessorTimeSeconds(src.ProcessorTimeSeconds),
			MemoryConsumedBytes(src.MemoryConsumedBytes),
			APIRequestsIssued(src.APIRequestsIssued),
			HttpRequestsIssued(src.HttpRequestsIssued),
			Error(src.Error.IsValid() ? MakeShareable(new FScriptExecutionError(*src.Error)) : nullptr)
			{}
			
		FExecuteCloudScriptResult(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptResult()
        {
            readFromValue(obj);
        }
		
		~FExecuteCloudScriptResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FFacebookPlayFabIdPair : public FPlayFabBaseModel
    {
		
		// [optional] Unique Facebook identifier for a user.
		FString FacebookId;
		// [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Facebook identifier.
		FString PlayFabId;
	
        FFacebookPlayFabIdPair() :
			FPlayFabBaseModel(),
			FacebookId(),
			PlayFabId()
			{}
		
		FFacebookPlayFabIdPair(const FFacebookPlayFabIdPair& src) :
			FPlayFabBaseModel(),
			FacebookId(src.FacebookId),
			PlayFabId(src.PlayFabId)
			{}
			
		FFacebookPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FFacebookPlayFabIdPair()
        {
            readFromValue(obj);
        }
		
		~FFacebookPlayFabIdPair();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserFacebookInfo : public FPlayFabBaseModel
    {
		
		// [optional] Facebook identifier
		FString FacebookId;
		// [optional] Facebook full name
		FString FullName;
	
        FUserFacebookInfo() :
			FPlayFabBaseModel(),
			FacebookId(),
			FullName()
			{}
		
		FUserFacebookInfo(const FUserFacebookInfo& src) :
			FPlayFabBaseModel(),
			FacebookId(src.FacebookId),
			FullName(src.FullName)
			{}
			
		FUserFacebookInfo(const TSharedPtr<FJsonObject>& obj) : FUserFacebookInfo()
        {
            readFromValue(obj);
        }
		
		~FUserFacebookInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum TitleActivationStatus
	{
		TitleActivationStatusNone,
		TitleActivationStatusActivatedTitleKey,
		TitleActivationStatusPendingSteam,
		TitleActivationStatusActivatedSteam,
		TitleActivationStatusRevokedSteam
	};
	
	void writeTitleActivationStatusEnumJSON(TitleActivationStatus enumVal, JsonWriter& writer);
	TitleActivationStatus readTitleActivationStatusFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FUserSteamInfo : public FPlayFabBaseModel
    {
		
		// [optional] Steam identifier
		FString SteamId;
		// [optional] the country in which the player resides, from Steam data
		FString SteamCountry;
		// [optional] currency type set in the user Steam account
		Boxed<Currency> SteamCurrency;
		// [optional] what stage of game ownership the user is listed as being in, from Steam
		Boxed<TitleActivationStatus> SteamActivationStatus;
	
        FUserSteamInfo() :
			FPlayFabBaseModel(),
			SteamId(),
			SteamCountry(),
			SteamCurrency(),
			SteamActivationStatus()
			{}
		
		FUserSteamInfo(const FUserSteamInfo& src) :
			FPlayFabBaseModel(),
			SteamId(src.SteamId),
			SteamCountry(src.SteamCountry),
			SteamCurrency(src.SteamCurrency),
			SteamActivationStatus(src.SteamActivationStatus)
			{}
			
		FUserSteamInfo(const TSharedPtr<FJsonObject>& obj) : FUserSteamInfo()
        {
            readFromValue(obj);
        }
		
		~FUserSteamInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserGameCenterInfo : public FPlayFabBaseModel
    {
		
		// [optional] Gamecenter identifier
		FString GameCenterId;
	
        FUserGameCenterInfo() :
			FPlayFabBaseModel(),
			GameCenterId()
			{}
		
		FUserGameCenterInfo(const FUserGameCenterInfo& src) :
			FPlayFabBaseModel(),
			GameCenterId(src.GameCenterId)
			{}
			
		FUserGameCenterInfo(const TSharedPtr<FJsonObject>& obj) : FUserGameCenterInfo()
        {
            readFromValue(obj);
        }
		
		~FUserGameCenterInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FFriendInfo : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier for this friend.
		FString FriendPlayFabId;
		// [optional] PlayFab unique username for this friend.
		FString Username;
		// [optional] Title-specific display name for this friend.
		FString TitleDisplayName;
		// [optional] Tags which have been associated with this friend.
		TArray<FString> Tags;
		// [optional] Unique lobby identifier of the Game Server Instance to which this player is currently connected.
		FString CurrentMatchmakerLobbyId;
		// [optional] Available Facebook information (if the user and PlayFab friend are also connected in Facebook).
		TSharedPtr<FUserFacebookInfo> FacebookInfo;
		// [optional] Available Steam information (if the user and PlayFab friend are also connected in Steam).
		TSharedPtr<FUserSteamInfo> SteamInfo;
		// [optional] Available Game Center information (if the user and PlayFab friend are also connected in Game Center).
		TSharedPtr<FUserGameCenterInfo> GameCenterInfo;
	
        FFriendInfo() :
			FPlayFabBaseModel(),
			FriendPlayFabId(),
			Username(),
			TitleDisplayName(),
			Tags(),
			CurrentMatchmakerLobbyId(),
			FacebookInfo(nullptr),
			SteamInfo(nullptr),
			GameCenterInfo(nullptr)
			{}
		
		FFriendInfo(const FFriendInfo& src) :
			FPlayFabBaseModel(),
			FriendPlayFabId(src.FriendPlayFabId),
			Username(src.Username),
			TitleDisplayName(src.TitleDisplayName),
			Tags(src.Tags),
			CurrentMatchmakerLobbyId(src.CurrentMatchmakerLobbyId),
			FacebookInfo(src.FacebookInfo.IsValid() ? MakeShareable(new FUserFacebookInfo(*src.FacebookInfo)) : nullptr),
			SteamInfo(src.SteamInfo.IsValid() ? MakeShareable(new FUserSteamInfo(*src.SteamInfo)) : nullptr),
			GameCenterInfo(src.GameCenterInfo.IsValid() ? MakeShareable(new FUserGameCenterInfo(*src.GameCenterInfo)) : nullptr)
			{}
			
		FFriendInfo(const TSharedPtr<FJsonObject>& obj) : FFriendInfo()
        {
            readFromValue(obj);
        }
		
		~FFriendInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGameCenterPlayFabIdPair : public FPlayFabBaseModel
    {
		
		// [optional] Unique Game Center identifier for a user.
		FString GameCenterId;
		// [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Game Center identifier.
		FString PlayFabId;
	
        FGameCenterPlayFabIdPair() :
			FPlayFabBaseModel(),
			GameCenterId(),
			PlayFabId()
			{}
		
		FGameCenterPlayFabIdPair(const FGameCenterPlayFabIdPair& src) :
			FPlayFabBaseModel(),
			GameCenterId(src.GameCenterId),
			PlayFabId(src.PlayFabId)
			{}
			
		FGameCenterPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FGameCenterPlayFabIdPair()
        {
            readFromValue(obj);
        }
		
		~FGameCenterPlayFabIdPair();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGameServerRegionsRequest : public FPlayFabBaseModel
    {
		
		// version of game server for which stats are being requested
		FString BuildVersion;
		// [optional] Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
	
        FGameServerRegionsRequest() :
			FPlayFabBaseModel(),
			BuildVersion(),
			TitleId()
			{}
		
		FGameServerRegionsRequest(const FGameServerRegionsRequest& src) :
			FPlayFabBaseModel(),
			BuildVersion(src.BuildVersion),
			TitleId(src.TitleId)
			{}
			
		FGameServerRegionsRequest(const TSharedPtr<FJsonObject>& obj) : FGameServerRegionsRequest()
        {
            readFromValue(obj);
        }
		
		~FGameServerRegionsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRegionInfo : public FPlayFabBaseModel
    {
		
		// [optional] unique identifier for the region
		Boxed<Region> pfRegion;
		// [optional] name of the region
		FString Name;
		// indicates whether the server specified is available in this region
		bool Available;
		// [optional] url to ping to get roundtrip time
		FString PingUrl;
	
        FRegionInfo() :
			FPlayFabBaseModel(),
			pfRegion(),
			Name(),
			Available(false),
			PingUrl()
			{}
		
		FRegionInfo(const FRegionInfo& src) :
			FPlayFabBaseModel(),
			pfRegion(src.pfRegion),
			Name(src.Name),
			Available(src.Available),
			PingUrl(src.PingUrl)
			{}
			
		FRegionInfo(const TSharedPtr<FJsonObject>& obj) : FRegionInfo()
        {
            readFromValue(obj);
        }
		
		~FRegionInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGameServerRegionsResult : public FPlayFabBaseModel
    {
		
		// [optional] array of regions found matching the request parameters
		TArray<FRegionInfo> Regions;
	
        FGameServerRegionsResult() :
			FPlayFabBaseModel(),
			Regions()
			{}
		
		FGameServerRegionsResult(const FGameServerRegionsResult& src) :
			FPlayFabBaseModel(),
			Regions(src.Regions)
			{}
			
		FGameServerRegionsResult(const TSharedPtr<FJsonObject>& obj) : FGameServerRegionsResult()
        {
            readFromValue(obj);
        }
		
		~FGameServerRegionsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGenericPlayFabIdPair : public FPlayFabBaseModel
    {
		
		// [optional] Unique generic service identifier for a user.
		TSharedPtr<FGenericServiceId> GenericId;
		// [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the given generic identifier.
		FString PlayFabId;
	
        FGenericPlayFabIdPair() :
			FPlayFabBaseModel(),
			GenericId(nullptr),
			PlayFabId()
			{}
		
		FGenericPlayFabIdPair(const FGenericPlayFabIdPair& src) :
			FPlayFabBaseModel(),
			GenericId(src.GenericId.IsValid() ? MakeShareable(new FGenericServiceId(*src.GenericId)) : nullptr),
			PlayFabId(src.PlayFabId)
			{}
			
		FGenericPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FGenericPlayFabIdPair()
        {
            readFromValue(obj);
        }
		
		~FGenericPlayFabIdPair();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetAccountInfoRequest : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab identifier of the user whose info is being requested. Optional, defaults to the authenticated user if no other lookup identifier set.
		FString PlayFabId;
		// [optional] PlayFab Username for the account to find (if no PlayFabId is specified).
		FString Username;
		// [optional] User email address for the account to find (if no Username is specified).
		FString Email;
		// [optional] Title-specific username for the account to find (if no Email is set). Note that if the non-unique Title Display Names option is enabled for the title, attempts to look up users by Title Display Name will always return AccountNotFound.
		FString TitleDisplayName;
	
        FGetAccountInfoRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Username(),
			Email(),
			TitleDisplayName()
			{}
		
		FGetAccountInfoRequest(const FGetAccountInfoRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Username(src.Username),
			Email(src.Email),
			TitleDisplayName(src.TitleDisplayName)
			{}
			
		FGetAccountInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetAccountInfoRequest()
        {
            readFromValue(obj);
        }
		
		~FGetAccountInfoRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum UserOrigination
	{
		UserOriginationOrganic,
		UserOriginationSteam,
		UserOriginationGoogle,
		UserOriginationAmazon,
		UserOriginationFacebook,
		UserOriginationKongregate,
		UserOriginationGamersFirst,
		UserOriginationUnknown,
		UserOriginationIOS,
		UserOriginationLoadTest,
		UserOriginationAndroid,
		UserOriginationPSN,
		UserOriginationGameCenter,
		UserOriginationCustomId,
		UserOriginationXboxLive,
		UserOriginationParse,
		UserOriginationTwitch
	};
	
	void writeUserOriginationEnumJSON(UserOrigination enumVal, JsonWriter& writer);
	UserOrigination readUserOriginationFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FUserTitleInfo : public FPlayFabBaseModel
    {
		
		// [optional] name of the user, as it is displayed in-game
		FString DisplayName;
		// [optional] source by which the user first joined the game, if known
		Boxed<UserOrigination> Origination;
		// timestamp indicating when the user was first associated with this game (this can differ significantly from when the user first registered with PlayFab)
		FDateTime Created;
		// [optional] timestamp for the last user login for this title
		OptionalTime LastLogin;
		// [optional] timestamp indicating when the user first signed into this game (this can differ from the Created timestamp, as other events, such as issuing a beta key to the user, can associate the title to the user)
		OptionalTime FirstLogin;
		// [optional] boolean indicating whether or not the user is currently banned for a title
		OptionalBool isBanned;
	
        FUserTitleInfo() :
			FPlayFabBaseModel(),
			DisplayName(),
			Origination(),
			Created(0),
			LastLogin(),
			FirstLogin(),
			isBanned()
			{}
		
		FUserTitleInfo(const FUserTitleInfo& src) :
			FPlayFabBaseModel(),
			DisplayName(src.DisplayName),
			Origination(src.Origination),
			Created(src.Created),
			LastLogin(src.LastLogin),
			FirstLogin(src.FirstLogin),
			isBanned(src.isBanned)
			{}
			
		FUserTitleInfo(const TSharedPtr<FJsonObject>& obj) : FUserTitleInfo()
        {
            readFromValue(obj);
        }
		
		~FUserTitleInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserPrivateAccountInfo : public FPlayFabBaseModel
    {
		
		// [optional] user email address
		FString Email;
	
        FUserPrivateAccountInfo() :
			FPlayFabBaseModel(),
			Email()
			{}
		
		FUserPrivateAccountInfo(const FUserPrivateAccountInfo& src) :
			FPlayFabBaseModel(),
			Email(src.Email)
			{}
			
		FUserPrivateAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserPrivateAccountInfo()
        {
            readFromValue(obj);
        }
		
		~FUserPrivateAccountInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserIosDeviceInfo : public FPlayFabBaseModel
    {
		
		// [optional] iOS device ID
		FString IosDeviceId;
	
        FUserIosDeviceInfo() :
			FPlayFabBaseModel(),
			IosDeviceId()
			{}
		
		FUserIosDeviceInfo(const FUserIosDeviceInfo& src) :
			FPlayFabBaseModel(),
			IosDeviceId(src.IosDeviceId)
			{}
			
		FUserIosDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserIosDeviceInfo()
        {
            readFromValue(obj);
        }
		
		~FUserIosDeviceInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserAndroidDeviceInfo : public FPlayFabBaseModel
    {
		
		// [optional] Android device ID
		FString AndroidDeviceId;
	
        FUserAndroidDeviceInfo() :
			FPlayFabBaseModel(),
			AndroidDeviceId()
			{}
		
		FUserAndroidDeviceInfo(const FUserAndroidDeviceInfo& src) :
			FPlayFabBaseModel(),
			AndroidDeviceId(src.AndroidDeviceId)
			{}
			
		FUserAndroidDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserAndroidDeviceInfo()
        {
            readFromValue(obj);
        }
		
		~FUserAndroidDeviceInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserKongregateInfo : public FPlayFabBaseModel
    {
		
		// [optional] Kongregate ID
		FString KongregateId;
		// [optional] Kongregate Username
		FString KongregateName;
	
        FUserKongregateInfo() :
			FPlayFabBaseModel(),
			KongregateId(),
			KongregateName()
			{}
		
		FUserKongregateInfo(const FUserKongregateInfo& src) :
			FPlayFabBaseModel(),
			KongregateId(src.KongregateId),
			KongregateName(src.KongregateName)
			{}
			
		FUserKongregateInfo(const TSharedPtr<FJsonObject>& obj) : FUserKongregateInfo()
        {
            readFromValue(obj);
        }
		
		~FUserKongregateInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserTwitchInfo : public FPlayFabBaseModel
    {
		
		// [optional] Twitch ID
		FString TwitchId;
		// [optional] Twitch Username
		FString TwitchUserName;
	
        FUserTwitchInfo() :
			FPlayFabBaseModel(),
			TwitchId(),
			TwitchUserName()
			{}
		
		FUserTwitchInfo(const FUserTwitchInfo& src) :
			FPlayFabBaseModel(),
			TwitchId(src.TwitchId),
			TwitchUserName(src.TwitchUserName)
			{}
			
		FUserTwitchInfo(const TSharedPtr<FJsonObject>& obj) : FUserTwitchInfo()
        {
            readFromValue(obj);
        }
		
		~FUserTwitchInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserPsnInfo : public FPlayFabBaseModel
    {
		
		// [optional] PSN account ID
		FString PsnAccountId;
		// [optional] PSN online ID
		FString PsnOnlineId;
	
        FUserPsnInfo() :
			FPlayFabBaseModel(),
			PsnAccountId(),
			PsnOnlineId()
			{}
		
		FUserPsnInfo(const FUserPsnInfo& src) :
			FPlayFabBaseModel(),
			PsnAccountId(src.PsnAccountId),
			PsnOnlineId(src.PsnOnlineId)
			{}
			
		FUserPsnInfo(const TSharedPtr<FJsonObject>& obj) : FUserPsnInfo()
        {
            readFromValue(obj);
        }
		
		~FUserPsnInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserGoogleInfo : public FPlayFabBaseModel
    {
		
		// [optional] Google ID
		FString GoogleId;
		// [optional] Email address of the Google account
		FString GoogleEmail;
		// [optional] Locale of the Google account
		FString GoogleLocale;
		// [optional] Gender information of the Google account
		FString GoogleGender;
	
        FUserGoogleInfo() :
			FPlayFabBaseModel(),
			GoogleId(),
			GoogleEmail(),
			GoogleLocale(),
			GoogleGender()
			{}
		
		FUserGoogleInfo(const FUserGoogleInfo& src) :
			FPlayFabBaseModel(),
			GoogleId(src.GoogleId),
			GoogleEmail(src.GoogleEmail),
			GoogleLocale(src.GoogleLocale),
			GoogleGender(src.GoogleGender)
			{}
			
		FUserGoogleInfo(const TSharedPtr<FJsonObject>& obj) : FUserGoogleInfo()
        {
            readFromValue(obj);
        }
		
		~FUserGoogleInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserXboxInfo : public FPlayFabBaseModel
    {
		
		// [optional] XBox user ID
		FString XboxUserId;
	
        FUserXboxInfo() :
			FPlayFabBaseModel(),
			XboxUserId()
			{}
		
		FUserXboxInfo(const FUserXboxInfo& src) :
			FPlayFabBaseModel(),
			XboxUserId(src.XboxUserId)
			{}
			
		FUserXboxInfo(const TSharedPtr<FJsonObject>& obj) : FUserXboxInfo()
        {
            readFromValue(obj);
        }
		
		~FUserXboxInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserCustomIdInfo : public FPlayFabBaseModel
    {
		
		// [optional] Custom ID
		FString CustomId;
	
        FUserCustomIdInfo() :
			FPlayFabBaseModel(),
			CustomId()
			{}
		
		FUserCustomIdInfo(const FUserCustomIdInfo& src) :
			FPlayFabBaseModel(),
			CustomId(src.CustomId)
			{}
			
		FUserCustomIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserCustomIdInfo()
        {
            readFromValue(obj);
        }
		
		~FUserCustomIdInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserAccountInfo : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the user account
		FString PlayFabId;
		// Timestamp indicating when the user account was created
		FDateTime Created;
		// [optional] User account name in the PlayFab service
		FString Username;
		// [optional] Title-specific information for the user account
		TSharedPtr<FUserTitleInfo> TitleInfo;
		// [optional] Personal information for the user which is considered more sensitive
		TSharedPtr<FUserPrivateAccountInfo> PrivateInfo;
		// [optional] User Facebook information, if a Facebook account has been linked
		TSharedPtr<FUserFacebookInfo> FacebookInfo;
		// [optional] User Steam information, if a Steam account has been linked
		TSharedPtr<FUserSteamInfo> SteamInfo;
		// [optional] User Gamecenter information, if a Gamecenter account has been linked
		TSharedPtr<FUserGameCenterInfo> GameCenterInfo;
		// [optional] User iOS device information, if an iOS device has been linked
		TSharedPtr<FUserIosDeviceInfo> IosDeviceInfo;
		// [optional] User Android device information, if an Android device has been linked
		TSharedPtr<FUserAndroidDeviceInfo> AndroidDeviceInfo;
		// [optional] User Kongregate account information, if a Kongregate account has been linked
		TSharedPtr<FUserKongregateInfo> KongregateInfo;
		// [optional] User Twitch account information, if a Twitch account has been linked
		TSharedPtr<FUserTwitchInfo> TwitchInfo;
		// [optional] User PSN account information, if a PSN account has been linked
		TSharedPtr<FUserPsnInfo> PsnInfo;
		// [optional] User Google account information, if a Google account has been linked
		TSharedPtr<FUserGoogleInfo> GoogleInfo;
		// [optional] User XBox account information, if a XBox account has been linked
		TSharedPtr<FUserXboxInfo> XboxInfo;
		// [optional] Custom ID information, if a custom ID has been assigned
		TSharedPtr<FUserCustomIdInfo> CustomIdInfo;
	
        FUserAccountInfo() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Created(0),
			Username(),
			TitleInfo(nullptr),
			PrivateInfo(nullptr),
			FacebookInfo(nullptr),
			SteamInfo(nullptr),
			GameCenterInfo(nullptr),
			IosDeviceInfo(nullptr),
			AndroidDeviceInfo(nullptr),
			KongregateInfo(nullptr),
			TwitchInfo(nullptr),
			PsnInfo(nullptr),
			GoogleInfo(nullptr),
			XboxInfo(nullptr),
			CustomIdInfo(nullptr)
			{}
		
		FUserAccountInfo(const FUserAccountInfo& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Created(src.Created),
			Username(src.Username),
			TitleInfo(src.TitleInfo.IsValid() ? MakeShareable(new FUserTitleInfo(*src.TitleInfo)) : nullptr),
			PrivateInfo(src.PrivateInfo.IsValid() ? MakeShareable(new FUserPrivateAccountInfo(*src.PrivateInfo)) : nullptr),
			FacebookInfo(src.FacebookInfo.IsValid() ? MakeShareable(new FUserFacebookInfo(*src.FacebookInfo)) : nullptr),
			SteamInfo(src.SteamInfo.IsValid() ? MakeShareable(new FUserSteamInfo(*src.SteamInfo)) : nullptr),
			GameCenterInfo(src.GameCenterInfo.IsValid() ? MakeShareable(new FUserGameCenterInfo(*src.GameCenterInfo)) : nullptr),
			IosDeviceInfo(src.IosDeviceInfo.IsValid() ? MakeShareable(new FUserIosDeviceInfo(*src.IosDeviceInfo)) : nullptr),
			AndroidDeviceInfo(src.AndroidDeviceInfo.IsValid() ? MakeShareable(new FUserAndroidDeviceInfo(*src.AndroidDeviceInfo)) : nullptr),
			KongregateInfo(src.KongregateInfo.IsValid() ? MakeShareable(new FUserKongregateInfo(*src.KongregateInfo)) : nullptr),
			TwitchInfo(src.TwitchInfo.IsValid() ? MakeShareable(new FUserTwitchInfo(*src.TwitchInfo)) : nullptr),
			PsnInfo(src.PsnInfo.IsValid() ? MakeShareable(new FUserPsnInfo(*src.PsnInfo)) : nullptr),
			GoogleInfo(src.GoogleInfo.IsValid() ? MakeShareable(new FUserGoogleInfo(*src.GoogleInfo)) : nullptr),
			XboxInfo(src.XboxInfo.IsValid() ? MakeShareable(new FUserXboxInfo(*src.XboxInfo)) : nullptr),
			CustomIdInfo(src.CustomIdInfo.IsValid() ? MakeShareable(new FUserCustomIdInfo(*src.CustomIdInfo)) : nullptr)
			{}
			
		FUserAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserAccountInfo()
        {
            readFromValue(obj);
        }
		
		~FUserAccountInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetAccountInfoResult : public FPlayFabBaseModel
    {
		
		// [optional] Account information for the local user.
		TSharedPtr<FUserAccountInfo> AccountInfo;
	
        FGetAccountInfoResult() :
			FPlayFabBaseModel(),
			AccountInfo(nullptr)
			{}
		
		FGetAccountInfoResult(const FGetAccountInfoResult& src) :
			FPlayFabBaseModel(),
			AccountInfo(src.AccountInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.AccountInfo)) : nullptr)
			{}
			
		FGetAccountInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetAccountInfoResult()
        {
            readFromValue(obj);
        }
		
		~FGetAccountInfoResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCatalogItemsRequest : public FPlayFabBaseModel
    {
		
		// [optional] Which catalog is being requested. If null, uses the default catalog.
		FString CatalogVersion;
	
        FGetCatalogItemsRequest() :
			FPlayFabBaseModel(),
			CatalogVersion()
			{}
		
		FGetCatalogItemsRequest(const FGetCatalogItemsRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion)
			{}
			
		FGetCatalogItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCatalogItemsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCatalogItemsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of items which can be purchased.
		TArray<FCatalogItem> Catalog;
	
        FGetCatalogItemsResult() :
			FPlayFabBaseModel(),
			Catalog()
			{}
		
		FGetCatalogItemsResult(const FGetCatalogItemsResult& src) :
			FPlayFabBaseModel(),
			Catalog(src.Catalog)
			{}
			
		FGetCatalogItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsResult()
        {
            readFromValue(obj);
        }
		
		~FGetCatalogItemsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterDataRequest : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab identifier of the user to load data for. Optional, defaults to yourself if not set.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Specific keys to search for in the custom user data.
		TArray<FString> Keys;
		// [optional] The version that currently exists according to the caller. The call will return the data for all of the keys if the version in the system is greater than this.
		OptionalUint32 IfChangedFromDataVersion;
	
        FGetCharacterDataRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			Keys(),
			IfChangedFromDataVersion()
			{}
		
		FGetCharacterDataRequest(const FGetCharacterDataRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			Keys(src.Keys),
			IfChangedFromDataVersion(src.IfChangedFromDataVersion)
			{}
			
		FGetCharacterDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum UserDataPermission
	{
		UserDataPermissionPrivate,
		UserDataPermissionPublic
	};
	
	void writeUserDataPermissionEnumJSON(UserDataPermission enumVal, JsonWriter& writer);
	UserDataPermission readUserDataPermissionFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FUserDataRecord : public FPlayFabBaseModel
    {
		
		// [optional] Data stored for the specified user data key.
		FString Value;
		// Timestamp for when this data was last updated.
		FDateTime LastUpdated;
		// [optional] Indicates whether this data can be read by all users (public) or only the user (private). This is used for GetUserData requests being made by one player about another player.
		Boxed<UserDataPermission> Permission;
	
        FUserDataRecord() :
			FPlayFabBaseModel(),
			Value(),
			LastUpdated(0),
			Permission()
			{}
		
		FUserDataRecord(const FUserDataRecord& src) :
			FPlayFabBaseModel(),
			Value(src.Value),
			LastUpdated(src.LastUpdated),
			Permission(src.Permission)
			{}
			
		FUserDataRecord(const TSharedPtr<FJsonObject>& obj) : FUserDataRecord()
        {
            readFromValue(obj);
        }
		
		~FUserDataRecord();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterDataResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] User specific data for this title.
		TMap<FString, FUserDataRecord> Data;
		// Indicates the current version of the data that has been set. This is incremented with every set call for that type of data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
		uint32 DataVersion;
	
        FGetCharacterDataResult() :
			FPlayFabBaseModel(),
			CharacterId(),
			Data(),
			DataVersion(0)
			{}
		
		FGetCharacterDataResult(const FGetCharacterDataResult& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			Data(src.Data),
			DataVersion(src.DataVersion)
			{}
			
		FGetCharacterDataResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterInventoryRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Used to limit results to only those from a specific catalog version.
		FString CatalogVersion;
	
        FGetCharacterInventoryRequest() :
			FPlayFabBaseModel(),
			CharacterId(),
			CatalogVersion()
			{}
		
		FGetCharacterInventoryRequest(const FGetCharacterInventoryRequest& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			CatalogVersion(src.CatalogVersion)
			{}
			
		FGetCharacterInventoryRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterInventoryRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterInventoryRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FVirtualCurrencyRechargeTime : public FPlayFabBaseModel
    {
		
		// Time remaining (in seconds) before the next recharge increment of the virtual currency.
		int32 SecondsToRecharge;
		// Server timestamp in UTC indicating the next time the virtual currency will be incremented.
		FDateTime RechargeTime;
		// Maximum value to which the regenerating currency will automatically increment. Note that it can exceed this value through use of the AddUserVirtualCurrency API call. However, it will not regenerate automatically until it has fallen below this value.
		int32 RechargeMax;
	
        FVirtualCurrencyRechargeTime() :
			FPlayFabBaseModel(),
			SecondsToRecharge(0),
			RechargeTime(0),
			RechargeMax(0)
			{}
		
		FVirtualCurrencyRechargeTime(const FVirtualCurrencyRechargeTime& src) :
			FPlayFabBaseModel(),
			SecondsToRecharge(src.SecondsToRecharge),
			RechargeTime(src.RechargeTime),
			RechargeMax(src.RechargeMax)
			{}
			
		FVirtualCurrencyRechargeTime(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyRechargeTime()
        {
            readFromValue(obj);
        }
		
		~FVirtualCurrencyRechargeTime();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterInventoryResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier of the character for this inventory.
		FString CharacterId;
		// [optional] Array of inventory items belonging to the character.
		TArray<FItemInstance> Inventory;
		// [optional] Array of virtual currency balance(s) belonging to the character.
		TMap<FString, int32> VirtualCurrency;
		// [optional] Array of remaining times and timestamps for virtual currencies.
		TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
	
        FGetCharacterInventoryResult() :
			FPlayFabBaseModel(),
			CharacterId(),
			Inventory(),
			VirtualCurrency(),
			VirtualCurrencyRechargeTimes()
			{}
		
		FGetCharacterInventoryResult(const FGetCharacterInventoryResult& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			Inventory(src.Inventory),
			VirtualCurrency(src.VirtualCurrency),
			VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes)
			{}
			
		FGetCharacterInventoryResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterInventoryResult()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterInventoryResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterLeaderboardRequest : public FPlayFabBaseModel
    {
		
		// [optional] Optional character type on which to filter the leaderboard entries.
		FString CharacterType;
		// Unique identifier for the title-specific statistic for the leaderboard.
		FString StatisticName;
		// First entry in the leaderboard to be retrieved.
		int32 StartPosition;
		// [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
		OptionalInt32 MaxResultsCount;
	
        FGetCharacterLeaderboardRequest() :
			FPlayFabBaseModel(),
			CharacterType(),
			StatisticName(),
			StartPosition(0),
			MaxResultsCount()
			{}
		
		FGetCharacterLeaderboardRequest(const FGetCharacterLeaderboardRequest& src) :
			FPlayFabBaseModel(),
			CharacterType(src.CharacterType),
			StatisticName(src.StatisticName),
			StartPosition(src.StartPosition),
			MaxResultsCount(src.MaxResultsCount)
			{}
			
		FGetCharacterLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterLeaderboardRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterLeaderboardRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterLeaderboardResult : public FPlayFabBaseModel
    {
		
		// [optional] Ordered list of leaderboard entries.
		TArray<FCharacterLeaderboardEntry> Leaderboard;
	
        FGetCharacterLeaderboardResult() :
			FPlayFabBaseModel(),
			Leaderboard()
			{}
		
		FGetCharacterLeaderboardResult(const FGetCharacterLeaderboardResult& src) :
			FPlayFabBaseModel(),
			Leaderboard(src.Leaderboard)
			{}
			
		FGetCharacterLeaderboardResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterLeaderboardResult()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterLeaderboardResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterStatisticsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
	
        FGetCharacterStatisticsRequest() :
			FPlayFabBaseModel(),
			CharacterId()
			{}
		
		FGetCharacterStatisticsRequest(const FGetCharacterStatisticsRequest& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId)
			{}
			
		FGetCharacterStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterStatisticsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterStatisticsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterStatisticsResult : public FPlayFabBaseModel
    {
		
		// [optional] The requested character statistics.
		TMap<FString, int32> CharacterStatistics;
	
        FGetCharacterStatisticsResult() :
			FPlayFabBaseModel(),
			CharacterStatistics()
			{}
		
		FGetCharacterStatisticsResult(const FGetCharacterStatisticsResult& src) :
			FPlayFabBaseModel(),
			CharacterStatistics(src.CharacterStatistics)
			{}
			
		FGetCharacterStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterStatisticsResult()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterStatisticsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetContentDownloadUrlRequest : public FPlayFabBaseModel
    {
		
		// Key of the content item to fetch, usually formatted as a path, e.g. images/a.png
		FString Key;
		// [optional] HTTP method to fetch item - GET or HEAD. Use HEAD when only fetching metadata. Default is GET.
		FString HttpMethod;
		// [optional] True if download through CDN. CDN provides better download bandwidth and time. However, if you want latest, non-cached version of the content, set this to false. Default is true.
		OptionalBool ThruCDN;
	
        FGetContentDownloadUrlRequest() :
			FPlayFabBaseModel(),
			Key(),
			HttpMethod(),
			ThruCDN()
			{}
		
		FGetContentDownloadUrlRequest(const FGetContentDownloadUrlRequest& src) :
			FPlayFabBaseModel(),
			Key(src.Key),
			HttpMethod(src.HttpMethod),
			ThruCDN(src.ThruCDN)
			{}
			
		FGetContentDownloadUrlRequest(const TSharedPtr<FJsonObject>& obj) : FGetContentDownloadUrlRequest()
        {
            readFromValue(obj);
        }
		
		~FGetContentDownloadUrlRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetContentDownloadUrlResult : public FPlayFabBaseModel
    {
		
		// [optional] URL for downloading content via HTTP GET or HEAD method. The URL will expire in 1 hour.
		FString URL;
	
        FGetContentDownloadUrlResult() :
			FPlayFabBaseModel(),
			URL()
			{}
		
		FGetContentDownloadUrlResult(const FGetContentDownloadUrlResult& src) :
			FPlayFabBaseModel(),
			URL(src.URL)
			{}
			
		FGetContentDownloadUrlResult(const TSharedPtr<FJsonObject>& obj) : FGetContentDownloadUrlResult()
        {
            readFromValue(obj);
        }
		
		~FGetContentDownloadUrlResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetFriendLeaderboardAroundPlayerRequest : public FPlayFabBaseModel
    {
		
		// Statistic used to rank players for this leaderboard.
		FString StatisticName;
		// [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
		OptionalInt32 MaxResultsCount;
		// [optional] PlayFab unique identifier of the user to center the leaderboard around. If null will center on the logged in user.
		FString PlayFabId;
		// [optional] Indicates whether Steam service friends should be included in the response. Default is true.
		OptionalBool IncludeSteamFriends;
		// [optional] Indicates whether Facebook friends should be included in the response. Default is true.
		OptionalBool IncludeFacebookFriends;
	
        FGetFriendLeaderboardAroundPlayerRequest() :
			FPlayFabBaseModel(),
			StatisticName(),
			MaxResultsCount(),
			PlayFabId(),
			IncludeSteamFriends(),
			IncludeFacebookFriends()
			{}
		
		FGetFriendLeaderboardAroundPlayerRequest(const FGetFriendLeaderboardAroundPlayerRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			MaxResultsCount(src.MaxResultsCount),
			PlayFabId(src.PlayFabId),
			IncludeSteamFriends(src.IncludeSteamFriends),
			IncludeFacebookFriends(src.IncludeFacebookFriends)
			{}
			
		FGetFriendLeaderboardAroundPlayerRequest(const TSharedPtr<FJsonObject>& obj) : FGetFriendLeaderboardAroundPlayerRequest()
        {
            readFromValue(obj);
        }
		
		~FGetFriendLeaderboardAroundPlayerRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPlayerLeaderboardEntry : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier of the user for this leaderboard entry.
		FString PlayFabId;
		// [optional] Title-specific display name of the user for this leaderboard entry.
		FString DisplayName;
		// Specific value of the user's statistic.
		int32 StatValue;
		// User's overall position in the leaderboard.
		int32 Position;
	
        FPlayerLeaderboardEntry() :
			FPlayFabBaseModel(),
			PlayFabId(),
			DisplayName(),
			StatValue(0),
			Position(0)
			{}
		
		FPlayerLeaderboardEntry(const FPlayerLeaderboardEntry& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			DisplayName(src.DisplayName),
			StatValue(src.StatValue),
			Position(src.Position)
			{}
			
		FPlayerLeaderboardEntry(const TSharedPtr<FJsonObject>& obj) : FPlayerLeaderboardEntry()
        {
            readFromValue(obj);
        }
		
		~FPlayerLeaderboardEntry();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetFriendLeaderboardAroundPlayerResult : public FPlayFabBaseModel
    {
		
		// [optional] Ordered listing of users and their positions in the requested leaderboard.
		TArray<FPlayerLeaderboardEntry> Leaderboard;
	
        FGetFriendLeaderboardAroundPlayerResult() :
			FPlayFabBaseModel(),
			Leaderboard()
			{}
		
		FGetFriendLeaderboardAroundPlayerResult(const FGetFriendLeaderboardAroundPlayerResult& src) :
			FPlayFabBaseModel(),
			Leaderboard(src.Leaderboard)
			{}
			
		FGetFriendLeaderboardAroundPlayerResult(const TSharedPtr<FJsonObject>& obj) : FGetFriendLeaderboardAroundPlayerResult()
        {
            readFromValue(obj);
        }
		
		~FGetFriendLeaderboardAroundPlayerResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetFriendLeaderboardRequest : public FPlayFabBaseModel
    {
		
		// Statistic used to rank friends for this leaderboard.
		FString StatisticName;
		// Position in the leaderboard to start this listing (defaults to the first entry).
		int32 StartPosition;
		// [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
		OptionalInt32 MaxResultsCount;
		// [optional] Indicates whether Steam service friends should be included in the response. Default is true.
		OptionalBool IncludeSteamFriends;
		// [optional] Indicates whether Facebook friends should be included in the response. Default is true.
		OptionalBool IncludeFacebookFriends;
	
        FGetFriendLeaderboardRequest() :
			FPlayFabBaseModel(),
			StatisticName(),
			StartPosition(0),
			MaxResultsCount(),
			IncludeSteamFriends(),
			IncludeFacebookFriends()
			{}
		
		FGetFriendLeaderboardRequest(const FGetFriendLeaderboardRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			StartPosition(src.StartPosition),
			MaxResultsCount(src.MaxResultsCount),
			IncludeSteamFriends(src.IncludeSteamFriends),
			IncludeFacebookFriends(src.IncludeFacebookFriends)
			{}
			
		FGetFriendLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetFriendLeaderboardRequest()
        {
            readFromValue(obj);
        }
		
		~FGetFriendLeaderboardRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetFriendsListRequest : public FPlayFabBaseModel
    {
		
		// [optional] Indicates whether Steam service friends should be included in the response. Default is true.
		OptionalBool IncludeSteamFriends;
		// [optional] Indicates whether Facebook friends should be included in the response. Default is true.
		OptionalBool IncludeFacebookFriends;
	
        FGetFriendsListRequest() :
			FPlayFabBaseModel(),
			IncludeSteamFriends(),
			IncludeFacebookFriends()
			{}
		
		FGetFriendsListRequest(const FGetFriendsListRequest& src) :
			FPlayFabBaseModel(),
			IncludeSteamFriends(src.IncludeSteamFriends),
			IncludeFacebookFriends(src.IncludeFacebookFriends)
			{}
			
		FGetFriendsListRequest(const TSharedPtr<FJsonObject>& obj) : FGetFriendsListRequest()
        {
            readFromValue(obj);
        }
		
		~FGetFriendsListRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetFriendsListResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of friends found.
		TArray<FFriendInfo> Friends;
	
        FGetFriendsListResult() :
			FPlayFabBaseModel(),
			Friends()
			{}
		
		FGetFriendsListResult(const FGetFriendsListResult& src) :
			FPlayFabBaseModel(),
			Friends(src.Friends)
			{}
			
		FGetFriendsListResult(const TSharedPtr<FJsonObject>& obj) : FGetFriendsListResult()
        {
            readFromValue(obj);
        }
		
		~FGetFriendsListResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardAroundCharacterRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title-specific statistic for the leaderboard.
		FString StatisticName;
		// Unique PlayFab assigned ID for a specific character on which to center the leaderboard.
		FString CharacterId;
		// [optional] Optional character type on which to filter the leaderboard entries.
		FString CharacterType;
		// [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
		OptionalInt32 MaxResultsCount;
	
        FGetLeaderboardAroundCharacterRequest() :
			FPlayFabBaseModel(),
			StatisticName(),
			CharacterId(),
			CharacterType(),
			MaxResultsCount()
			{}
		
		FGetLeaderboardAroundCharacterRequest(const FGetLeaderboardAroundCharacterRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			CharacterId(src.CharacterId),
			CharacterType(src.CharacterType),
			MaxResultsCount(src.MaxResultsCount)
			{}
			
		FGetLeaderboardAroundCharacterRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundCharacterRequest()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardAroundCharacterRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardAroundCharacterResult : public FPlayFabBaseModel
    {
		
		// [optional] Ordered list of leaderboard entries.
		TArray<FCharacterLeaderboardEntry> Leaderboard;
	
        FGetLeaderboardAroundCharacterResult() :
			FPlayFabBaseModel(),
			Leaderboard()
			{}
		
		FGetLeaderboardAroundCharacterResult(const FGetLeaderboardAroundCharacterResult& src) :
			FPlayFabBaseModel(),
			Leaderboard(src.Leaderboard)
			{}
			
		FGetLeaderboardAroundCharacterResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundCharacterResult()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardAroundCharacterResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardAroundPlayerRequest : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier of the user to center the leaderboard around. If null will center on the logged in user.
		FString PlayFabId;
		// Statistic used to rank players for this leaderboard.
		FString StatisticName;
		// [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
		OptionalInt32 MaxResultsCount;
	
        FGetLeaderboardAroundPlayerRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			StatisticName(),
			MaxResultsCount()
			{}
		
		FGetLeaderboardAroundPlayerRequest(const FGetLeaderboardAroundPlayerRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			StatisticName(src.StatisticName),
			MaxResultsCount(src.MaxResultsCount)
			{}
			
		FGetLeaderboardAroundPlayerRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundPlayerRequest()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardAroundPlayerRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardAroundPlayerResult : public FPlayFabBaseModel
    {
		
		// [optional] Ordered listing of users and their positions in the requested leaderboard.
		TArray<FPlayerLeaderboardEntry> Leaderboard;
	
        FGetLeaderboardAroundPlayerResult() :
			FPlayFabBaseModel(),
			Leaderboard()
			{}
		
		FGetLeaderboardAroundPlayerResult(const FGetLeaderboardAroundPlayerResult& src) :
			FPlayFabBaseModel(),
			Leaderboard(src.Leaderboard)
			{}
			
		FGetLeaderboardAroundPlayerResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundPlayerResult()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardAroundPlayerResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardForUsersCharactersRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title-specific statistic for the leaderboard.
		FString StatisticName;
		// Maximum number of entries to retrieve.
		int32 MaxResultsCount;
	
        FGetLeaderboardForUsersCharactersRequest() :
			FPlayFabBaseModel(),
			StatisticName(),
			MaxResultsCount(0)
			{}
		
		FGetLeaderboardForUsersCharactersRequest(const FGetLeaderboardForUsersCharactersRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			MaxResultsCount(src.MaxResultsCount)
			{}
			
		FGetLeaderboardForUsersCharactersRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardForUsersCharactersRequest()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardForUsersCharactersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardForUsersCharactersResult : public FPlayFabBaseModel
    {
		
		// [optional] Ordered list of leaderboard entries.
		TArray<FCharacterLeaderboardEntry> Leaderboard;
	
        FGetLeaderboardForUsersCharactersResult() :
			FPlayFabBaseModel(),
			Leaderboard()
			{}
		
		FGetLeaderboardForUsersCharactersResult(const FGetLeaderboardForUsersCharactersResult& src) :
			FPlayFabBaseModel(),
			Leaderboard(src.Leaderboard)
			{}
			
		FGetLeaderboardForUsersCharactersResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardForUsersCharactersResult()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardForUsersCharactersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardRequest : public FPlayFabBaseModel
    {
		
		// Statistic used to rank players for this leaderboard.
		FString StatisticName;
		// Position in the leaderboard to start this listing (defaults to the first entry).
		int32 StartPosition;
		// [optional] Maximum number of entries to retrieve. Default 10, maximum 100.
		OptionalInt32 MaxResultsCount;
	
        FGetLeaderboardRequest() :
			FPlayFabBaseModel(),
			StatisticName(),
			StartPosition(0),
			MaxResultsCount()
			{}
		
		FGetLeaderboardRequest(const FGetLeaderboardRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			StartPosition(src.StartPosition),
			MaxResultsCount(src.MaxResultsCount)
			{}
			
		FGetLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardRequest()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardResult : public FPlayFabBaseModel
    {
		
		// [optional] Ordered listing of users and their positions in the requested leaderboard.
		TArray<FPlayerLeaderboardEntry> Leaderboard;
	
        FGetLeaderboardResult() :
			FPlayFabBaseModel(),
			Leaderboard()
			{}
		
		FGetLeaderboardResult(const FGetLeaderboardResult& src) :
			FPlayFabBaseModel(),
			Leaderboard(src.Leaderboard)
			{}
			
		FGetLeaderboardResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardResult()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPhotonAuthenticationTokenRequest : public FPlayFabBaseModel
    {
		
		// The Photon applicationId for the game you wish to log into.
		FString PhotonApplicationId;
	
        FGetPhotonAuthenticationTokenRequest() :
			FPlayFabBaseModel(),
			PhotonApplicationId()
			{}
		
		FGetPhotonAuthenticationTokenRequest(const FGetPhotonAuthenticationTokenRequest& src) :
			FPlayFabBaseModel(),
			PhotonApplicationId(src.PhotonApplicationId)
			{}
			
		FGetPhotonAuthenticationTokenRequest(const TSharedPtr<FJsonObject>& obj) : FGetPhotonAuthenticationTokenRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPhotonAuthenticationTokenRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPhotonAuthenticationTokenResult : public FPlayFabBaseModel
    {
		
		// [optional] The Photon authentication token for this game-session.
		FString PhotonCustomAuthenticationToken;
	
        FGetPhotonAuthenticationTokenResult() :
			FPlayFabBaseModel(),
			PhotonCustomAuthenticationToken()
			{}
		
		FGetPhotonAuthenticationTokenResult(const FGetPhotonAuthenticationTokenResult& src) :
			FPlayFabBaseModel(),
			PhotonCustomAuthenticationToken(src.PhotonCustomAuthenticationToken)
			{}
			
		FGetPhotonAuthenticationTokenResult(const TSharedPtr<FJsonObject>& obj) : FGetPhotonAuthenticationTokenResult()
        {
            readFromValue(obj);
        }
		
		~FGetPhotonAuthenticationTokenResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerCombinedInfoRequestParams : public FPlayFabBaseModel
    {
		
		// Whether to get the player's account Info. Defaults to false
		bool GetUserAccountInfo;
		// Whether to get the player's inventory. Defaults to false
		bool GetUserInventory;
		// Whether to get the player's virtual currency balances. Defaults to false
		bool GetUserVirtualCurrency;
		// Whether to get the player's custom data. Defaults to false
		bool GetUserData;
		// [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if UserDataKeys is false
		TArray<FString> UserDataKeys;
		// Whether to get the player's read only data. Defaults to false
		bool GetUserReadOnlyData;
		// [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if GetUserReadOnlyData is false
		TArray<FString> UserReadOnlyDataKeys;
		// Whether to get character inventories. Defaults to false.
		bool GetCharacterInventories;
		// Whether to get the list of characters. Defaults to false.
		bool GetCharacterList;
		// Whether to get title data. Defaults to false.
		bool GetTitleData;
		// [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if GetTitleData is false
		TArray<FString> TitleDataKeys;
		// Whether to get player statistics. Defaults to false.
		bool GetPlayerStatistics;
		// [optional] Specific statistics to retrieve. Leave null to get all keys. Has no effect if GetPlayerStatistics is false
		TArray<FString> PlayerStatisticNames;
	
        FGetPlayerCombinedInfoRequestParams() :
			FPlayFabBaseModel(),
			GetUserAccountInfo(false),
			GetUserInventory(false),
			GetUserVirtualCurrency(false),
			GetUserData(false),
			UserDataKeys(),
			GetUserReadOnlyData(false),
			UserReadOnlyDataKeys(),
			GetCharacterInventories(false),
			GetCharacterList(false),
			GetTitleData(false),
			TitleDataKeys(),
			GetPlayerStatistics(false),
			PlayerStatisticNames()
			{}
		
		FGetPlayerCombinedInfoRequestParams(const FGetPlayerCombinedInfoRequestParams& src) :
			FPlayFabBaseModel(),
			GetUserAccountInfo(src.GetUserAccountInfo),
			GetUserInventory(src.GetUserInventory),
			GetUserVirtualCurrency(src.GetUserVirtualCurrency),
			GetUserData(src.GetUserData),
			UserDataKeys(src.UserDataKeys),
			GetUserReadOnlyData(src.GetUserReadOnlyData),
			UserReadOnlyDataKeys(src.UserReadOnlyDataKeys),
			GetCharacterInventories(src.GetCharacterInventories),
			GetCharacterList(src.GetCharacterList),
			GetTitleData(src.GetTitleData),
			TitleDataKeys(src.TitleDataKeys),
			GetPlayerStatistics(src.GetPlayerStatistics),
			PlayerStatisticNames(src.PlayerStatisticNames)
			{}
			
		FGetPlayerCombinedInfoRequestParams(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoRequestParams()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerCombinedInfoRequestParams();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerCombinedInfoRequest : public FPlayFabBaseModel
    {
		
		// [optional] PlayFabId of the user whose data will be returned. If not filled included, we return the data for the calling player. 
		FString PlayFabId;
		// Flags for which pieces of info to return for the user.
		FGetPlayerCombinedInfoRequestParams InfoRequestParameters;
	
        FGetPlayerCombinedInfoRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			InfoRequestParameters()
			{}
		
		FGetPlayerCombinedInfoRequest(const FGetPlayerCombinedInfoRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			InfoRequestParameters(src.InfoRequestParameters)
			{}
			
		FGetPlayerCombinedInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerCombinedInfoRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStatisticValue : public FPlayFabBaseModel
    {
		
		// [optional] unique name of the statistic
		FString StatisticName;
		// statistic value for the player
		int32 Value;
		// for updates to an existing statistic value for a player, the version of the statistic when it was loaded
		uint32 Version;
	
        FStatisticValue() :
			FPlayFabBaseModel(),
			StatisticName(),
			Value(0),
			Version(0)
			{}
		
		FStatisticValue(const FStatisticValue& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			Value(src.Value),
			Version(src.Version)
			{}
			
		FStatisticValue(const TSharedPtr<FJsonObject>& obj) : FStatisticValue()
        {
            readFromValue(obj);
        }
		
		~FStatisticValue();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerCombinedInfoResultPayload : public FPlayFabBaseModel
    {
		
		// [optional] Account information for the user. This is always retrieved.
		TSharedPtr<FUserAccountInfo> AccountInfo;
		// [optional] Array of inventory items in the user's current inventory.
		TArray<FItemInstance> UserInventory;
		// [optional] Dictionary of virtual currency balance(s) belonging to the user.
		TMap<FString, int32> UserVirtualCurrency;
		// [optional] Dictionary of remaining times and timestamps for virtual currencies.
		TMap<FString, FVirtualCurrencyRechargeTime> UserVirtualCurrencyRechargeTimes;
		// [optional] User specific custom data.
		TMap<FString, FUserDataRecord> UserData;
		// The version of the UserData that was returned.
		uint32 UserDataVersion;
		// [optional] User specific read-only data.
		TMap<FString, FUserDataRecord> UserReadOnlyData;
		// The version of the Read-Only UserData that was returned.
		uint32 UserReadOnlyDataVersion;
		// [optional] List of characters for the user.
		TArray<FCharacterResult> CharacterList;
		// [optional] Inventories for each character for the user.
		TArray<FCharacterInventory> CharacterInventories;
		// [optional] Title data for this title.
		TMap<FString, FString> TitleData;
		// [optional] List of statistics for this player.
		TArray<FStatisticValue> PlayerStatistics;
	
        FGetPlayerCombinedInfoResultPayload() :
			FPlayFabBaseModel(),
			AccountInfo(nullptr),
			UserInventory(),
			UserVirtualCurrency(),
			UserVirtualCurrencyRechargeTimes(),
			UserData(),
			UserDataVersion(0),
			UserReadOnlyData(),
			UserReadOnlyDataVersion(0),
			CharacterList(),
			CharacterInventories(),
			TitleData(),
			PlayerStatistics()
			{}
		
		FGetPlayerCombinedInfoResultPayload(const FGetPlayerCombinedInfoResultPayload& src) :
			FPlayFabBaseModel(),
			AccountInfo(src.AccountInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.AccountInfo)) : nullptr),
			UserInventory(src.UserInventory),
			UserVirtualCurrency(src.UserVirtualCurrency),
			UserVirtualCurrencyRechargeTimes(src.UserVirtualCurrencyRechargeTimes),
			UserData(src.UserData),
			UserDataVersion(src.UserDataVersion),
			UserReadOnlyData(src.UserReadOnlyData),
			UserReadOnlyDataVersion(src.UserReadOnlyDataVersion),
			CharacterList(src.CharacterList),
			CharacterInventories(src.CharacterInventories),
			TitleData(src.TitleData),
			PlayerStatistics(src.PlayerStatistics)
			{}
			
		FGetPlayerCombinedInfoResultPayload(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoResultPayload()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerCombinedInfoResultPayload();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerCombinedInfoResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Results for requested info.
		TSharedPtr<FGetPlayerCombinedInfoResultPayload> InfoResultPayload;
	
        FGetPlayerCombinedInfoResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			InfoResultPayload(nullptr)
			{}
		
		FGetPlayerCombinedInfoResult(const FGetPlayerCombinedInfoResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			InfoResultPayload(src.InfoResultPayload.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoResultPayload(*src.InfoResultPayload)) : nullptr)
			{}
			
		FGetPlayerCombinedInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerCombinedInfoResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerSegmentsRequest : public FPlayFabBaseModel
    {
		
	
        FGetPlayerSegmentsRequest() :
			FPlayFabBaseModel()
			{}
		
		FGetPlayerSegmentsRequest(const FGetPlayerSegmentsRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FGetPlayerSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSegmentsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerSegmentsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetSegmentResult : public FPlayFabBaseModel
    {
		
		// Unique identifier for this segment.
		FString Id;
		// [optional] Segment name.
		FString Name;
		// [optional] Identifier of the segments AB Test, if it is attached to one.
		FString ABTestParent;
	
        FGetSegmentResult() :
			FPlayFabBaseModel(),
			Id(),
			Name(),
			ABTestParent()
			{}
		
		FGetSegmentResult(const FGetSegmentResult& src) :
			FPlayFabBaseModel(),
			Id(src.Id),
			Name(src.Name),
			ABTestParent(src.ABTestParent)
			{}
			
		FGetSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetSegmentResult()
        {
            readFromValue(obj);
        }
		
		~FGetSegmentResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerSegmentsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of segments the requested player currently belongs to.
		TArray<FGetSegmentResult> Segments;
	
        FGetPlayerSegmentsResult() :
			FPlayFabBaseModel(),
			Segments()
			{}
		
		FGetPlayerSegmentsResult(const FGetPlayerSegmentsResult& src) :
			FPlayFabBaseModel(),
			Segments(src.Segments)
			{}
			
		FGetPlayerSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSegmentsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerSegmentsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStatisticNameVersion : public FPlayFabBaseModel
    {
		
		// unique name of the statistic
		FString StatisticName;
		// the version of the statistic to be returned
		uint32 Version;
	
        FStatisticNameVersion() :
			FPlayFabBaseModel(),
			StatisticName(),
			Version(0)
			{}
		
		FStatisticNameVersion(const FStatisticNameVersion& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			Version(src.Version)
			{}
			
		FStatisticNameVersion(const TSharedPtr<FJsonObject>& obj) : FStatisticNameVersion()
        {
            readFromValue(obj);
        }
		
		~FStatisticNameVersion();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticsRequest : public FPlayFabBaseModel
    {
		
		// [optional] statistics to return (current version will be returned for each)
		TArray<FString> StatisticNames;
		// [optional] statistics to return, if StatisticNames is not set (only statistics which have a version matching that provided will be returned)
		TArray<FStatisticNameVersion> StatisticNameVersions;
	
        FGetPlayerStatisticsRequest() :
			FPlayFabBaseModel(),
			StatisticNames(),
			StatisticNameVersions()
			{}
		
		FGetPlayerStatisticsRequest(const FGetPlayerStatisticsRequest& src) :
			FPlayFabBaseModel(),
			StatisticNames(src.StatisticNames),
			StatisticNameVersions(src.StatisticNameVersions)
			{}
			
		FGetPlayerStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticsResult : public FPlayFabBaseModel
    {
		
		// [optional] User statistics for the requested user.
		TArray<FStatisticValue> Statistics;
	
        FGetPlayerStatisticsResult() :
			FPlayFabBaseModel(),
			Statistics()
			{}
		
		FGetPlayerStatisticsResult(const FGetPlayerStatisticsResult& src) :
			FPlayFabBaseModel(),
			Statistics(src.Statistics)
			{}
			
		FGetPlayerStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticVersionsRequest : public FPlayFabBaseModel
    {
		
		// [optional] unique name of the statistic
		FString StatisticName;
	
        FGetPlayerStatisticVersionsRequest() :
			FPlayFabBaseModel(),
			StatisticName()
			{}
		
		FGetPlayerStatisticVersionsRequest(const FGetPlayerStatisticVersionsRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName)
			{}
			
		FGetPlayerStatisticVersionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticVersionsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPlayerStatisticVersion : public FPlayFabBaseModel
    {
		
		// [optional] name of the statistic when the version became active
		FString StatisticName;
		// version of the statistic
		uint32 Version;
		// [optional] time at which the statistic version was scheduled to become active, based on the configured ResetInterval
		OptionalTime ScheduledActivationTime;
		// time when the statistic version became active
		FDateTime ActivationTime;
		// [optional] time at which the statistic version was scheduled to become inactive, based on the configured ResetInterval
		OptionalTime ScheduledDeactivationTime;
		// [optional] time when the statistic version became inactive due to statistic version incrementing
		OptionalTime DeactivationTime;
	
        FPlayerStatisticVersion() :
			FPlayFabBaseModel(),
			StatisticName(),
			Version(0),
			ScheduledActivationTime(),
			ActivationTime(0),
			ScheduledDeactivationTime(),
			DeactivationTime()
			{}
		
		FPlayerStatisticVersion(const FPlayerStatisticVersion& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			Version(src.Version),
			ScheduledActivationTime(src.ScheduledActivationTime),
			ActivationTime(src.ActivationTime),
			ScheduledDeactivationTime(src.ScheduledDeactivationTime),
			DeactivationTime(src.DeactivationTime)
			{}
			
		FPlayerStatisticVersion(const TSharedPtr<FJsonObject>& obj) : FPlayerStatisticVersion()
        {
            readFromValue(obj);
        }
		
		~FPlayerStatisticVersion();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticVersionsResult : public FPlayFabBaseModel
    {
		
		// [optional] version change history of the statistic
		TArray<FPlayerStatisticVersion> StatisticVersions;
	
        FGetPlayerStatisticVersionsResult() :
			FPlayFabBaseModel(),
			StatisticVersions()
			{}
		
		FGetPlayerStatisticVersionsResult(const FGetPlayerStatisticVersionsResult& src) :
			FPlayFabBaseModel(),
			StatisticVersions(src.StatisticVersions)
			{}
			
		FGetPlayerStatisticVersionsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticVersionsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerTagsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Optional namespace to filter results by
		FString Namespace;
	
        FGetPlayerTagsRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Namespace()
			{}
		
		FGetPlayerTagsRequest(const FGetPlayerTagsRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Namespace(src.Namespace)
			{}
			
		FGetPlayerTagsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerTagsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerTagsResult : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Canonical tags (including namespace and tag's name) for the requested user
		TArray<FString> Tags;
	
        FGetPlayerTagsResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Tags()
			{}
		
		FGetPlayerTagsResult(const FGetPlayerTagsResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Tags(src.Tags)
			{}
			
		FGetPlayerTagsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerTagsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerTradesRequest : public FPlayFabBaseModel
    {
		
		// [optional] Returns only trades with the given status. If null, returns all trades.
		Boxed<TradeStatus> StatusFilter;
	
        FGetPlayerTradesRequest() :
			FPlayFabBaseModel(),
			StatusFilter()
			{}
		
		FGetPlayerTradesRequest(const FGetPlayerTradesRequest& src) :
			FPlayFabBaseModel(),
			StatusFilter(src.StatusFilter)
			{}
			
		FGetPlayerTradesRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTradesRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerTradesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerTradesResponse : public FPlayFabBaseModel
    {
		
		// [optional] The trades for this player which are currently available to be accepted.
		TArray<FTradeInfo> OpenedTrades;
		// [optional] History of trades which this player has accepted.
		TArray<FTradeInfo> AcceptedTrades;
	
        FGetPlayerTradesResponse() :
			FPlayFabBaseModel(),
			OpenedTrades(),
			AcceptedTrades()
			{}
		
		FGetPlayerTradesResponse(const FGetPlayerTradesResponse& src) :
			FPlayFabBaseModel(),
			OpenedTrades(src.OpenedTrades),
			AcceptedTrades(src.AcceptedTrades)
			{}
			
		FGetPlayerTradesResponse(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTradesResponse()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerTradesResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromFacebookIDsRequest : public FPlayFabBaseModel
    {
		
		// Array of unique Facebook identifiers for which the title needs to get PlayFab identifiers.
		TArray<FString> FacebookIDs;
	
        FGetPlayFabIDsFromFacebookIDsRequest() :
			FPlayFabBaseModel(),
			FacebookIDs()
			{}
		
		FGetPlayFabIDsFromFacebookIDsRequest(const FGetPlayFabIDsFromFacebookIDsRequest& src) :
			FPlayFabBaseModel(),
			FacebookIDs(src.FacebookIDs)
			{}
			
		FGetPlayFabIDsFromFacebookIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromFacebookIDsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromFacebookIDsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromFacebookIDsResult : public FPlayFabBaseModel
    {
		
		// [optional] Mapping of Facebook identifiers to PlayFab identifiers.
		TArray<FFacebookPlayFabIdPair> Data;
	
        FGetPlayFabIDsFromFacebookIDsResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPlayFabIDsFromFacebookIDsResult(const FGetPlayFabIDsFromFacebookIDsResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPlayFabIDsFromFacebookIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromFacebookIDsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromFacebookIDsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromGameCenterIDsRequest : public FPlayFabBaseModel
    {
		
		// Array of unique Game Center identifiers (the Player Identifier) for which the title needs to get PlayFab identifiers.
		TArray<FString> GameCenterIDs;
	
        FGetPlayFabIDsFromGameCenterIDsRequest() :
			FPlayFabBaseModel(),
			GameCenterIDs()
			{}
		
		FGetPlayFabIDsFromGameCenterIDsRequest(const FGetPlayFabIDsFromGameCenterIDsRequest& src) :
			FPlayFabBaseModel(),
			GameCenterIDs(src.GameCenterIDs)
			{}
			
		FGetPlayFabIDsFromGameCenterIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGameCenterIDsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromGameCenterIDsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromGameCenterIDsResult : public FPlayFabBaseModel
    {
		
		// [optional] Mapping of Game Center identifiers to PlayFab identifiers.
		TArray<FGameCenterPlayFabIdPair> Data;
	
        FGetPlayFabIDsFromGameCenterIDsResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPlayFabIDsFromGameCenterIDsResult(const FGetPlayFabIDsFromGameCenterIDsResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPlayFabIDsFromGameCenterIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGameCenterIDsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromGameCenterIDsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromGenericIDsRequest : public FPlayFabBaseModel
    {
		
		// Array of unique generic service identifiers for which the title needs to get PlayFab identifiers. Currently limited to a maximum of 10 in a single request.
		TArray<FGenericServiceId> GenericIDs;
	
        FGetPlayFabIDsFromGenericIDsRequest() :
			FPlayFabBaseModel(),
			GenericIDs()
			{}
		
		FGetPlayFabIDsFromGenericIDsRequest(const FGetPlayFabIDsFromGenericIDsRequest& src) :
			FPlayFabBaseModel(),
			GenericIDs(src.GenericIDs)
			{}
			
		FGetPlayFabIDsFromGenericIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGenericIDsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromGenericIDsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromGenericIDsResult : public FPlayFabBaseModel
    {
		
		// [optional] Mapping of generic service identifiers to PlayFab identifiers.
		TArray<FGenericPlayFabIdPair> Data;
	
        FGetPlayFabIDsFromGenericIDsResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPlayFabIDsFromGenericIDsResult(const FGetPlayFabIDsFromGenericIDsResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPlayFabIDsFromGenericIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGenericIDsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromGenericIDsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromGoogleIDsRequest : public FPlayFabBaseModel
    {
		
		// Array of unique Google identifiers (Google+ user IDs) for which the title needs to get PlayFab identifiers.
		TArray<FString> GoogleIDs;
	
        FGetPlayFabIDsFromGoogleIDsRequest() :
			FPlayFabBaseModel(),
			GoogleIDs()
			{}
		
		FGetPlayFabIDsFromGoogleIDsRequest(const FGetPlayFabIDsFromGoogleIDsRequest& src) :
			FPlayFabBaseModel(),
			GoogleIDs(src.GoogleIDs)
			{}
			
		FGetPlayFabIDsFromGoogleIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGoogleIDsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromGoogleIDsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGooglePlayFabIdPair : public FPlayFabBaseModel
    {
		
		// [optional] Unique Google identifier for a user.
		FString GoogleId;
		// [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Google identifier.
		FString PlayFabId;
	
        FGooglePlayFabIdPair() :
			FPlayFabBaseModel(),
			GoogleId(),
			PlayFabId()
			{}
		
		FGooglePlayFabIdPair(const FGooglePlayFabIdPair& src) :
			FPlayFabBaseModel(),
			GoogleId(src.GoogleId),
			PlayFabId(src.PlayFabId)
			{}
			
		FGooglePlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FGooglePlayFabIdPair()
        {
            readFromValue(obj);
        }
		
		~FGooglePlayFabIdPair();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromGoogleIDsResult : public FPlayFabBaseModel
    {
		
		// [optional] Mapping of Google identifiers to PlayFab identifiers.
		TArray<FGooglePlayFabIdPair> Data;
	
        FGetPlayFabIDsFromGoogleIDsResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPlayFabIDsFromGoogleIDsResult(const FGetPlayFabIDsFromGoogleIDsResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPlayFabIDsFromGoogleIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromGoogleIDsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromGoogleIDsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromKongregateIDsRequest : public FPlayFabBaseModel
    {
		
		// Array of unique Kongregate identifiers (Kongregate's user_id) for which the title needs to get PlayFab identifiers.
		TArray<FString> KongregateIDs;
	
        FGetPlayFabIDsFromKongregateIDsRequest() :
			FPlayFabBaseModel(),
			KongregateIDs()
			{}
		
		FGetPlayFabIDsFromKongregateIDsRequest(const FGetPlayFabIDsFromKongregateIDsRequest& src) :
			FPlayFabBaseModel(),
			KongregateIDs(src.KongregateIDs)
			{}
			
		FGetPlayFabIDsFromKongregateIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromKongregateIDsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromKongregateIDsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FKongregatePlayFabIdPair : public FPlayFabBaseModel
    {
		
		// [optional] Unique Kongregate identifier for a user.
		FString KongregateId;
		// [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Kongregate identifier.
		FString PlayFabId;
	
        FKongregatePlayFabIdPair() :
			FPlayFabBaseModel(),
			KongregateId(),
			PlayFabId()
			{}
		
		FKongregatePlayFabIdPair(const FKongregatePlayFabIdPair& src) :
			FPlayFabBaseModel(),
			KongregateId(src.KongregateId),
			PlayFabId(src.PlayFabId)
			{}
			
		FKongregatePlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FKongregatePlayFabIdPair()
        {
            readFromValue(obj);
        }
		
		~FKongregatePlayFabIdPair();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromKongregateIDsResult : public FPlayFabBaseModel
    {
		
		// [optional] Mapping of Kongregate identifiers to PlayFab identifiers.
		TArray<FKongregatePlayFabIdPair> Data;
	
        FGetPlayFabIDsFromKongregateIDsResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPlayFabIDsFromKongregateIDsResult(const FGetPlayFabIDsFromKongregateIDsResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPlayFabIDsFromKongregateIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromKongregateIDsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromKongregateIDsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromSteamIDsRequest : public FPlayFabBaseModel
    {
		
		// [optional] Array of unique Steam identifiers (Steam profile IDs) for which the title needs to get PlayFab identifiers.
		TArray<FString> SteamStringIDs;
	
        FGetPlayFabIDsFromSteamIDsRequest() :
			FPlayFabBaseModel(),
			SteamStringIDs()
			{}
		
		FGetPlayFabIDsFromSteamIDsRequest(const FGetPlayFabIDsFromSteamIDsRequest& src) :
			FPlayFabBaseModel(),
			SteamStringIDs(src.SteamStringIDs)
			{}
			
		FGetPlayFabIDsFromSteamIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromSteamIDsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromSteamIDsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSteamPlayFabIdPair : public FPlayFabBaseModel
    {
		
		// [optional] Unique Steam identifier for a user.
		FString SteamStringId;
		// [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Steam identifier.
		FString PlayFabId;
	
        FSteamPlayFabIdPair() :
			FPlayFabBaseModel(),
			SteamStringId(),
			PlayFabId()
			{}
		
		FSteamPlayFabIdPair(const FSteamPlayFabIdPair& src) :
			FPlayFabBaseModel(),
			SteamStringId(src.SteamStringId),
			PlayFabId(src.PlayFabId)
			{}
			
		FSteamPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FSteamPlayFabIdPair()
        {
            readFromValue(obj);
        }
		
		~FSteamPlayFabIdPair();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromSteamIDsResult : public FPlayFabBaseModel
    {
		
		// [optional] Mapping of Steam identifiers to PlayFab identifiers.
		TArray<FSteamPlayFabIdPair> Data;
	
        FGetPlayFabIDsFromSteamIDsResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPlayFabIDsFromSteamIDsResult(const FGetPlayFabIDsFromSteamIDsResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPlayFabIDsFromSteamIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromSteamIDsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromSteamIDsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromTwitchIDsRequest : public FPlayFabBaseModel
    {
		
		// Array of unique Twitch identifiers (Twitch's _id) for which the title needs to get PlayFab identifiers.
		TArray<FString> TwitchIds;
	
        FGetPlayFabIDsFromTwitchIDsRequest() :
			FPlayFabBaseModel(),
			TwitchIds()
			{}
		
		FGetPlayFabIDsFromTwitchIDsRequest(const FGetPlayFabIDsFromTwitchIDsRequest& src) :
			FPlayFabBaseModel(),
			TwitchIds(src.TwitchIds)
			{}
			
		FGetPlayFabIDsFromTwitchIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromTwitchIDsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromTwitchIDsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FTwitchPlayFabIdPair : public FPlayFabBaseModel
    {
		
		// [optional] Unique Twitch identifier for a user.
		FString TwitchId;
		// [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Twitch identifier.
		FString PlayFabId;
	
        FTwitchPlayFabIdPair() :
			FPlayFabBaseModel(),
			TwitchId(),
			PlayFabId()
			{}
		
		FTwitchPlayFabIdPair(const FTwitchPlayFabIdPair& src) :
			FPlayFabBaseModel(),
			TwitchId(src.TwitchId),
			PlayFabId(src.PlayFabId)
			{}
			
		FTwitchPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FTwitchPlayFabIdPair()
        {
            readFromValue(obj);
        }
		
		~FTwitchPlayFabIdPair();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromTwitchIDsResult : public FPlayFabBaseModel
    {
		
		// [optional] Mapping of Twitch identifiers to PlayFab identifiers.
		TArray<FTwitchPlayFabIdPair> Data;
	
        FGetPlayFabIDsFromTwitchIDsResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPlayFabIDsFromTwitchIDsResult(const FGetPlayFabIDsFromTwitchIDsResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPlayFabIDsFromTwitchIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromTwitchIDsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromTwitchIDsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPublisherDataRequest : public FPlayFabBaseModel
    {
		
		//  array of keys to get back data from the Publisher data blob, set by the admin tools
		TArray<FString> Keys;
	
        FGetPublisherDataRequest() :
			FPlayFabBaseModel(),
			Keys()
			{}
		
		FGetPublisherDataRequest(const FGetPublisherDataRequest& src) :
			FPlayFabBaseModel(),
			Keys(src.Keys)
			{}
			
		FGetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPublisherDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPublisherDataResult : public FPlayFabBaseModel
    {
		
		// [optional] a dictionary object of key / value pairs
		TMap<FString, FString> Data;
	
        FGetPublisherDataResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPublisherDataResult(const FGetPublisherDataResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetPublisherDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPurchaseRequest : public FPlayFabBaseModel
    {
		
		// Purchase order identifier.
		FString OrderId;
	
        FGetPurchaseRequest() :
			FPlayFabBaseModel(),
			OrderId()
			{}
		
		FGetPurchaseRequest(const FGetPurchaseRequest& src) :
			FPlayFabBaseModel(),
			OrderId(src.OrderId)
			{}
			
		FGetPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FGetPurchaseRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPurchaseRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPurchaseResult : public FPlayFabBaseModel
    {
		
		// [optional] Purchase order identifier.
		FString OrderId;
		// [optional] Payment provider used for transaction (If not VC)
		FString PaymentProvider;
		// [optional] Provider transaction ID (If not VC)
		FString TransactionId;
		// [optional] PlayFab transaction status
		FString TransactionStatus;
		// Date and time of the purchase.
		FDateTime PurchaseDate;
		// [optional] Array of items purchased.
		TArray<FItemInstance> Items;
	
        FGetPurchaseResult() :
			FPlayFabBaseModel(),
			OrderId(),
			PaymentProvider(),
			TransactionId(),
			TransactionStatus(),
			PurchaseDate(0),
			Items()
			{}
		
		FGetPurchaseResult(const FGetPurchaseResult& src) :
			FPlayFabBaseModel(),
			OrderId(src.OrderId),
			PaymentProvider(src.PaymentProvider),
			TransactionId(src.TransactionId),
			TransactionStatus(src.TransactionStatus),
			PurchaseDate(src.PurchaseDate),
			Items(src.Items)
			{}
			
		FGetPurchaseResult(const TSharedPtr<FJsonObject>& obj) : FGetPurchaseResult()
        {
            readFromValue(obj);
        }
		
		~FGetPurchaseResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetSharedGroupDataRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the shared group.
		FString SharedGroupId;
		// [optional] Specific keys to retrieve from the shared group (if not specified, all keys will be returned, while an empty array indicates that no keys should be returned).
		TArray<FString> Keys;
		// [optional] If true, return the list of all members of the shared group.
		OptionalBool GetMembers;
	
        FGetSharedGroupDataRequest() :
			FPlayFabBaseModel(),
			SharedGroupId(),
			Keys(),
			GetMembers()
			{}
		
		FGetSharedGroupDataRequest(const FGetSharedGroupDataRequest& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId),
			Keys(src.Keys),
			GetMembers(src.GetMembers)
			{}
			
		FGetSharedGroupDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetSharedGroupDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetSharedGroupDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSharedGroupDataRecord : public FPlayFabBaseModel
    {
		
		// [optional] Data stored for the specified group data key.
		FString Value;
		// [optional] Unique PlayFab identifier of the user to last update this value.
		FString LastUpdatedBy;
		// Timestamp for when this data was last updated.
		FDateTime LastUpdated;
		// [optional] Indicates whether this data can be read by all users (public) or only members of the group (private).
		Boxed<UserDataPermission> Permission;
	
        FSharedGroupDataRecord() :
			FPlayFabBaseModel(),
			Value(),
			LastUpdatedBy(),
			LastUpdated(0),
			Permission()
			{}
		
		FSharedGroupDataRecord(const FSharedGroupDataRecord& src) :
			FPlayFabBaseModel(),
			Value(src.Value),
			LastUpdatedBy(src.LastUpdatedBy),
			LastUpdated(src.LastUpdated),
			Permission(src.Permission)
			{}
			
		FSharedGroupDataRecord(const TSharedPtr<FJsonObject>& obj) : FSharedGroupDataRecord()
        {
            readFromValue(obj);
        }
		
		~FSharedGroupDataRecord();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetSharedGroupDataResult : public FPlayFabBaseModel
    {
		
		// [optional] Data for the requested keys.
		TMap<FString, FSharedGroupDataRecord> Data;
		// [optional] List of PlayFabId identifiers for the members of this group, if requested.
		TArray<FString> Members;
	
        FGetSharedGroupDataResult() :
			FPlayFabBaseModel(),
			Data(),
			Members()
			{}
		
		FGetSharedGroupDataResult(const FGetSharedGroupDataResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data),
			Members(src.Members)
			{}
			
		FGetSharedGroupDataResult(const TSharedPtr<FJsonObject>& obj) : FGetSharedGroupDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetSharedGroupDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetStoreItemsRequest : public FPlayFabBaseModel
    {
		
		// [optional] catalog version to store items from. Use default catalog version if null
		FString CatalogVersion;
		// Unqiue identifier for the store which is being requested.
		FString StoreId;
	
        FGetStoreItemsRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			StoreId()
			{}
		
		FGetStoreItemsRequest(const FGetStoreItemsRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			StoreId(src.StoreId)
			{}
			
		FGetStoreItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetStoreItemsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetStoreItemsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStoreItem : public FPlayFabBaseModel
    {
		
		// Unique identifier of the item as it exists in the catalog - note that this must exactly match the ItemId from the catalog
		FString ItemId;
		// [optional] Override prices for this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
		TMap<FString, uint32> VirtualCurrencyPrices;
		// [optional] Override prices for this item for specific currencies
		TMap<FString, uint32> RealCurrencyPrices;
		// [optional] Store specific custom data. The data only exists as part of this store; it is not transferred to item instances
		FMultitypeVar CustomData;
		// [optional] Intended display position for this item. Note that 0 is the first position
		OptionalUint32 DisplayPosition;
	
        FStoreItem() :
			FPlayFabBaseModel(),
			ItemId(),
			VirtualCurrencyPrices(),
			RealCurrencyPrices(),
			CustomData(),
			DisplayPosition()
			{}
		
		FStoreItem(const FStoreItem& src) :
			FPlayFabBaseModel(),
			ItemId(src.ItemId),
			VirtualCurrencyPrices(src.VirtualCurrencyPrices),
			RealCurrencyPrices(src.RealCurrencyPrices),
			CustomData(src.CustomData),
			DisplayPosition(src.DisplayPosition)
			{}
			
		FStoreItem(const TSharedPtr<FJsonObject>& obj) : FStoreItem()
        {
            readFromValue(obj);
        }
		
		~FStoreItem();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum SourceType
	{
		SourceTypeAdmin,
		SourceTypeBackEnd,
		SourceTypeGameClient,
		SourceTypeGameServer,
		SourceTypePartner
	};
	
	void writeSourceTypeEnumJSON(SourceType enumVal, JsonWriter& writer);
	SourceType readSourceTypeFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FStoreMarketingModel : public FPlayFabBaseModel
    {
		
		// [optional] Display name of a store as it will appear to users.
		FString DisplayName;
		// [optional] Tagline for a store.
		FString Description;
		// [optional] Custom data about a store.
		FMultitypeVar Metadata;
	
        FStoreMarketingModel() :
			FPlayFabBaseModel(),
			DisplayName(),
			Description(),
			Metadata()
			{}
		
		FStoreMarketingModel(const FStoreMarketingModel& src) :
			FPlayFabBaseModel(),
			DisplayName(src.DisplayName),
			Description(src.Description),
			Metadata(src.Metadata)
			{}
			
		FStoreMarketingModel(const TSharedPtr<FJsonObject>& obj) : FStoreMarketingModel()
        {
            readFromValue(obj);
        }
		
		~FStoreMarketingModel();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetStoreItemsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of items which can be purchased from this store.
		TArray<FStoreItem> Store;
		// [optional] How the store was last updated (Admin or a third party).
		Boxed<SourceType> Source;
		// [optional] The base catalog that this store is a part of.
		FString CatalogVersion;
		// [optional] The ID of this store.
		FString StoreId;
		// [optional] Additional data about the store.
		TSharedPtr<FStoreMarketingModel> MarketingData;
	
        FGetStoreItemsResult() :
			FPlayFabBaseModel(),
			Store(),
			Source(),
			CatalogVersion(),
			StoreId(),
			MarketingData(nullptr)
			{}
		
		FGetStoreItemsResult(const FGetStoreItemsResult& src) :
			FPlayFabBaseModel(),
			Store(src.Store),
			Source(src.Source),
			CatalogVersion(src.CatalogVersion),
			StoreId(src.StoreId),
			MarketingData(src.MarketingData.IsValid() ? MakeShareable(new FStoreMarketingModel(*src.MarketingData)) : nullptr)
			{}
			
		FGetStoreItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetStoreItemsResult()
        {
            readFromValue(obj);
        }
		
		~FGetStoreItemsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTimeRequest : public FPlayFabBaseModel
    {
		
	
        FGetTimeRequest() :
			FPlayFabBaseModel()
			{}
		
		FGetTimeRequest(const FGetTimeRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FGetTimeRequest(const TSharedPtr<FJsonObject>& obj) : FGetTimeRequest()
        {
            readFromValue(obj);
        }
		
		~FGetTimeRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTimeResult : public FPlayFabBaseModel
    {
		
		// Current server time when the request was received, in UTC
		FDateTime Time;
	
        FGetTimeResult() :
			FPlayFabBaseModel(),
			Time(0)
			{}
		
		FGetTimeResult(const FGetTimeResult& src) :
			FPlayFabBaseModel(),
			Time(src.Time)
			{}
			
		FGetTimeResult(const TSharedPtr<FJsonObject>& obj) : FGetTimeResult()
        {
            readFromValue(obj);
        }
		
		~FGetTimeResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTitleDataRequest : public FPlayFabBaseModel
    {
		
		// [optional] Specific keys to search for in the title data (leave null to get all keys)
		TArray<FString> Keys;
	
        FGetTitleDataRequest() :
			FPlayFabBaseModel(),
			Keys()
			{}
		
		FGetTitleDataRequest(const FGetTitleDataRequest& src) :
			FPlayFabBaseModel(),
			Keys(src.Keys)
			{}
			
		FGetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetTitleDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTitleDataResult : public FPlayFabBaseModel
    {
		
		// [optional] a dictionary object of key / value pairs
		TMap<FString, FString> Data;
	
        FGetTitleDataResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetTitleDataResult(const FGetTitleDataResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetTitleDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTitleNewsRequest : public FPlayFabBaseModel
    {
		
		// [optional] Limits the results to the last n entries. Defaults to 10 if not set.
		OptionalInt32 Count;
	
        FGetTitleNewsRequest() :
			FPlayFabBaseModel(),
			Count()
			{}
		
		FGetTitleNewsRequest(const FGetTitleNewsRequest& src) :
			FPlayFabBaseModel(),
			Count(src.Count)
			{}
			
		FGetTitleNewsRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleNewsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetTitleNewsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FTitleNewsItem : public FPlayFabBaseModel
    {
		
		// Date and time when the news items was posted.
		FDateTime Timestamp;
		// [optional] Unique identifier of news item.
		FString NewsId;
		// [optional] Title of the news item.
		FString Title;
		// [optional] News item text.
		FString Body;
	
        FTitleNewsItem() :
			FPlayFabBaseModel(),
			Timestamp(0),
			NewsId(),
			Title(),
			Body()
			{}
		
		FTitleNewsItem(const FTitleNewsItem& src) :
			FPlayFabBaseModel(),
			Timestamp(src.Timestamp),
			NewsId(src.NewsId),
			Title(src.Title),
			Body(src.Body)
			{}
			
		FTitleNewsItem(const TSharedPtr<FJsonObject>& obj) : FTitleNewsItem()
        {
            readFromValue(obj);
        }
		
		~FTitleNewsItem();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTitleNewsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of news items.
		TArray<FTitleNewsItem> News;
	
        FGetTitleNewsResult() :
			FPlayFabBaseModel(),
			News()
			{}
		
		FGetTitleNewsResult(const FGetTitleNewsResult& src) :
			FPlayFabBaseModel(),
			News(src.News)
			{}
			
		FGetTitleNewsResult(const TSharedPtr<FJsonObject>& obj) : FGetTitleNewsResult()
        {
            readFromValue(obj);
        }
		
		~FGetTitleNewsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTradeStatusRequest : public FPlayFabBaseModel
    {
		
		// Player who opened trade.
		FString OfferingPlayerId;
		// Trade identifier as returned by OpenTradeOffer.
		FString TradeId;
	
        FGetTradeStatusRequest() :
			FPlayFabBaseModel(),
			OfferingPlayerId(),
			TradeId()
			{}
		
		FGetTradeStatusRequest(const FGetTradeStatusRequest& src) :
			FPlayFabBaseModel(),
			OfferingPlayerId(src.OfferingPlayerId),
			TradeId(src.TradeId)
			{}
			
		FGetTradeStatusRequest(const TSharedPtr<FJsonObject>& obj) : FGetTradeStatusRequest()
        {
            readFromValue(obj);
        }
		
		~FGetTradeStatusRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTradeStatusResponse : public FPlayFabBaseModel
    {
		
		// [optional] Information about the requested trade.
		TSharedPtr<FTradeInfo> Trade;
	
        FGetTradeStatusResponse() :
			FPlayFabBaseModel(),
			Trade(nullptr)
			{}
		
		FGetTradeStatusResponse(const FGetTradeStatusResponse& src) :
			FPlayFabBaseModel(),
			Trade(src.Trade.IsValid() ? MakeShareable(new FTradeInfo(*src.Trade)) : nullptr)
			{}
			
		FGetTradeStatusResponse(const TSharedPtr<FJsonObject>& obj) : FGetTradeStatusResponse()
        {
            readFromValue(obj);
        }
		
		~FGetTradeStatusResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserCombinedInfoRequest : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab identifier of the user whose info is being requested. Optional, defaults to the authenticated user if no other lookup identifier set.
		FString PlayFabId;
		// [optional] PlayFab Username for the account to find (if no PlayFabId is specified).
		FString Username;
		// [optional] User email address for the account to find (if no Username is specified).
		FString Email;
		// [optional] Title-specific username for the account to find (if no Email is set).
		FString TitleDisplayName;
		// [optional] If set to false, account info will not be returned. Defaults to true.
		OptionalBool GetAccountInfo;
		// [optional] If set to false, inventory will not be returned. Defaults to true. Inventory will never be returned for users other than yourself.
		OptionalBool GetInventory;
		// [optional] If set to false, virtual currency balances will not be returned. Defaults to true. Currency balances will never be returned for users other than yourself.
		OptionalBool GetVirtualCurrency;
		// [optional] If set to false, custom user data will not be returned. Defaults to true.
		OptionalBool GetUserData;
		// [optional] User custom data keys to return. If set to null, all keys will be returned. For users other than yourself, only public data will be returned.
		TArray<FString> UserDataKeys;
		// [optional] If set to false, read-only user data will not be returned. Defaults to true.
		OptionalBool GetReadOnlyData;
		// [optional] User read-only custom data keys to return. If set to null, all keys will be returned. For users other than yourself, only public data will be returned.
		TArray<FString> ReadOnlyDataKeys;
	
        FGetUserCombinedInfoRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Username(),
			Email(),
			TitleDisplayName(),
			GetAccountInfo(),
			GetInventory(),
			GetVirtualCurrency(),
			GetUserData(),
			UserDataKeys(),
			GetReadOnlyData(),
			ReadOnlyDataKeys()
			{}
		
		FGetUserCombinedInfoRequest(const FGetUserCombinedInfoRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Username(src.Username),
			Email(src.Email),
			TitleDisplayName(src.TitleDisplayName),
			GetAccountInfo(src.GetAccountInfo),
			GetInventory(src.GetInventory),
			GetVirtualCurrency(src.GetVirtualCurrency),
			GetUserData(src.GetUserData),
			UserDataKeys(src.UserDataKeys),
			GetReadOnlyData(src.GetReadOnlyData),
			ReadOnlyDataKeys(src.ReadOnlyDataKeys)
			{}
			
		FGetUserCombinedInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserCombinedInfoRequest()
        {
            readFromValue(obj);
        }
		
		~FGetUserCombinedInfoRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserCombinedInfoResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab identifier of the owner of the combined info.
		FString PlayFabId;
		// [optional] Account information for the user.
		TSharedPtr<FUserAccountInfo> AccountInfo;
		// [optional] Array of inventory items in the user's current inventory.
		TArray<FItemInstance> Inventory;
		// [optional] Array of virtual currency balance(s) belonging to the user.
		TMap<FString, int32> VirtualCurrency;
		// [optional] Array of remaining times and timestamps for virtual currencies.
		TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
		// [optional] User specific custom data.
		TMap<FString, FUserDataRecord> Data;
		// The version of the UserData that was returned.
		uint32 DataVersion;
		// [optional] User specific read-only data.
		TMap<FString, FUserDataRecord> ReadOnlyData;
		// The version of the Read-Only UserData that was returned.
		uint32 ReadOnlyDataVersion;
	
        FGetUserCombinedInfoResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			AccountInfo(nullptr),
			Inventory(),
			VirtualCurrency(),
			VirtualCurrencyRechargeTimes(),
			Data(),
			DataVersion(0),
			ReadOnlyData(),
			ReadOnlyDataVersion(0)
			{}
		
		FGetUserCombinedInfoResult(const FGetUserCombinedInfoResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			AccountInfo(src.AccountInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.AccountInfo)) : nullptr),
			Inventory(src.Inventory),
			VirtualCurrency(src.VirtualCurrency),
			VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes),
			Data(src.Data),
			DataVersion(src.DataVersion),
			ReadOnlyData(src.ReadOnlyData),
			ReadOnlyDataVersion(src.ReadOnlyDataVersion)
			{}
			
		FGetUserCombinedInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetUserCombinedInfoResult()
        {
            readFromValue(obj);
        }
		
		~FGetUserCombinedInfoResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserDataRequest : public FPlayFabBaseModel
    {
		
		// [optional] Specific keys to search for in the custom data. Leave null to get all keys.
		TArray<FString> Keys;
		// [optional] Unique PlayFab identifier of the user to load data for. Optional, defaults to yourself if not set. When specified to a PlayFab id of another player, then this will only return public keys for that account.
		FString PlayFabId;
		// [optional] The version that currently exists according to the caller. The call will return the data for all of the keys if the version in the system is greater than this.
		OptionalUint32 IfChangedFromDataVersion;
	
        FGetUserDataRequest() :
			FPlayFabBaseModel(),
			Keys(),
			PlayFabId(),
			IfChangedFromDataVersion()
			{}
		
		FGetUserDataRequest(const FGetUserDataRequest& src) :
			FPlayFabBaseModel(),
			Keys(src.Keys),
			PlayFabId(src.PlayFabId),
			IfChangedFromDataVersion(src.IfChangedFromDataVersion)
			{}
			
		FGetUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetUserDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserDataResult : public FPlayFabBaseModel
    {
		
		// [optional] User specific data for this title.
		TMap<FString, FUserDataRecord> Data;
		// Indicates the current version of the data that has been set. This is incremented with every set call for that type of data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
		uint32 DataVersion;
	
        FGetUserDataResult() :
			FPlayFabBaseModel(),
			Data(),
			DataVersion(0)
			{}
		
		FGetUserDataResult(const FGetUserDataResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data),
			DataVersion(src.DataVersion)
			{}
			
		FGetUserDataResult(const TSharedPtr<FJsonObject>& obj) : FGetUserDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetUserDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserInventoryRequest : public FPlayFabBaseModel
    {
		
	
        FGetUserInventoryRequest() :
			FPlayFabBaseModel()
			{}
		
		FGetUserInventoryRequest(const FGetUserInventoryRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FGetUserInventoryRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryRequest()
        {
            readFromValue(obj);
        }
		
		~FGetUserInventoryRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserInventoryResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of inventory items belonging to the user.
		TArray<FItemInstance> Inventory;
		// [optional] Array of virtual currency balance(s) belonging to the user.
		TMap<FString, int32> VirtualCurrency;
		// [optional] Array of remaining times and timestamps for virtual currencies.
		TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
	
        FGetUserInventoryResult() :
			FPlayFabBaseModel(),
			Inventory(),
			VirtualCurrency(),
			VirtualCurrencyRechargeTimes()
			{}
		
		FGetUserInventoryResult(const FGetUserInventoryResult& src) :
			FPlayFabBaseModel(),
			Inventory(src.Inventory),
			VirtualCurrency(src.VirtualCurrency),
			VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes)
			{}
			
		FGetUserInventoryResult(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryResult()
        {
            readFromValue(obj);
        }
		
		~FGetUserInventoryResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantCharacterToUserRequest : public FPlayFabBaseModel
    {
		
		// [optional] Catalog version from which items are to be granted.
		FString CatalogVersion;
		// Catalog item identifier of the item in the user's inventory that corresponds to the character in the catalog to be created.
		FString ItemId;
		// Non-unique display name of the character being granted.
		FString CharacterName;
	
        FGrantCharacterToUserRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			ItemId(),
			CharacterName()
			{}
		
		FGrantCharacterToUserRequest(const FGrantCharacterToUserRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			ItemId(src.ItemId),
			CharacterName(src.CharacterName)
			{}
			
		FGrantCharacterToUserRequest(const TSharedPtr<FJsonObject>& obj) : FGrantCharacterToUserRequest()
        {
            readFromValue(obj);
        }
		
		~FGrantCharacterToUserRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantCharacterToUserResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier tagged to this character.
		FString CharacterId;
		// [optional] Type of character that was created.
		FString CharacterType;
		// Indicates whether this character was created successfully.
		bool Result;
	
        FGrantCharacterToUserResult() :
			FPlayFabBaseModel(),
			CharacterId(),
			CharacterType(),
			Result(false)
			{}
		
		FGrantCharacterToUserResult(const FGrantCharacterToUserResult& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			CharacterType(src.CharacterType),
			Result(src.Result)
			{}
			
		FGrantCharacterToUserResult(const TSharedPtr<FJsonObject>& obj) : FGrantCharacterToUserResult()
        {
            readFromValue(obj);
        }
		
		~FGrantCharacterToUserResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FItemPurchaseRequest : public FPlayFabBaseModel
    {
		
		// Unique ItemId of the item to purchase.
		FString ItemId;
		// How many of this item to purchase.
		uint32 Quantity;
		// [optional] Title-specific text concerning this purchase.
		FString Annotation;
		// [optional] Items to be upgraded as a result of this purchase (upgraded items are hidden, as they are "replaced" by the new items).
		TArray<FString> UpgradeFromItems;
	
        FItemPurchaseRequest() :
			FPlayFabBaseModel(),
			ItemId(),
			Quantity(0),
			Annotation(),
			UpgradeFromItems()
			{}
		
		FItemPurchaseRequest(const FItemPurchaseRequest& src) :
			FPlayFabBaseModel(),
			ItemId(src.ItemId),
			Quantity(src.Quantity),
			Annotation(src.Annotation),
			UpgradeFromItems(src.UpgradeFromItems)
			{}
			
		FItemPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FItemPurchaseRequest()
        {
            readFromValue(obj);
        }
		
		~FItemPurchaseRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkAndroidDeviceIDRequest : public FPlayFabBaseModel
    {
		
		// Android device identifier for the user's device.
		FString AndroidDeviceId;
		// [optional] Specific Operating System version for the user's device.
		FString OS;
		// [optional] Specific model of the user's device.
		FString AndroidDevice;
		// [optional] If another user is already linked to the device, unlink the other user and re-link.
		OptionalBool ForceLink;
	
        FLinkAndroidDeviceIDRequest() :
			FPlayFabBaseModel(),
			AndroidDeviceId(),
			OS(),
			AndroidDevice(),
			ForceLink()
			{}
		
		FLinkAndroidDeviceIDRequest(const FLinkAndroidDeviceIDRequest& src) :
			FPlayFabBaseModel(),
			AndroidDeviceId(src.AndroidDeviceId),
			OS(src.OS),
			AndroidDevice(src.AndroidDevice),
			ForceLink(src.ForceLink)
			{}
			
		FLinkAndroidDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FLinkAndroidDeviceIDRequest()
        {
            readFromValue(obj);
        }
		
		~FLinkAndroidDeviceIDRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkAndroidDeviceIDResult : public FPlayFabBaseModel
    {
		
	
        FLinkAndroidDeviceIDResult() :
			FPlayFabBaseModel()
			{}
		
		FLinkAndroidDeviceIDResult(const FLinkAndroidDeviceIDResult& src) :
			FPlayFabBaseModel()
			{}
			
		FLinkAndroidDeviceIDResult(const TSharedPtr<FJsonObject>& obj) : FLinkAndroidDeviceIDResult()
        {
            readFromValue(obj);
        }
		
		~FLinkAndroidDeviceIDResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkCustomIDRequest : public FPlayFabBaseModel
    {
		
		// Custom unique identifier for the user, generated by the title.
		FString CustomId;
		// [optional] If another user is already linked to the custom ID, unlink the other user and re-link.
		OptionalBool ForceLink;
	
        FLinkCustomIDRequest() :
			FPlayFabBaseModel(),
			CustomId(),
			ForceLink()
			{}
		
		FLinkCustomIDRequest(const FLinkCustomIDRequest& src) :
			FPlayFabBaseModel(),
			CustomId(src.CustomId),
			ForceLink(src.ForceLink)
			{}
			
		FLinkCustomIDRequest(const TSharedPtr<FJsonObject>& obj) : FLinkCustomIDRequest()
        {
            readFromValue(obj);
        }
		
		~FLinkCustomIDRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkCustomIDResult : public FPlayFabBaseModel
    {
		
	
        FLinkCustomIDResult() :
			FPlayFabBaseModel()
			{}
		
		FLinkCustomIDResult(const FLinkCustomIDResult& src) :
			FPlayFabBaseModel()
			{}
			
		FLinkCustomIDResult(const TSharedPtr<FJsonObject>& obj) : FLinkCustomIDResult()
        {
            readFromValue(obj);
        }
		
		~FLinkCustomIDResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkFacebookAccountRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier from Facebook for the user.
		FString AccessToken;
		// [optional] If another user is already linked to the account, unlink the other user and re-link.
		OptionalBool ForceLink;
	
        FLinkFacebookAccountRequest() :
			FPlayFabBaseModel(),
			AccessToken(),
			ForceLink()
			{}
		
		FLinkFacebookAccountRequest(const FLinkFacebookAccountRequest& src) :
			FPlayFabBaseModel(),
			AccessToken(src.AccessToken),
			ForceLink(src.ForceLink)
			{}
			
		FLinkFacebookAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkFacebookAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FLinkFacebookAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkFacebookAccountResult : public FPlayFabBaseModel
    {
		
	
        FLinkFacebookAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FLinkFacebookAccountResult(const FLinkFacebookAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FLinkFacebookAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkFacebookAccountResult()
        {
            readFromValue(obj);
        }
		
		~FLinkFacebookAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkGameCenterAccountRequest : public FPlayFabBaseModel
    {
		
		// Game Center identifier for the player account to be linked.
		FString GameCenterId;
		// [optional] If another user is already linked to the account, unlink the other user and re-link.
		OptionalBool ForceLink;
	
        FLinkGameCenterAccountRequest() :
			FPlayFabBaseModel(),
			GameCenterId(),
			ForceLink()
			{}
		
		FLinkGameCenterAccountRequest(const FLinkGameCenterAccountRequest& src) :
			FPlayFabBaseModel(),
			GameCenterId(src.GameCenterId),
			ForceLink(src.ForceLink)
			{}
			
		FLinkGameCenterAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkGameCenterAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FLinkGameCenterAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkGameCenterAccountResult : public FPlayFabBaseModel
    {
		
	
        FLinkGameCenterAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FLinkGameCenterAccountResult(const FLinkGameCenterAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FLinkGameCenterAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkGameCenterAccountResult()
        {
            readFromValue(obj);
        }
		
		~FLinkGameCenterAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkGoogleAccountRequest : public FPlayFabBaseModel
    {
		
		// Unique token (https://developers.google.com/android/reference/com/google/android/gms/auth/GoogleAuthUtil#public-methods) from Google Play for the user.
		FString AccessToken;
		// [optional] If another user is already linked to the account, unlink the other user and re-link.
		OptionalBool ForceLink;
	
        FLinkGoogleAccountRequest() :
			FPlayFabBaseModel(),
			AccessToken(),
			ForceLink()
			{}
		
		FLinkGoogleAccountRequest(const FLinkGoogleAccountRequest& src) :
			FPlayFabBaseModel(),
			AccessToken(src.AccessToken),
			ForceLink(src.ForceLink)
			{}
			
		FLinkGoogleAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkGoogleAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FLinkGoogleAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkGoogleAccountResult : public FPlayFabBaseModel
    {
		
	
        FLinkGoogleAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FLinkGoogleAccountResult(const FLinkGoogleAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FLinkGoogleAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkGoogleAccountResult()
        {
            readFromValue(obj);
        }
		
		~FLinkGoogleAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkIOSDeviceIDRequest : public FPlayFabBaseModel
    {
		
		// Vendor-specific iOS identifier for the user's device.
		FString DeviceId;
		// [optional] Specific Operating System version for the user's device.
		FString OS;
		// [optional] Specific model of the user's device.
		FString DeviceModel;
		// [optional] If another user is already linked to the device, unlink the other user and re-link.
		OptionalBool ForceLink;
	
        FLinkIOSDeviceIDRequest() :
			FPlayFabBaseModel(),
			DeviceId(),
			OS(),
			DeviceModel(),
			ForceLink()
			{}
		
		FLinkIOSDeviceIDRequest(const FLinkIOSDeviceIDRequest& src) :
			FPlayFabBaseModel(),
			DeviceId(src.DeviceId),
			OS(src.OS),
			DeviceModel(src.DeviceModel),
			ForceLink(src.ForceLink)
			{}
			
		FLinkIOSDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FLinkIOSDeviceIDRequest()
        {
            readFromValue(obj);
        }
		
		~FLinkIOSDeviceIDRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkIOSDeviceIDResult : public FPlayFabBaseModel
    {
		
	
        FLinkIOSDeviceIDResult() :
			FPlayFabBaseModel()
			{}
		
		FLinkIOSDeviceIDResult(const FLinkIOSDeviceIDResult& src) :
			FPlayFabBaseModel()
			{}
			
		FLinkIOSDeviceIDResult(const TSharedPtr<FJsonObject>& obj) : FLinkIOSDeviceIDResult()
        {
            readFromValue(obj);
        }
		
		~FLinkIOSDeviceIDResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkKongregateAccountRequest : public FPlayFabBaseModel
    {
		
		// Numeric user ID assigned by Kongregate
		FString KongregateId;
		// Valid session auth ticket issued by Kongregate
		FString AuthTicket;
		// [optional] If another user is already linked to the account, unlink the other user and re-link.
		OptionalBool ForceLink;
	
        FLinkKongregateAccountRequest() :
			FPlayFabBaseModel(),
			KongregateId(),
			AuthTicket(),
			ForceLink()
			{}
		
		FLinkKongregateAccountRequest(const FLinkKongregateAccountRequest& src) :
			FPlayFabBaseModel(),
			KongregateId(src.KongregateId),
			AuthTicket(src.AuthTicket),
			ForceLink(src.ForceLink)
			{}
			
		FLinkKongregateAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkKongregateAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FLinkKongregateAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkKongregateAccountResult : public FPlayFabBaseModel
    {
		
	
        FLinkKongregateAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FLinkKongregateAccountResult(const FLinkKongregateAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FLinkKongregateAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkKongregateAccountResult()
        {
            readFromValue(obj);
        }
		
		~FLinkKongregateAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkSteamAccountRequest : public FPlayFabBaseModel
    {
		
		// Authentication token for the user, returned as a byte array from Steam, and converted to a string (for example, the byte 0x08 should become "08").
		FString SteamTicket;
		// [optional] If another user is already linked to the account, unlink the other user and re-link.
		OptionalBool ForceLink;
	
        FLinkSteamAccountRequest() :
			FPlayFabBaseModel(),
			SteamTicket(),
			ForceLink()
			{}
		
		FLinkSteamAccountRequest(const FLinkSteamAccountRequest& src) :
			FPlayFabBaseModel(),
			SteamTicket(src.SteamTicket),
			ForceLink(src.ForceLink)
			{}
			
		FLinkSteamAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkSteamAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FLinkSteamAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkSteamAccountResult : public FPlayFabBaseModel
    {
		
	
        FLinkSteamAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FLinkSteamAccountResult(const FLinkSteamAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FLinkSteamAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkSteamAccountResult()
        {
            readFromValue(obj);
        }
		
		~FLinkSteamAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkTwitchAccountRequest : public FPlayFabBaseModel
    {
		
		// Valid token issued by Twitch
		FString AccessToken;
		// [optional] If another user is already linked to the account, unlink the other user and re-link.
		OptionalBool ForceLink;
	
        FLinkTwitchAccountRequest() :
			FPlayFabBaseModel(),
			AccessToken(),
			ForceLink()
			{}
		
		FLinkTwitchAccountRequest(const FLinkTwitchAccountRequest& src) :
			FPlayFabBaseModel(),
			AccessToken(src.AccessToken),
			ForceLink(src.ForceLink)
			{}
			
		FLinkTwitchAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLinkTwitchAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FLinkTwitchAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLinkTwitchAccountResult : public FPlayFabBaseModel
    {
		
	
        FLinkTwitchAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FLinkTwitchAccountResult(const FLinkTwitchAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FLinkTwitchAccountResult(const TSharedPtr<FJsonObject>& obj) : FLinkTwitchAccountResult()
        {
            readFromValue(obj);
        }
		
		~FLinkTwitchAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FListUsersCharactersRequest : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FListUsersCharactersRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FListUsersCharactersRequest(const FListUsersCharactersRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FListUsersCharactersRequest(const TSharedPtr<FJsonObject>& obj) : FListUsersCharactersRequest()
        {
            readFromValue(obj);
        }
		
		~FListUsersCharactersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FListUsersCharactersResult : public FPlayFabBaseModel
    {
		
		// [optional] The requested list of characters.
		TArray<FCharacterResult> Characters;
	
        FListUsersCharactersResult() :
			FPlayFabBaseModel(),
			Characters()
			{}
		
		FListUsersCharactersResult(const FListUsersCharactersResult& src) :
			FPlayFabBaseModel(),
			Characters(src.Characters)
			{}
			
		FListUsersCharactersResult(const TSharedPtr<FJsonObject>& obj) : FListUsersCharactersResult()
        {
            readFromValue(obj);
        }
		
		~FListUsersCharactersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserSettings : public FPlayFabBaseModel
    {
		
		// Boolean for whether this player is eligible for ad tracking.
		bool NeedsAttribution;
	
        FUserSettings() :
			FPlayFabBaseModel(),
			NeedsAttribution(false)
			{}
		
		FUserSettings(const FUserSettings& src) :
			FPlayFabBaseModel(),
			NeedsAttribution(src.NeedsAttribution)
			{}
			
		FUserSettings(const TSharedPtr<FJsonObject>& obj) : FUserSettings()
        {
            readFromValue(obj);
        }
		
		~FUserSettings();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique token authorizing the user and game at the server level, for the current session.
		FString SessionTicket;
		// [optional] Player's unique PlayFabId.
		FString PlayFabId;
		// True if the account was newly created on this login.
		bool NewlyCreated;
		// [optional] Settings specific to this user.
		TSharedPtr<FUserSettings> SettingsForUser;
		// [optional] The time of this user's previous login. If there was no previous login, then it's DateTime.MinValue
		OptionalTime LastLoginTime;
		// [optional] Results for requested info.
		TSharedPtr<FGetPlayerCombinedInfoResultPayload> InfoResultPayload;
	
        FLoginResult() :
			FPlayFabBaseModel(),
			SessionTicket(),
			PlayFabId(),
			NewlyCreated(false),
			SettingsForUser(nullptr),
			LastLoginTime(),
			InfoResultPayload(nullptr)
			{}
		
		FLoginResult(const FLoginResult& src) :
			FPlayFabBaseModel(),
			SessionTicket(src.SessionTicket),
			PlayFabId(src.PlayFabId),
			NewlyCreated(src.NewlyCreated),
			SettingsForUser(src.SettingsForUser.IsValid() ? MakeShareable(new FUserSettings(*src.SettingsForUser)) : nullptr),
			LastLoginTime(src.LastLoginTime),
			InfoResultPayload(src.InfoResultPayload.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoResultPayload(*src.InfoResultPayload)) : nullptr)
			{}
			
		FLoginResult(const TSharedPtr<FJsonObject>& obj) : FLoginResult()
        {
            readFromValue(obj);
        }
		
		~FLoginResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginWithAndroidDeviceIDRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// Android device identifier for the user's device.
		FString AndroidDeviceId;
		// [optional] Specific Operating System version for the user's device.
		FString OS;
		// [optional] Specific model of the user's device.
		FString AndroidDevice;
		// [optional] Automatically create a PlayFab account if one is not currently linked to this Android device.
		OptionalBool CreateAccount;
		// [optional] Flags for which pieces of info to return for the user.
		TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;
	
        FLoginWithAndroidDeviceIDRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			AndroidDeviceId(),
			OS(),
			AndroidDevice(),
			CreateAccount(),
			InfoRequestParameters(nullptr)
			{}
		
		FLoginWithAndroidDeviceIDRequest(const FLoginWithAndroidDeviceIDRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			AndroidDeviceId(src.AndroidDeviceId),
			OS(src.OS),
			AndroidDevice(src.AndroidDevice),
			CreateAccount(src.CreateAccount),
			InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr)
			{}
			
		FLoginWithAndroidDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithAndroidDeviceIDRequest()
        {
            readFromValue(obj);
        }
		
		~FLoginWithAndroidDeviceIDRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginWithCustomIDRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// Custom unique identifier for the user, generated by the title.
		FString CustomId;
		// [optional] Automatically create a PlayFab account if one is not currently linked to this Custom ID.
		OptionalBool CreateAccount;
		// [optional] Flags for which pieces of info to return for the user.
		TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;
	
        FLoginWithCustomIDRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			CustomId(),
			CreateAccount(),
			InfoRequestParameters(nullptr)
			{}
		
		FLoginWithCustomIDRequest(const FLoginWithCustomIDRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			CustomId(src.CustomId),
			CreateAccount(src.CreateAccount),
			InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr)
			{}
			
		FLoginWithCustomIDRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithCustomIDRequest()
        {
            readFromValue(obj);
        }
		
		~FLoginWithCustomIDRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginWithEmailAddressRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// Email address for the account.
		FString Email;
		// Password for the PlayFab account (6-100 characters)
		FString Password;
		// [optional] Flags for which pieces of info to return for the user.
		TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;
	
        FLoginWithEmailAddressRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			Email(),
			Password(),
			InfoRequestParameters(nullptr)
			{}
		
		FLoginWithEmailAddressRequest(const FLoginWithEmailAddressRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			Email(src.Email),
			Password(src.Password),
			InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr)
			{}
			
		FLoginWithEmailAddressRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithEmailAddressRequest()
        {
            readFromValue(obj);
        }
		
		~FLoginWithEmailAddressRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginWithFacebookRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// Unique identifier from Facebook for the user.
		FString AccessToken;
		// [optional] Automatically create a PlayFab account if one is not currently linked to this Facebook account.
		OptionalBool CreateAccount;
		// [optional] Flags for which pieces of info to return for the user.
		TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;
	
        FLoginWithFacebookRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			AccessToken(),
			CreateAccount(),
			InfoRequestParameters(nullptr)
			{}
		
		FLoginWithFacebookRequest(const FLoginWithFacebookRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			AccessToken(src.AccessToken),
			CreateAccount(src.CreateAccount),
			InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr)
			{}
			
		FLoginWithFacebookRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithFacebookRequest()
        {
            readFromValue(obj);
        }
		
		~FLoginWithFacebookRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginWithGameCenterRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// Unique Game Center player id.
		FString PlayerId;
		// [optional] Automatically create a PlayFab account if one is not currently linked to this Game Center id.
		OptionalBool CreateAccount;
		// [optional] Flags for which pieces of info to return for the user.
		TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;
	
        FLoginWithGameCenterRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			PlayerId(),
			CreateAccount(),
			InfoRequestParameters(nullptr)
			{}
		
		FLoginWithGameCenterRequest(const FLoginWithGameCenterRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			PlayerId(src.PlayerId),
			CreateAccount(src.CreateAccount),
			InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr)
			{}
			
		FLoginWithGameCenterRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithGameCenterRequest()
        {
            readFromValue(obj);
        }
		
		~FLoginWithGameCenterRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginWithGoogleAccountRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// Unique token (https://developers.google.com/android/reference/com/google/android/gms/auth/GoogleAuthUtil#public-methods) from Google Play for the user.
		FString AccessToken;
		// [optional] Automatically create a PlayFab account if one is not currently linked to this Google account.
		OptionalBool CreateAccount;
		// [optional] Flags for which pieces of info to return for the user.
		TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;
	
        FLoginWithGoogleAccountRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			AccessToken(),
			CreateAccount(),
			InfoRequestParameters(nullptr)
			{}
		
		FLoginWithGoogleAccountRequest(const FLoginWithGoogleAccountRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			AccessToken(src.AccessToken),
			CreateAccount(src.CreateAccount),
			InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr)
			{}
			
		FLoginWithGoogleAccountRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithGoogleAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FLoginWithGoogleAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginWithIOSDeviceIDRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// Vendor-specific iOS identifier for the user's device.
		FString DeviceId;
		// [optional] Specific Operating System version for the user's device.
		FString OS;
		// [optional] Specific model of the user's device.
		FString DeviceModel;
		// [optional] Flags for which pieces of info to return for the user.
		TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;
		// [optional] Automatically create a PlayFab account if one is not currently linked to this iOS device.
		OptionalBool CreateAccount;
	
        FLoginWithIOSDeviceIDRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			DeviceId(),
			OS(),
			DeviceModel(),
			InfoRequestParameters(nullptr),
			CreateAccount()
			{}
		
		FLoginWithIOSDeviceIDRequest(const FLoginWithIOSDeviceIDRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			DeviceId(src.DeviceId),
			OS(src.OS),
			DeviceModel(src.DeviceModel),
			InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr),
			CreateAccount(src.CreateAccount)
			{}
			
		FLoginWithIOSDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithIOSDeviceIDRequest()
        {
            readFromValue(obj);
        }
		
		~FLoginWithIOSDeviceIDRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginWithKongregateRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// Numeric user ID assigned by Kongregate
		FString KongregateId;
		// Token issued by Kongregate's client API for the user.
		FString AuthTicket;
		// [optional] Automatically create a PlayFab account if one is not currently linked to this Kongregate account.
		OptionalBool CreateAccount;
		// [optional] Flags for which pieces of info to return for the user.
		TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;
	
        FLoginWithKongregateRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			KongregateId(),
			AuthTicket(),
			CreateAccount(),
			InfoRequestParameters(nullptr)
			{}
		
		FLoginWithKongregateRequest(const FLoginWithKongregateRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			KongregateId(src.KongregateId),
			AuthTicket(src.AuthTicket),
			CreateAccount(src.CreateAccount),
			InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr)
			{}
			
		FLoginWithKongregateRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithKongregateRequest()
        {
            readFromValue(obj);
        }
		
		~FLoginWithKongregateRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginWithPlayFabRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// PlayFab username for the account.
		FString Username;
		// Password for the PlayFab account (6-100 characters)
		FString Password;
		// [optional] Flags for which pieces of info to return for the user.
		TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;
	
        FLoginWithPlayFabRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			Username(),
			Password(),
			InfoRequestParameters(nullptr)
			{}
		
		FLoginWithPlayFabRequest(const FLoginWithPlayFabRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			Username(src.Username),
			Password(src.Password),
			InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr)
			{}
			
		FLoginWithPlayFabRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithPlayFabRequest()
        {
            readFromValue(obj);
        }
		
		~FLoginWithPlayFabRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginWithSteamRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// Authentication token for the user, returned as a byte array from Steam, and converted to a string (for example, the byte 0x08 should become "08").
		FString SteamTicket;
		// [optional] Automatically create a PlayFab account if one is not currently linked to this Steam account.
		OptionalBool CreateAccount;
		// [optional] Flags for which pieces of info to return for the user.
		TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;
	
        FLoginWithSteamRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			SteamTicket(),
			CreateAccount(),
			InfoRequestParameters(nullptr)
			{}
		
		FLoginWithSteamRequest(const FLoginWithSteamRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			SteamTicket(src.SteamTicket),
			CreateAccount(src.CreateAccount),
			InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr)
			{}
			
		FLoginWithSteamRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithSteamRequest()
        {
            readFromValue(obj);
        }
		
		~FLoginWithSteamRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLoginWithTwitchRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// Token issued by Twitch's API for the user.
		FString AccessToken;
		// [optional] Automatically create a PlayFab account if one is not currently linked to this Twitch account.
		OptionalBool CreateAccount;
		// [optional] Flags for which pieces of info to return for the user.
		TSharedPtr<FGetPlayerCombinedInfoRequestParams> InfoRequestParameters;
	
        FLoginWithTwitchRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			AccessToken(),
			CreateAccount(),
			InfoRequestParameters(nullptr)
			{}
		
		FLoginWithTwitchRequest(const FLoginWithTwitchRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			AccessToken(src.AccessToken),
			CreateAccount(src.CreateAccount),
			InfoRequestParameters(src.InfoRequestParameters.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoRequestParams(*src.InfoRequestParameters)) : nullptr)
			{}
			
		FLoginWithTwitchRequest(const TSharedPtr<FJsonObject>& obj) : FLoginWithTwitchRequest()
        {
            readFromValue(obj);
        }
		
		~FLoginWithTwitchRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FMatchmakeRequest : public FPlayFabBaseModel
    {
		
		// [optional] Build version to match against. [Note: Required if LobbyId is not specified]
		FString BuildVersion;
		// [optional] Region to match make against. [Note: Required if LobbyId is not specified]
		Boxed<Region> pfRegion;
		// [optional] Game mode to match make against. [Note: Required if LobbyId is not specified]
		FString GameMode;
		// [optional] Lobby identifier to match make against. This is used to select a specific Game Server Instance.
		FString LobbyId;
		// [optional] Player statistic to use in finding a match. May be null for no stat-based matching.
		FString StatisticName;
		// [optional] Character to use for stats based matching. Leave null to use account stats.
		FString CharacterId;
		// [optional] Start a game session if one with an open slot is not found. Defaults to true.
		OptionalBool StartNewIfNoneFound;
		// [optional] Filter to include and/or exclude Game Server Instances associated with certain Tags
		TSharedPtr<FCollectionFilter> TagFilter;
	
        FMatchmakeRequest() :
			FPlayFabBaseModel(),
			BuildVersion(),
			pfRegion(),
			GameMode(),
			LobbyId(),
			StatisticName(),
			CharacterId(),
			StartNewIfNoneFound(),
			TagFilter(nullptr)
			{}
		
		FMatchmakeRequest(const FMatchmakeRequest& src) :
			FPlayFabBaseModel(),
			BuildVersion(src.BuildVersion),
			pfRegion(src.pfRegion),
			GameMode(src.GameMode),
			LobbyId(src.LobbyId),
			StatisticName(src.StatisticName),
			CharacterId(src.CharacterId),
			StartNewIfNoneFound(src.StartNewIfNoneFound),
			TagFilter(src.TagFilter.IsValid() ? MakeShareable(new FCollectionFilter(*src.TagFilter)) : nullptr)
			{}
			
		FMatchmakeRequest(const TSharedPtr<FJsonObject>& obj) : FMatchmakeRequest()
        {
            readFromValue(obj);
        }
		
		~FMatchmakeRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum MatchmakeStatus
	{
		MatchmakeStatusComplete,
		MatchmakeStatusWaiting,
		MatchmakeStatusGameNotFound,
		MatchmakeStatusNoAvailableSlots,
		MatchmakeStatusSessionClosed
	};
	
	void writeMatchmakeStatusEnumJSON(MatchmakeStatus enumVal, JsonWriter& writer);
	MatchmakeStatus readMatchmakeStatusFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FMatchmakeResult : public FPlayFabBaseModel
    {
		
		// [optional] unique lobby identifier of the server matched
		FString LobbyID;
		// [optional] IP address of the server
		FString ServerHostname;
		// [optional] port number to use for non-http communications with the server
		OptionalInt32 ServerPort;
		// [optional] server authorization ticket (used by RedeemMatchmakerTicket to validate user insertion into the game)
		FString Ticket;
		// [optional] timestamp for when the server will expire, if applicable
		FString Expires;
		// [optional] time in milliseconds the application is configured to wait on matchmaking results
		OptionalInt32 PollWaitTimeMS;
		// [optional] result of match making process
		Boxed<MatchmakeStatus> Status;
	
        FMatchmakeResult() :
			FPlayFabBaseModel(),
			LobbyID(),
			ServerHostname(),
			ServerPort(),
			Ticket(),
			Expires(),
			PollWaitTimeMS(),
			Status()
			{}
		
		FMatchmakeResult(const FMatchmakeResult& src) :
			FPlayFabBaseModel(),
			LobbyID(src.LobbyID),
			ServerHostname(src.ServerHostname),
			ServerPort(src.ServerPort),
			Ticket(src.Ticket),
			Expires(src.Expires),
			PollWaitTimeMS(src.PollWaitTimeMS),
			Status(src.Status)
			{}
			
		FMatchmakeResult(const TSharedPtr<FJsonObject>& obj) : FMatchmakeResult()
        {
            readFromValue(obj);
        }
		
		~FMatchmakeResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FModifyUserVirtualCurrencyResult : public FPlayFabBaseModel
    {
		
		// [optional] User currency was subtracted from.
		FString PlayFabId;
		// [optional] Name of the virtual currency which was modified.
		FString VirtualCurrency;
		// Amount added or subtracted from the user's virtual currency. Maximum VC balance is Int32 (2,147,483,647). Any increase over this value will be discarded.
		int32 BalanceChange;
		// Balance of the virtual currency after modification.
		int32 Balance;
	
        FModifyUserVirtualCurrencyResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			VirtualCurrency(),
			BalanceChange(0),
			Balance(0)
			{}
		
		FModifyUserVirtualCurrencyResult(const FModifyUserVirtualCurrencyResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			VirtualCurrency(src.VirtualCurrency),
			BalanceChange(src.BalanceChange),
			Balance(src.Balance)
			{}
			
		FModifyUserVirtualCurrencyResult(const TSharedPtr<FJsonObject>& obj) : FModifyUserVirtualCurrencyResult()
        {
            readFromValue(obj);
        }
		
		~FModifyUserVirtualCurrencyResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FOpenTradeRequest : public FPlayFabBaseModel
    {
		
		// [optional] Player inventory items offered for trade. If not set, the trade is effectively a gift request
		TArray<FString> OfferedInventoryInstanceIds;
		// [optional] Catalog items accepted for the trade. If not set, the trade is effectively a gift.
		TArray<FString> RequestedCatalogItemIds;
		// [optional] Players who are allowed to accept the trade. If null, the trade may be accepted by any player. If empty, the trade may not be accepted by any player.
		TArray<FString> AllowedPlayerIds;
	
        FOpenTradeRequest() :
			FPlayFabBaseModel(),
			OfferedInventoryInstanceIds(),
			RequestedCatalogItemIds(),
			AllowedPlayerIds()
			{}
		
		FOpenTradeRequest(const FOpenTradeRequest& src) :
			FPlayFabBaseModel(),
			OfferedInventoryInstanceIds(src.OfferedInventoryInstanceIds),
			RequestedCatalogItemIds(src.RequestedCatalogItemIds),
			AllowedPlayerIds(src.AllowedPlayerIds)
			{}
			
		FOpenTradeRequest(const TSharedPtr<FJsonObject>& obj) : FOpenTradeRequest()
        {
            readFromValue(obj);
        }
		
		~FOpenTradeRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FOpenTradeResponse : public FPlayFabBaseModel
    {
		
		// [optional] The information about the trade that was just opened.
		TSharedPtr<FTradeInfo> Trade;
	
        FOpenTradeResponse() :
			FPlayFabBaseModel(),
			Trade(nullptr)
			{}
		
		FOpenTradeResponse(const FOpenTradeResponse& src) :
			FPlayFabBaseModel(),
			Trade(src.Trade.IsValid() ? MakeShareable(new FTradeInfo(*src.Trade)) : nullptr)
			{}
			
		FOpenTradeResponse(const TSharedPtr<FJsonObject>& obj) : FOpenTradeResponse()
        {
            readFromValue(obj);
        }
		
		~FOpenTradeResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPayForPurchaseRequest : public FPlayFabBaseModel
    {
		
		// Purchase order identifier returned from StartPurchase.
		FString OrderId;
		// Payment provider to use to fund the purchase.
		FString ProviderName;
		// Currency to use to fund the purchase.
		FString Currency;
		// [optional] Payment provider transaction identifier. Required for Facebook Payments.
		FString ProviderTransactionId;
	
        FPayForPurchaseRequest() :
			FPlayFabBaseModel(),
			OrderId(),
			ProviderName(),
			Currency(),
			ProviderTransactionId()
			{}
		
		FPayForPurchaseRequest(const FPayForPurchaseRequest& src) :
			FPlayFabBaseModel(),
			OrderId(src.OrderId),
			ProviderName(src.ProviderName),
			Currency(src.Currency),
			ProviderTransactionId(src.ProviderTransactionId)
			{}
			
		FPayForPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FPayForPurchaseRequest()
        {
            readFromValue(obj);
        }
		
		~FPayForPurchaseRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum TransactionStatus
	{
		TransactionStatusCreateCart,
		TransactionStatusInit,
		TransactionStatusApproved,
		TransactionStatusSucceeded,
		TransactionStatusFailedByProvider,
		TransactionStatusDisputePending,
		TransactionStatusRefundPending,
		TransactionStatusRefunded,
		TransactionStatusRefundFailed,
		TransactionStatusChargedBack,
		TransactionStatusFailedByUber,
		TransactionStatusFailedByPlayFab,
		TransactionStatusRevoked,
		TransactionStatusTradePending,
		TransactionStatusTraded,
		TransactionStatusUpgraded,
		TransactionStatusStackPending,
		TransactionStatusStacked,
		TransactionStatusOther,
		TransactionStatusFailed
	};
	
	void writeTransactionStatusEnumJSON(TransactionStatus enumVal, JsonWriter& writer);
	TransactionStatus readTransactionStatusFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FPayForPurchaseResult : public FPlayFabBaseModel
    {
		
		// [optional] Purchase order identifier.
		FString OrderId;
		// [optional] Status of the transaction.
		Boxed<TransactionStatus> Status;
		// [optional] Virtual currency cost of the transaction.
		TMap<FString, int32> VCAmount;
		// [optional] Real world currency for the transaction.
		FString PurchaseCurrency;
		// Real world cost of the transaction.
		uint32 PurchasePrice;
		// Local credit applied to the transaction (provider specific).
		uint32 CreditApplied;
		// [optional] Provider used for the transaction.
		FString ProviderData;
		// [optional] URL to the purchase provider page that details the purchase.
		FString PurchaseConfirmationPageURL;
		// [optional] Current virtual currency totals for the user.
		TMap<FString, int32> VirtualCurrency;
		// [optional] A token generated by the provider to authenticate the request (provider-specific).
		FString ProviderToken;
	
        FPayForPurchaseResult() :
			FPlayFabBaseModel(),
			OrderId(),
			Status(),
			VCAmount(),
			PurchaseCurrency(),
			PurchasePrice(0),
			CreditApplied(0),
			ProviderData(),
			PurchaseConfirmationPageURL(),
			VirtualCurrency(),
			ProviderToken()
			{}
		
		FPayForPurchaseResult(const FPayForPurchaseResult& src) :
			FPlayFabBaseModel(),
			OrderId(src.OrderId),
			Status(src.Status),
			VCAmount(src.VCAmount),
			PurchaseCurrency(src.PurchaseCurrency),
			PurchasePrice(src.PurchasePrice),
			CreditApplied(src.CreditApplied),
			ProviderData(src.ProviderData),
			PurchaseConfirmationPageURL(src.PurchaseConfirmationPageURL),
			VirtualCurrency(src.VirtualCurrency),
			ProviderToken(src.ProviderToken)
			{}
			
		FPayForPurchaseResult(const TSharedPtr<FJsonObject>& obj) : FPayForPurchaseResult()
        {
            readFromValue(obj);
        }
		
		~FPayForPurchaseResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPaymentOption : public FPlayFabBaseModel
    {
		
		// [optional] Specific currency to use to fund the purchase.
		FString Currency;
		// [optional] Name of the purchase provider for this option.
		FString ProviderName;
		// Amount of the specified currency needed for the purchase.
		uint32 Price;
		// Amount of existing credit the user has with the provider.
		uint32 StoreCredit;
	
        FPaymentOption() :
			FPlayFabBaseModel(),
			Currency(),
			ProviderName(),
			Price(0),
			StoreCredit(0)
			{}
		
		FPaymentOption(const FPaymentOption& src) :
			FPlayFabBaseModel(),
			Currency(src.Currency),
			ProviderName(src.ProviderName),
			Price(src.Price),
			StoreCredit(src.StoreCredit)
			{}
			
		FPaymentOption(const TSharedPtr<FJsonObject>& obj) : FPaymentOption()
        {
            readFromValue(obj);
        }
		
		~FPaymentOption();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPurchaseItemRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier of the item to purchase.
		FString ItemId;
		// Virtual currency to use to purchase the item.
		FString VirtualCurrency;
		// Price the client expects to pay for the item (in case a new catalog or store was uploaded, with new prices).
		int32 Price;
		// [optional] Catalog version for the items to be purchased (defaults to most recent version.
		FString CatalogVersion;
		// [optional] Store to buy this item through. If not set, prices default to those in the catalog.
		FString StoreId;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
	
        FPurchaseItemRequest() :
			FPlayFabBaseModel(),
			ItemId(),
			VirtualCurrency(),
			Price(0),
			CatalogVersion(),
			StoreId(),
			CharacterId()
			{}
		
		FPurchaseItemRequest(const FPurchaseItemRequest& src) :
			FPlayFabBaseModel(),
			ItemId(src.ItemId),
			VirtualCurrency(src.VirtualCurrency),
			Price(src.Price),
			CatalogVersion(src.CatalogVersion),
			StoreId(src.StoreId),
			CharacterId(src.CharacterId)
			{}
			
		FPurchaseItemRequest(const TSharedPtr<FJsonObject>& obj) : FPurchaseItemRequest()
        {
            readFromValue(obj);
        }
		
		~FPurchaseItemRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPurchaseItemResult : public FPlayFabBaseModel
    {
		
		// [optional] Details for the items purchased.
		TArray<FItemInstance> Items;
	
        FPurchaseItemResult() :
			FPlayFabBaseModel(),
			Items()
			{}
		
		FPurchaseItemResult(const FPurchaseItemResult& src) :
			FPlayFabBaseModel(),
			Items(src.Items)
			{}
			
		FPurchaseItemResult(const TSharedPtr<FJsonObject>& obj) : FPurchaseItemResult()
        {
            readFromValue(obj);
        }
		
		~FPurchaseItemResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRedeemCouponRequest : public FPlayFabBaseModel
    {
		
		// Generated coupon code to redeem.
		FString CouponCode;
		// [optional] Catalog version of the coupon. If null, uses the default catalog
		FString CatalogVersion;
		// [optional] Optional identifier for the Character that should receive the item. If null, item is added to the player
		FString CharacterId;
	
        FRedeemCouponRequest() :
			FPlayFabBaseModel(),
			CouponCode(),
			CatalogVersion(),
			CharacterId()
			{}
		
		FRedeemCouponRequest(const FRedeemCouponRequest& src) :
			FPlayFabBaseModel(),
			CouponCode(src.CouponCode),
			CatalogVersion(src.CatalogVersion),
			CharacterId(src.CharacterId)
			{}
			
		FRedeemCouponRequest(const TSharedPtr<FJsonObject>& obj) : FRedeemCouponRequest()
        {
            readFromValue(obj);
        }
		
		~FRedeemCouponRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRedeemCouponResult : public FPlayFabBaseModel
    {
		
		// [optional] Items granted to the player as a result of redeeming the coupon.
		TArray<FItemInstance> GrantedItems;
	
        FRedeemCouponResult() :
			FPlayFabBaseModel(),
			GrantedItems()
			{}
		
		FRedeemCouponResult(const FRedeemCouponResult& src) :
			FPlayFabBaseModel(),
			GrantedItems(src.GrantedItems)
			{}
			
		FRedeemCouponResult(const TSharedPtr<FJsonObject>& obj) : FRedeemCouponResult()
        {
            readFromValue(obj);
        }
		
		~FRedeemCouponResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRegisterForIOSPushNotificationRequest : public FPlayFabBaseModel
    {
		
		// Unique token generated by the Apple Push Notification service when the title registered to receive push notifications.
		FString DeviceToken;
		// [optional] If true, send a test push message immediately after sucessful registration. Defaults to false.
		OptionalBool SendPushNotificationConfirmation;
		// [optional] Message to display when confirming push notification.
		FString ConfirmationMessage;
	
        FRegisterForIOSPushNotificationRequest() :
			FPlayFabBaseModel(),
			DeviceToken(),
			SendPushNotificationConfirmation(),
			ConfirmationMessage()
			{}
		
		FRegisterForIOSPushNotificationRequest(const FRegisterForIOSPushNotificationRequest& src) :
			FPlayFabBaseModel(),
			DeviceToken(src.DeviceToken),
			SendPushNotificationConfirmation(src.SendPushNotificationConfirmation),
			ConfirmationMessage(src.ConfirmationMessage)
			{}
			
		FRegisterForIOSPushNotificationRequest(const TSharedPtr<FJsonObject>& obj) : FRegisterForIOSPushNotificationRequest()
        {
            readFromValue(obj);
        }
		
		~FRegisterForIOSPushNotificationRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRegisterForIOSPushNotificationResult : public FPlayFabBaseModel
    {
		
	
        FRegisterForIOSPushNotificationResult() :
			FPlayFabBaseModel()
			{}
		
		FRegisterForIOSPushNotificationResult(const FRegisterForIOSPushNotificationResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRegisterForIOSPushNotificationResult(const TSharedPtr<FJsonObject>& obj) : FRegisterForIOSPushNotificationResult()
        {
            readFromValue(obj);
        }
		
		~FRegisterForIOSPushNotificationResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRegisterPlayFabUserRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
		// [optional] PlayFab username for the account (3-20 characters)
		FString Username;
		// [optional] User email address attached to their account
		FString Email;
		// Password for the PlayFab account (6-100 characters)
		FString Password;
		// [optional] An optional parameter that specifies whether both the username and email parameters are required. If true, both parameters are required; if false, the user must supply either the username or email parameter. The default value is true.
		OptionalBool RequireBothUsernameAndEmail;
		// [optional] An optional parameter for setting the display name for this title.
		FString DisplayName;
	
        FRegisterPlayFabUserRequest() :
			FPlayFabBaseModel(),
			TitleId(),
			Username(),
			Email(),
			Password(),
			RequireBothUsernameAndEmail(),
			DisplayName()
			{}
		
		FRegisterPlayFabUserRequest(const FRegisterPlayFabUserRequest& src) :
			FPlayFabBaseModel(),
			TitleId(src.TitleId),
			Username(src.Username),
			Email(src.Email),
			Password(src.Password),
			RequireBothUsernameAndEmail(src.RequireBothUsernameAndEmail),
			DisplayName(src.DisplayName)
			{}
			
		FRegisterPlayFabUserRequest(const TSharedPtr<FJsonObject>& obj) : FRegisterPlayFabUserRequest()
        {
            readFromValue(obj);
        }
		
		~FRegisterPlayFabUserRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRegisterPlayFabUserResult : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier for this newly created account.
		FString PlayFabId;
		// [optional] Unique token identifying the user and game at the server level, for the current session.
		FString SessionTicket;
		// [optional] PlayFab unique user name.
		FString Username;
		// [optional] Settings specific to this user.
		TSharedPtr<FUserSettings> SettingsForUser;
	
        FRegisterPlayFabUserResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			SessionTicket(),
			Username(),
			SettingsForUser(nullptr)
			{}
		
		FRegisterPlayFabUserResult(const FRegisterPlayFabUserResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			SessionTicket(src.SessionTicket),
			Username(src.Username),
			SettingsForUser(src.SettingsForUser.IsValid() ? MakeShareable(new FUserSettings(*src.SettingsForUser)) : nullptr)
			{}
			
		FRegisterPlayFabUserResult(const TSharedPtr<FJsonObject>& obj) : FRegisterPlayFabUserResult()
        {
            readFromValue(obj);
        }
		
		~FRegisterPlayFabUserResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveFriendRequest : public FPlayFabBaseModel
    {
		
		// PlayFab identifier of the friend account which is to be removed.
		FString FriendPlayFabId;
	
        FRemoveFriendRequest() :
			FPlayFabBaseModel(),
			FriendPlayFabId()
			{}
		
		FRemoveFriendRequest(const FRemoveFriendRequest& src) :
			FPlayFabBaseModel(),
			FriendPlayFabId(src.FriendPlayFabId)
			{}
			
		FRemoveFriendRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveFriendRequest()
        {
            readFromValue(obj);
        }
		
		~FRemoveFriendRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveFriendResult : public FPlayFabBaseModel
    {
		
	
        FRemoveFriendResult() :
			FPlayFabBaseModel()
			{}
		
		FRemoveFriendResult(const FRemoveFriendResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRemoveFriendResult(const TSharedPtr<FJsonObject>& obj) : FRemoveFriendResult()
        {
            readFromValue(obj);
        }
		
		~FRemoveFriendResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveGenericIDRequest : public FPlayFabBaseModel
    {
		
		// Generic service identifier to be removed from the player.
		FGenericServiceId GenericId;
	
        FRemoveGenericIDRequest() :
			FPlayFabBaseModel(),
			GenericId()
			{}
		
		FRemoveGenericIDRequest(const FRemoveGenericIDRequest& src) :
			FPlayFabBaseModel(),
			GenericId(src.GenericId)
			{}
			
		FRemoveGenericIDRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveGenericIDRequest()
        {
            readFromValue(obj);
        }
		
		~FRemoveGenericIDRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveGenericIDResult : public FPlayFabBaseModel
    {
		
	
        FRemoveGenericIDResult() :
			FPlayFabBaseModel()
			{}
		
		FRemoveGenericIDResult(const FRemoveGenericIDResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRemoveGenericIDResult(const TSharedPtr<FJsonObject>& obj) : FRemoveGenericIDResult()
        {
            readFromValue(obj);
        }
		
		~FRemoveGenericIDResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveSharedGroupMembersRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the shared group.
		FString SharedGroupId;
		// An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
		TArray<FString> PlayFabIds;
	
        FRemoveSharedGroupMembersRequest() :
			FPlayFabBaseModel(),
			SharedGroupId(),
			PlayFabIds()
			{}
		
		FRemoveSharedGroupMembersRequest(const FRemoveSharedGroupMembersRequest& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId),
			PlayFabIds(src.PlayFabIds)
			{}
			
		FRemoveSharedGroupMembersRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveSharedGroupMembersRequest()
        {
            readFromValue(obj);
        }
		
		~FRemoveSharedGroupMembersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveSharedGroupMembersResult : public FPlayFabBaseModel
    {
		
	
        FRemoveSharedGroupMembersResult() :
			FPlayFabBaseModel()
			{}
		
		FRemoveSharedGroupMembersResult(const FRemoveSharedGroupMembersResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRemoveSharedGroupMembersResult(const TSharedPtr<FJsonObject>& obj) : FRemoveSharedGroupMembersResult()
        {
            readFromValue(obj);
        }
		
		~FRemoveSharedGroupMembersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FReportPlayerClientRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab identifier of the reported player.
		FString ReporteeId;
		// [optional] Optional additional comment by reporting player.
		FString Comment;
	
        FReportPlayerClientRequest() :
			FPlayFabBaseModel(),
			ReporteeId(),
			Comment()
			{}
		
		FReportPlayerClientRequest(const FReportPlayerClientRequest& src) :
			FPlayFabBaseModel(),
			ReporteeId(src.ReporteeId),
			Comment(src.Comment)
			{}
			
		FReportPlayerClientRequest(const TSharedPtr<FJsonObject>& obj) : FReportPlayerClientRequest()
        {
            readFromValue(obj);
        }
		
		~FReportPlayerClientRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FReportPlayerClientResult : public FPlayFabBaseModel
    {
		
		// Indicates whether this action completed successfully.
		bool Updated;
		// The number of remaining reports which may be filed today.
		int32 SubmissionsRemaining;
	
        FReportPlayerClientResult() :
			FPlayFabBaseModel(),
			Updated(false),
			SubmissionsRemaining(0)
			{}
		
		FReportPlayerClientResult(const FReportPlayerClientResult& src) :
			FPlayFabBaseModel(),
			Updated(src.Updated),
			SubmissionsRemaining(src.SubmissionsRemaining)
			{}
			
		FReportPlayerClientResult(const TSharedPtr<FJsonObject>& obj) : FReportPlayerClientResult()
        {
            readFromValue(obj);
        }
		
		~FReportPlayerClientResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRestoreIOSPurchasesRequest : public FPlayFabBaseModel
    {
		
		// Base64 encoded receipt data, passed back by the App Store as a result of a successful purchase.
		FString ReceiptData;
	
        FRestoreIOSPurchasesRequest() :
			FPlayFabBaseModel(),
			ReceiptData()
			{}
		
		FRestoreIOSPurchasesRequest(const FRestoreIOSPurchasesRequest& src) :
			FPlayFabBaseModel(),
			ReceiptData(src.ReceiptData)
			{}
			
		FRestoreIOSPurchasesRequest(const TSharedPtr<FJsonObject>& obj) : FRestoreIOSPurchasesRequest()
        {
            readFromValue(obj);
        }
		
		~FRestoreIOSPurchasesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRestoreIOSPurchasesResult : public FPlayFabBaseModel
    {
		
	
        FRestoreIOSPurchasesResult() :
			FPlayFabBaseModel()
			{}
		
		FRestoreIOSPurchasesResult(const FRestoreIOSPurchasesResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRestoreIOSPurchasesResult(const TSharedPtr<FJsonObject>& obj) : FRestoreIOSPurchasesResult()
        {
            readFromValue(obj);
        }
		
		~FRestoreIOSPurchasesResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSendAccountRecoveryEmailRequest : public FPlayFabBaseModel
    {
		
		// User email address attached to their account
		FString Email;
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
	
        FSendAccountRecoveryEmailRequest() :
			FPlayFabBaseModel(),
			Email(),
			TitleId()
			{}
		
		FSendAccountRecoveryEmailRequest(const FSendAccountRecoveryEmailRequest& src) :
			FPlayFabBaseModel(),
			Email(src.Email),
			TitleId(src.TitleId)
			{}
			
		FSendAccountRecoveryEmailRequest(const TSharedPtr<FJsonObject>& obj) : FSendAccountRecoveryEmailRequest()
        {
            readFromValue(obj);
        }
		
		~FSendAccountRecoveryEmailRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSendAccountRecoveryEmailResult : public FPlayFabBaseModel
    {
		
	
        FSendAccountRecoveryEmailResult() :
			FPlayFabBaseModel()
			{}
		
		FSendAccountRecoveryEmailResult(const FSendAccountRecoveryEmailResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSendAccountRecoveryEmailResult(const TSharedPtr<FJsonObject>& obj) : FSendAccountRecoveryEmailResult()
        {
            readFromValue(obj);
        }
		
		~FSendAccountRecoveryEmailResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetFriendTagsRequest : public FPlayFabBaseModel
    {
		
		// PlayFab identifier of the friend account to which the tag(s) should be applied.
		FString FriendPlayFabId;
		// Array of tags to set on the friend account.
		TArray<FString> Tags;
	
        FSetFriendTagsRequest() :
			FPlayFabBaseModel(),
			FriendPlayFabId(),
			Tags()
			{}
		
		FSetFriendTagsRequest(const FSetFriendTagsRequest& src) :
			FPlayFabBaseModel(),
			FriendPlayFabId(src.FriendPlayFabId),
			Tags(src.Tags)
			{}
			
		FSetFriendTagsRequest(const TSharedPtr<FJsonObject>& obj) : FSetFriendTagsRequest()
        {
            readFromValue(obj);
        }
		
		~FSetFriendTagsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetFriendTagsResult : public FPlayFabBaseModel
    {
		
	
        FSetFriendTagsResult() :
			FPlayFabBaseModel()
			{}
		
		FSetFriendTagsResult(const FSetFriendTagsResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSetFriendTagsResult(const TSharedPtr<FJsonObject>& obj) : FSetFriendTagsResult()
        {
            readFromValue(obj);
        }
		
		~FSetFriendTagsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStartGameRequest : public FPlayFabBaseModel
    {
		
		// version information for the build of the game server which is to be started
		FString BuildVersion;
		// the region to associate this server with for match filtering
		Region pfRegion;
		// the title-defined game mode this server is to be running (defaults to 0 if there is only one mode)
		FString GameMode;
		// [optional] player statistic for others to use in finding this game. May be null for no stat-based matching
		FString StatisticName;
		// [optional] character to use for stats based matching. Leave null to use account stats
		FString CharacterId;
		// [optional] custom command line argument when starting game server process
		FString CustomCommandLineData;
	
        FStartGameRequest() :
			FPlayFabBaseModel(),
			BuildVersion(),
			pfRegion(),
			GameMode(),
			StatisticName(),
			CharacterId(),
			CustomCommandLineData()
			{}
		
		FStartGameRequest(const FStartGameRequest& src) :
			FPlayFabBaseModel(),
			BuildVersion(src.BuildVersion),
			pfRegion(src.pfRegion),
			GameMode(src.GameMode),
			StatisticName(src.StatisticName),
			CharacterId(src.CharacterId),
			CustomCommandLineData(src.CustomCommandLineData)
			{}
			
		FStartGameRequest(const TSharedPtr<FJsonObject>& obj) : FStartGameRequest()
        {
            readFromValue(obj);
        }
		
		~FStartGameRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStartGameResult : public FPlayFabBaseModel
    {
		
		// [optional] unique identifier for the lobby of the server started
		FString LobbyID;
		// [optional] server IP address
		FString ServerHostname;
		// [optional] port on the server to be used for communication
		OptionalInt32 ServerPort;
		// [optional] unique identifier for the server
		FString Ticket;
		// [optional] timestamp for when the server should expire, if applicable
		FString Expires;
		// [optional] password required to log into the server
		FString Password;
	
        FStartGameResult() :
			FPlayFabBaseModel(),
			LobbyID(),
			ServerHostname(),
			ServerPort(),
			Ticket(),
			Expires(),
			Password()
			{}
		
		FStartGameResult(const FStartGameResult& src) :
			FPlayFabBaseModel(),
			LobbyID(src.LobbyID),
			ServerHostname(src.ServerHostname),
			ServerPort(src.ServerPort),
			Ticket(src.Ticket),
			Expires(src.Expires),
			Password(src.Password)
			{}
			
		FStartGameResult(const TSharedPtr<FJsonObject>& obj) : FStartGameResult()
        {
            readFromValue(obj);
        }
		
		~FStartGameResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStartPurchaseRequest : public FPlayFabBaseModel
    {
		
		// [optional] Catalog version for the items to be purchased. Defaults to most recent catalog.
		FString CatalogVersion;
		// [optional] Store through which to purchase items. If not set, prices will be pulled from the catalog itself.
		FString StoreId;
		// Array of items to purchase.
		TArray<FItemPurchaseRequest> Items;
	
        FStartPurchaseRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			StoreId(),
			Items()
			{}
		
		FStartPurchaseRequest(const FStartPurchaseRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			StoreId(src.StoreId),
			Items(src.Items)
			{}
			
		FStartPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FStartPurchaseRequest()
        {
            readFromValue(obj);
        }
		
		~FStartPurchaseRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStartPurchaseResult : public FPlayFabBaseModel
    {
		
		// [optional] Purchase order identifier.
		FString OrderId;
		// [optional] Cart items to be purchased.
		TArray<FCartItem> Contents;
		// [optional] Available methods by which the user can pay.
		TArray<FPaymentOption> PaymentOptions;
		// [optional] Current virtual currency totals for the user.
		TMap<FString, int32> VirtualCurrencyBalances;
	
        FStartPurchaseResult() :
			FPlayFabBaseModel(),
			OrderId(),
			Contents(),
			PaymentOptions(),
			VirtualCurrencyBalances()
			{}
		
		FStartPurchaseResult(const FStartPurchaseResult& src) :
			FPlayFabBaseModel(),
			OrderId(src.OrderId),
			Contents(src.Contents),
			PaymentOptions(src.PaymentOptions),
			VirtualCurrencyBalances(src.VirtualCurrencyBalances)
			{}
			
		FStartPurchaseResult(const TSharedPtr<FJsonObject>& obj) : FStartPurchaseResult()
        {
            readFromValue(obj);
        }
		
		~FStartPurchaseResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStatisticUpdate : public FPlayFabBaseModel
    {
		
		// unique name of the statistic
		FString StatisticName;
		// [optional] for updates to an existing statistic value for a player, the version of the statistic when it was loaded. Null when setting the statistic value for the first time.
		OptionalUint32 Version;
		// statistic value for the player
		int32 Value;
	
        FStatisticUpdate() :
			FPlayFabBaseModel(),
			StatisticName(),
			Version(),
			Value(0)
			{}
		
		FStatisticUpdate(const FStatisticUpdate& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			Version(src.Version),
			Value(src.Value)
			{}
			
		FStatisticUpdate(const TSharedPtr<FJsonObject>& obj) : FStatisticUpdate()
        {
            readFromValue(obj);
        }
		
		~FStatisticUpdate();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSubtractUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
		
		// Name of the virtual currency which is to be decremented.
		FString VirtualCurrency;
		// Amount to be subtracted from the user balance of the specified virtual currency.
		int32 Amount;
	
        FSubtractUserVirtualCurrencyRequest() :
			FPlayFabBaseModel(),
			VirtualCurrency(),
			Amount(0)
			{}
		
		FSubtractUserVirtualCurrencyRequest(const FSubtractUserVirtualCurrencyRequest& src) :
			FPlayFabBaseModel(),
			VirtualCurrency(src.VirtualCurrency),
			Amount(src.Amount)
			{}
			
		FSubtractUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FSubtractUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }
		
		~FSubtractUserVirtualCurrencyRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkAndroidDeviceIDRequest : public FPlayFabBaseModel
    {
		
		// [optional] Android device identifier for the user's device. If not specified, the most recently signed in Android Device ID will be used.
		FString AndroidDeviceId;
	
        FUnlinkAndroidDeviceIDRequest() :
			FPlayFabBaseModel(),
			AndroidDeviceId()
			{}
		
		FUnlinkAndroidDeviceIDRequest(const FUnlinkAndroidDeviceIDRequest& src) :
			FPlayFabBaseModel(),
			AndroidDeviceId(src.AndroidDeviceId)
			{}
			
		FUnlinkAndroidDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkAndroidDeviceIDRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlinkAndroidDeviceIDRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkAndroidDeviceIDResult : public FPlayFabBaseModel
    {
		
	
        FUnlinkAndroidDeviceIDResult() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkAndroidDeviceIDResult(const FUnlinkAndroidDeviceIDResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkAndroidDeviceIDResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkAndroidDeviceIDResult()
        {
            readFromValue(obj);
        }
		
		~FUnlinkAndroidDeviceIDResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkCustomIDRequest : public FPlayFabBaseModel
    {
		
		// [optional] Custom unique identifier for the user, generated by the title. If not specified, the most recently signed in Custom ID will be used.
		FString CustomId;
	
        FUnlinkCustomIDRequest() :
			FPlayFabBaseModel(),
			CustomId()
			{}
		
		FUnlinkCustomIDRequest(const FUnlinkCustomIDRequest& src) :
			FPlayFabBaseModel(),
			CustomId(src.CustomId)
			{}
			
		FUnlinkCustomIDRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkCustomIDRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlinkCustomIDRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkCustomIDResult : public FPlayFabBaseModel
    {
		
	
        FUnlinkCustomIDResult() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkCustomIDResult(const FUnlinkCustomIDResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkCustomIDResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkCustomIDResult()
        {
            readFromValue(obj);
        }
		
		~FUnlinkCustomIDResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkFacebookAccountRequest : public FPlayFabBaseModel
    {
		
	
        FUnlinkFacebookAccountRequest() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkFacebookAccountRequest(const FUnlinkFacebookAccountRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkFacebookAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkFacebookAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlinkFacebookAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkFacebookAccountResult : public FPlayFabBaseModel
    {
		
	
        FUnlinkFacebookAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkFacebookAccountResult(const FUnlinkFacebookAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkFacebookAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkFacebookAccountResult()
        {
            readFromValue(obj);
        }
		
		~FUnlinkFacebookAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkGameCenterAccountRequest : public FPlayFabBaseModel
    {
		
	
        FUnlinkGameCenterAccountRequest() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkGameCenterAccountRequest(const FUnlinkGameCenterAccountRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkGameCenterAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkGameCenterAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlinkGameCenterAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkGameCenterAccountResult : public FPlayFabBaseModel
    {
		
	
        FUnlinkGameCenterAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkGameCenterAccountResult(const FUnlinkGameCenterAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkGameCenterAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkGameCenterAccountResult()
        {
            readFromValue(obj);
        }
		
		~FUnlinkGameCenterAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkGoogleAccountRequest : public FPlayFabBaseModel
    {
		
	
        FUnlinkGoogleAccountRequest() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkGoogleAccountRequest(const FUnlinkGoogleAccountRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkGoogleAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkGoogleAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlinkGoogleAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkGoogleAccountResult : public FPlayFabBaseModel
    {
		
	
        FUnlinkGoogleAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkGoogleAccountResult(const FUnlinkGoogleAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkGoogleAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkGoogleAccountResult()
        {
            readFromValue(obj);
        }
		
		~FUnlinkGoogleAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkIOSDeviceIDRequest : public FPlayFabBaseModel
    {
		
		// [optional] Vendor-specific iOS identifier for the user's device. If not specified, the most recently signed in iOS Device ID will be used.
		FString DeviceId;
	
        FUnlinkIOSDeviceIDRequest() :
			FPlayFabBaseModel(),
			DeviceId()
			{}
		
		FUnlinkIOSDeviceIDRequest(const FUnlinkIOSDeviceIDRequest& src) :
			FPlayFabBaseModel(),
			DeviceId(src.DeviceId)
			{}
			
		FUnlinkIOSDeviceIDRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkIOSDeviceIDRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlinkIOSDeviceIDRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkIOSDeviceIDResult : public FPlayFabBaseModel
    {
		
	
        FUnlinkIOSDeviceIDResult() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkIOSDeviceIDResult(const FUnlinkIOSDeviceIDResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkIOSDeviceIDResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkIOSDeviceIDResult()
        {
            readFromValue(obj);
        }
		
		~FUnlinkIOSDeviceIDResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkKongregateAccountRequest : public FPlayFabBaseModel
    {
		
	
        FUnlinkKongregateAccountRequest() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkKongregateAccountRequest(const FUnlinkKongregateAccountRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkKongregateAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkKongregateAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlinkKongregateAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkKongregateAccountResult : public FPlayFabBaseModel
    {
		
	
        FUnlinkKongregateAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkKongregateAccountResult(const FUnlinkKongregateAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkKongregateAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkKongregateAccountResult()
        {
            readFromValue(obj);
        }
		
		~FUnlinkKongregateAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkSteamAccountRequest : public FPlayFabBaseModel
    {
		
	
        FUnlinkSteamAccountRequest() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkSteamAccountRequest(const FUnlinkSteamAccountRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkSteamAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkSteamAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlinkSteamAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkSteamAccountResult : public FPlayFabBaseModel
    {
		
	
        FUnlinkSteamAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkSteamAccountResult(const FUnlinkSteamAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkSteamAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkSteamAccountResult()
        {
            readFromValue(obj);
        }
		
		~FUnlinkSteamAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkTwitchAccountRequest : public FPlayFabBaseModel
    {
		
	
        FUnlinkTwitchAccountRequest() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkTwitchAccountRequest(const FUnlinkTwitchAccountRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkTwitchAccountRequest(const TSharedPtr<FJsonObject>& obj) : FUnlinkTwitchAccountRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlinkTwitchAccountRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlinkTwitchAccountResult : public FPlayFabBaseModel
    {
		
	
        FUnlinkTwitchAccountResult() :
			FPlayFabBaseModel()
			{}
		
		FUnlinkTwitchAccountResult(const FUnlinkTwitchAccountResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUnlinkTwitchAccountResult(const TSharedPtr<FJsonObject>& obj) : FUnlinkTwitchAccountResult()
        {
            readFromValue(obj);
        }
		
		~FUnlinkTwitchAccountResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlockContainerInstanceRequest : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// ItemInstanceId of the container to unlock.
		FString ContainerItemInstanceId;
		// [optional] ItemInstanceId of the key that will be consumed by unlocking this container.  If the container requires a key, this parameter is required.
		FString KeyItemInstanceId;
		// [optional] Specifies the catalog version that should be used to determine container contents.  If unspecified, uses catalog associated with the item instance.
		FString CatalogVersion;
	
        FUnlockContainerInstanceRequest() :
			FPlayFabBaseModel(),
			CharacterId(),
			ContainerItemInstanceId(),
			KeyItemInstanceId(),
			CatalogVersion()
			{}
		
		FUnlockContainerInstanceRequest(const FUnlockContainerInstanceRequest& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			ContainerItemInstanceId(src.ContainerItemInstanceId),
			KeyItemInstanceId(src.KeyItemInstanceId),
			CatalogVersion(src.CatalogVersion)
			{}
			
		FUnlockContainerInstanceRequest(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerInstanceRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlockContainerInstanceRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlockContainerItemRequest : public FPlayFabBaseModel
    {
		
		// Catalog ItemId of the container type to unlock.
		FString ContainerItemId;
		// [optional] Specifies the catalog version that should be used to determine container contents.  If unspecified, uses default/primary catalog.
		FString CatalogVersion;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
	
        FUnlockContainerItemRequest() :
			FPlayFabBaseModel(),
			ContainerItemId(),
			CatalogVersion(),
			CharacterId()
			{}
		
		FUnlockContainerItemRequest(const FUnlockContainerItemRequest& src) :
			FPlayFabBaseModel(),
			ContainerItemId(src.ContainerItemId),
			CatalogVersion(src.CatalogVersion),
			CharacterId(src.CharacterId)
			{}
			
		FUnlockContainerItemRequest(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerItemRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlockContainerItemRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlockContainerItemResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique instance identifier of the container unlocked.
		FString UnlockedItemInstanceId;
		// [optional] Unique instance identifier of the key used to unlock the container, if applicable.
		FString UnlockedWithItemInstanceId;
		// [optional] Items granted to the player as a result of unlocking the container.
		TArray<FItemInstance> GrantedItems;
		// [optional] Virtual currency granted to the player as a result of unlocking the container.
		TMap<FString, uint32> VirtualCurrency;
	
        FUnlockContainerItemResult() :
			FPlayFabBaseModel(),
			UnlockedItemInstanceId(),
			UnlockedWithItemInstanceId(),
			GrantedItems(),
			VirtualCurrency()
			{}
		
		FUnlockContainerItemResult(const FUnlockContainerItemResult& src) :
			FPlayFabBaseModel(),
			UnlockedItemInstanceId(src.UnlockedItemInstanceId),
			UnlockedWithItemInstanceId(src.UnlockedWithItemInstanceId),
			GrantedItems(src.GrantedItems),
			VirtualCurrency(src.VirtualCurrency)
			{}
			
		FUnlockContainerItemResult(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerItemResult()
        {
            readFromValue(obj);
        }
		
		~FUnlockContainerItemResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCharacterDataRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
		// [optional] Permission to be applied to all user data keys written in this request. Defaults to "private" if not set.
		Boxed<UserDataPermission> Permission;
	
        FUpdateCharacterDataRequest() :
			FPlayFabBaseModel(),
			CharacterId(),
			Data(),
			KeysToRemove(),
			Permission()
			{}
		
		FUpdateCharacterDataRequest(const FUpdateCharacterDataRequest& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove),
			Permission(src.Permission)
			{}
			
		FUpdateCharacterDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterDataRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateCharacterDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCharacterDataResult : public FPlayFabBaseModel
    {
		
		// Indicates the current version of the data that has been set. This is incremented with every set call for that type of data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
		uint32 DataVersion;
	
        FUpdateCharacterDataResult() :
			FPlayFabBaseModel(),
			DataVersion(0)
			{}
		
		FUpdateCharacterDataResult(const FUpdateCharacterDataResult& src) :
			FPlayFabBaseModel(),
			DataVersion(src.DataVersion)
			{}
			
		FUpdateCharacterDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterDataResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateCharacterDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCharacterStatisticsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Statistics to be updated with the provided values.
		TMap<FString, int32> CharacterStatistics;
	
        FUpdateCharacterStatisticsRequest() :
			FPlayFabBaseModel(),
			CharacterId(),
			CharacterStatistics()
			{}
		
		FUpdateCharacterStatisticsRequest(const FUpdateCharacterStatisticsRequest& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			CharacterStatistics(src.CharacterStatistics)
			{}
			
		FUpdateCharacterStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterStatisticsRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateCharacterStatisticsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCharacterStatisticsResult : public FPlayFabBaseModel
    {
		
	
        FUpdateCharacterStatisticsResult() :
			FPlayFabBaseModel()
			{}
		
		FUpdateCharacterStatisticsResult(const FUpdateCharacterStatisticsResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUpdateCharacterStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterStatisticsResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateCharacterStatisticsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdatePlayerStatisticsRequest : public FPlayFabBaseModel
    {
		
		// Statistics to be updated with the provided values
		TArray<FStatisticUpdate> Statistics;
	
        FUpdatePlayerStatisticsRequest() :
			FPlayFabBaseModel(),
			Statistics()
			{}
		
		FUpdatePlayerStatisticsRequest(const FUpdatePlayerStatisticsRequest& src) :
			FPlayFabBaseModel(),
			Statistics(src.Statistics)
			{}
			
		FUpdatePlayerStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticsRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdatePlayerStatisticsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdatePlayerStatisticsResult : public FPlayFabBaseModel
    {
		
	
        FUpdatePlayerStatisticsResult() :
			FPlayFabBaseModel()
			{}
		
		FUpdatePlayerStatisticsResult(const FUpdatePlayerStatisticsResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUpdatePlayerStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticsResult()
        {
            readFromValue(obj);
        }
		
		~FUpdatePlayerStatisticsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateSharedGroupDataRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the shared group.
		FString SharedGroupId;
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
		// [optional] Permission to be applied to all user data keys in this request.
		Boxed<UserDataPermission> Permission;
	
        FUpdateSharedGroupDataRequest() :
			FPlayFabBaseModel(),
			SharedGroupId(),
			Data(),
			KeysToRemove(),
			Permission()
			{}
		
		FUpdateSharedGroupDataRequest(const FUpdateSharedGroupDataRequest& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove),
			Permission(src.Permission)
			{}
			
		FUpdateSharedGroupDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateSharedGroupDataRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateSharedGroupDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateSharedGroupDataResult : public FPlayFabBaseModel
    {
		
	
        FUpdateSharedGroupDataResult() :
			FPlayFabBaseModel()
			{}
		
		FUpdateSharedGroupDataResult(const FUpdateSharedGroupDataResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUpdateSharedGroupDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateSharedGroupDataResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateSharedGroupDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserDataRequest : public FPlayFabBaseModel
    {
		
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
		// [optional] Permission to be applied to all user data keys written in this request. Defaults to "private" if not set. This is used for requests by one player for information about another player; those requests will only return Public keys.
		Boxed<UserDataPermission> Permission;
	
        FUpdateUserDataRequest() :
			FPlayFabBaseModel(),
			Data(),
			KeysToRemove(),
			Permission()
			{}
		
		FUpdateUserDataRequest(const FUpdateUserDataRequest& src) :
			FPlayFabBaseModel(),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove),
			Permission(src.Permission)
			{}
			
		FUpdateUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserDataResult : public FPlayFabBaseModel
    {
		
		// Indicates the current version of the data that has been set. This is incremented with every set call for that type of data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
		uint32 DataVersion;
	
        FUpdateUserDataResult() :
			FPlayFabBaseModel(),
			DataVersion(0)
			{}
		
		FUpdateUserDataResult(const FUpdateUserDataResult& src) :
			FPlayFabBaseModel(),
			DataVersion(src.DataVersion)
			{}
			
		FUpdateUserDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserTitleDisplayNameRequest : public FPlayFabBaseModel
    {
		
		// New title display name for the user - must be between 3 and 25 characters.
		FString DisplayName;
	
        FUpdateUserTitleDisplayNameRequest() :
			FPlayFabBaseModel(),
			DisplayName()
			{}
		
		FUpdateUserTitleDisplayNameRequest(const FUpdateUserTitleDisplayNameRequest& src) :
			FPlayFabBaseModel(),
			DisplayName(src.DisplayName)
			{}
			
		FUpdateUserTitleDisplayNameRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserTitleDisplayNameRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserTitleDisplayNameRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserTitleDisplayNameResult : public FPlayFabBaseModel
    {
		
		// [optional] Current title display name for the user (this will be the original display name if the rename attempt failed).
		FString DisplayName;
	
        FUpdateUserTitleDisplayNameResult() :
			FPlayFabBaseModel(),
			DisplayName()
			{}
		
		FUpdateUserTitleDisplayNameResult(const FUpdateUserTitleDisplayNameResult& src) :
			FPlayFabBaseModel(),
			DisplayName(src.DisplayName)
			{}
			
		FUpdateUserTitleDisplayNameResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserTitleDisplayNameResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserTitleDisplayNameResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FValidateAmazonReceiptRequest : public FPlayFabBaseModel
    {
		
		// ReceiptId returned by the Amazon App Store in-app purchase API
		FString ReceiptId;
		// AmazonId of the user making the purchase as returned by the Amazon App Store in-app purchase API
		FString UserId;
		// [optional] Catalog version to use when granting receipt item. If null, defaults to primary catalog.
		FString CatalogVersion;
		// Currency used for the purchase.
		FString CurrencyCode;
		// Amount of the stated currency paid for the object.
		int32 PurchasePrice;
	
        FValidateAmazonReceiptRequest() :
			FPlayFabBaseModel(),
			ReceiptId(),
			UserId(),
			CatalogVersion(),
			CurrencyCode(),
			PurchasePrice(0)
			{}
		
		FValidateAmazonReceiptRequest(const FValidateAmazonReceiptRequest& src) :
			FPlayFabBaseModel(),
			ReceiptId(src.ReceiptId),
			UserId(src.UserId),
			CatalogVersion(src.CatalogVersion),
			CurrencyCode(src.CurrencyCode),
			PurchasePrice(src.PurchasePrice)
			{}
			
		FValidateAmazonReceiptRequest(const TSharedPtr<FJsonObject>& obj) : FValidateAmazonReceiptRequest()
        {
            readFromValue(obj);
        }
		
		~FValidateAmazonReceiptRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FValidateAmazonReceiptResult : public FPlayFabBaseModel
    {
		
	
        FValidateAmazonReceiptResult() :
			FPlayFabBaseModel()
			{}
		
		FValidateAmazonReceiptResult(const FValidateAmazonReceiptResult& src) :
			FPlayFabBaseModel()
			{}
			
		FValidateAmazonReceiptResult(const TSharedPtr<FJsonObject>& obj) : FValidateAmazonReceiptResult()
        {
            readFromValue(obj);
        }
		
		~FValidateAmazonReceiptResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FValidateGooglePlayPurchaseRequest : public FPlayFabBaseModel
    {
		
		// Original JSON string returned by the Google Play IAB API.
		FString ReceiptJson;
		// Signature returned by the Google Play IAB API.
		FString Signature;
		// [optional] Currency used for the purchase.
		FString CurrencyCode;
		// [optional] Amount of the stated currency paid for the object.
		OptionalUint32 PurchasePrice;
	
        FValidateGooglePlayPurchaseRequest() :
			FPlayFabBaseModel(),
			ReceiptJson(),
			Signature(),
			CurrencyCode(),
			PurchasePrice()
			{}
		
		FValidateGooglePlayPurchaseRequest(const FValidateGooglePlayPurchaseRequest& src) :
			FPlayFabBaseModel(),
			ReceiptJson(src.ReceiptJson),
			Signature(src.Signature),
			CurrencyCode(src.CurrencyCode),
			PurchasePrice(src.PurchasePrice)
			{}
			
		FValidateGooglePlayPurchaseRequest(const TSharedPtr<FJsonObject>& obj) : FValidateGooglePlayPurchaseRequest()
        {
            readFromValue(obj);
        }
		
		~FValidateGooglePlayPurchaseRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FValidateGooglePlayPurchaseResult : public FPlayFabBaseModel
    {
		
	
        FValidateGooglePlayPurchaseResult() :
			FPlayFabBaseModel()
			{}
		
		FValidateGooglePlayPurchaseResult(const FValidateGooglePlayPurchaseResult& src) :
			FPlayFabBaseModel()
			{}
			
		FValidateGooglePlayPurchaseResult(const TSharedPtr<FJsonObject>& obj) : FValidateGooglePlayPurchaseResult()
        {
            readFromValue(obj);
        }
		
		~FValidateGooglePlayPurchaseResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FValidateIOSReceiptRequest : public FPlayFabBaseModel
    {
		
		// Base64 encoded receipt data, passed back by the App Store as a result of a successful purchase.
		FString ReceiptData;
		// Currency used for the purchase.
		FString CurrencyCode;
		// Amount of the stated currency paid for the object.
		int32 PurchasePrice;
	
        FValidateIOSReceiptRequest() :
			FPlayFabBaseModel(),
			ReceiptData(),
			CurrencyCode(),
			PurchasePrice(0)
			{}
		
		FValidateIOSReceiptRequest(const FValidateIOSReceiptRequest& src) :
			FPlayFabBaseModel(),
			ReceiptData(src.ReceiptData),
			CurrencyCode(src.CurrencyCode),
			PurchasePrice(src.PurchasePrice)
			{}
			
		FValidateIOSReceiptRequest(const TSharedPtr<FJsonObject>& obj) : FValidateIOSReceiptRequest()
        {
            readFromValue(obj);
        }
		
		~FValidateIOSReceiptRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FValidateIOSReceiptResult : public FPlayFabBaseModel
    {
		
	
        FValidateIOSReceiptResult() :
			FPlayFabBaseModel()
			{}
		
		FValidateIOSReceiptResult(const FValidateIOSReceiptResult& src) :
			FPlayFabBaseModel()
			{}
			
		FValidateIOSReceiptResult(const TSharedPtr<FJsonObject>& obj) : FValidateIOSReceiptResult()
        {
            readFromValue(obj);
        }
		
		~FValidateIOSReceiptResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FWriteClientCharacterEventRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it commonly follows the subject_verb_object pattern (e.g. player_logged_in).
		FString EventName;
		// [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
		OptionalTime Timestamp;
		// [optional] Custom event properties. Each property consists of a name (string) and a value (JSON object).
		TMap<FString, FMultitypeVar> Body;
	
        FWriteClientCharacterEventRequest() :
			FPlayFabBaseModel(),
			CharacterId(),
			EventName(),
			Timestamp(),
			Body()
			{}
		
		FWriteClientCharacterEventRequest(const FWriteClientCharacterEventRequest& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			EventName(src.EventName),
			Timestamp(src.Timestamp),
			Body(src.Body)
			{}
			
		FWriteClientCharacterEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteClientCharacterEventRequest()
        {
            readFromValue(obj);
        }
		
		~FWriteClientCharacterEventRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FWriteClientPlayerEventRequest : public FPlayFabBaseModel
    {
		
		// The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it commonly follows the subject_verb_object pattern (e.g. player_logged_in).
		FString EventName;
		// [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
		OptionalTime Timestamp;
		// [optional] Custom data properties associated with the event. Each property consists of a name (string) and a value (JSON object).
		TMap<FString, FMultitypeVar> Body;
	
        FWriteClientPlayerEventRequest() :
			FPlayFabBaseModel(),
			EventName(),
			Timestamp(),
			Body()
			{}
		
		FWriteClientPlayerEventRequest(const FWriteClientPlayerEventRequest& src) :
			FPlayFabBaseModel(),
			EventName(src.EventName),
			Timestamp(src.Timestamp),
			Body(src.Body)
			{}
			
		FWriteClientPlayerEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteClientPlayerEventRequest()
        {
            readFromValue(obj);
        }
		
		~FWriteClientPlayerEventRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FWriteEventResponse : public FPlayFabBaseModel
    {
		
		// [optional] The unique identifier of the event. The values of this identifier consist of ASCII characters and are not constrained to any particular format.
		FString EventId;
	
        FWriteEventResponse() :
			FPlayFabBaseModel(),
			EventId()
			{}
		
		FWriteEventResponse(const FWriteEventResponse& src) :
			FPlayFabBaseModel(),
			EventId(src.EventId)
			{}
			
		FWriteEventResponse(const TSharedPtr<FJsonObject>& obj) : FWriteEventResponse()
        {
            readFromValue(obj);
        }
		
		~FWriteEventResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FWriteTitleEventRequest : public FPlayFabBaseModel
    {
		
		// The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it commonly follows the subject_verb_object pattern (e.g. player_logged_in).
		FString EventName;
		// [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
		OptionalTime Timestamp;
		// [optional] Custom event properties. Each property consists of a name (string) and a value (JSON object).
		TMap<FString, FMultitypeVar> Body;
	
        FWriteTitleEventRequest() :
			FPlayFabBaseModel(),
			EventName(),
			Timestamp(),
			Body()
			{}
		
		FWriteTitleEventRequest(const FWriteTitleEventRequest& src) :
			FPlayFabBaseModel(),
			EventName(src.EventName),
			Timestamp(src.Timestamp),
			Body(src.Body)
			{}
			
		FWriteTitleEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteTitleEventRequest()
        {
            readFromValue(obj);
        }
		
		~FWriteTitleEventRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	

}
}

