// This is automatically generated by PlayFab SDKGenerator. DO NOT modify this manually!
#pragma once

#include "Core/PlayFabBaseModel.h"

namespace PlayFab
{
namespace ServerModels
{

	
	struct PLAYFAB_API FNameIdentifier : public FPlayFabBaseModel
    {
		
		// [optional] undefined
		FString Name;
		// [optional] undefined
		FString Id;
	
        FNameIdentifier() :
			FPlayFabBaseModel(),
			Name(),
			Id()
			{}
		
		FNameIdentifier(const FNameIdentifier& src) :
			FPlayFabBaseModel(),
			Name(src.Name),
			Id(src.Id)
			{}
			
		FNameIdentifier(const TSharedPtr<FJsonObject>& obj) : FNameIdentifier()
        {
            readFromValue(obj);
        }
		
		~FNameIdentifier();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum TaskInstanceStatus
	{
		TaskInstanceStatusSucceeded,
		TaskInstanceStatusStarting,
		TaskInstanceStatusInProgress,
		TaskInstanceStatusFailed,
		TaskInstanceStatusAborted,
		TaskInstanceStatusPending
	};
	
	void writeTaskInstanceStatusEnumJSON(TaskInstanceStatus enumVal, JsonWriter& writer);
	TaskInstanceStatus readTaskInstanceStatusFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FActionsOnPlayersInSegmentTaskSummary : public FPlayFabBaseModel
    {
		
		// [optional] ID of the task instance.
		FString TaskInstanceId;
		// [optional] Identifier of the task this instance belongs to.
		TSharedPtr<FNameIdentifier> TaskIdentifier;
		// UTC timestamp when the task started.
		FDateTime StartedAt;
		// [optional] UTC timestamp when the task completed.
		OptionalTime CompletedAt;
		// [optional] Current status of the task instance.
		Boxed<TaskInstanceStatus> Status;
		// [optional] Progress represented as percentage.
		OptionalDouble PercentComplete;
		// [optional] Estimated time remaining in seconds.
		OptionalDouble EstimatedSecondsRemaining;
		// [optional] If manually scheduled, ID of user who scheduled the task.
		FString ScheduledByUserId;
		// [optional] Error message for last processing attempt, if an error occured.
		FString ErrorMessage;
		// [optional] Flag indicating if the error was fatal, if false job will be retried.
		OptionalBool ErrorWasFatal;
		// [optional] Total players in segment when task was started.
		OptionalInt32 TotalPlayersInSegment;
		// [optional] Total number of players that have had the actions applied to.
		OptionalInt32 TotalPlayersProcessed;
	
        FActionsOnPlayersInSegmentTaskSummary() :
			FPlayFabBaseModel(),
			TaskInstanceId(),
			TaskIdentifier(nullptr),
			StartedAt(0),
			CompletedAt(),
			Status(),
			PercentComplete(),
			EstimatedSecondsRemaining(),
			ScheduledByUserId(),
			ErrorMessage(),
			ErrorWasFatal(),
			TotalPlayersInSegment(),
			TotalPlayersProcessed()
			{}
		
		FActionsOnPlayersInSegmentTaskSummary(const FActionsOnPlayersInSegmentTaskSummary& src) :
			FPlayFabBaseModel(),
			TaskInstanceId(src.TaskInstanceId),
			TaskIdentifier(src.TaskIdentifier.IsValid() ? MakeShareable(new FNameIdentifier(*src.TaskIdentifier)) : nullptr),
			StartedAt(src.StartedAt),
			CompletedAt(src.CompletedAt),
			Status(src.Status),
			PercentComplete(src.PercentComplete),
			EstimatedSecondsRemaining(src.EstimatedSecondsRemaining),
			ScheduledByUserId(src.ScheduledByUserId),
			ErrorMessage(src.ErrorMessage),
			ErrorWasFatal(src.ErrorWasFatal),
			TotalPlayersInSegment(src.TotalPlayersInSegment),
			TotalPlayersProcessed(src.TotalPlayersProcessed)
			{}
			
		FActionsOnPlayersInSegmentTaskSummary(const TSharedPtr<FJsonObject>& obj) : FActionsOnPlayersInSegmentTaskSummary()
        {
            readFromValue(obj);
        }
		
		~FActionsOnPlayersInSegmentTaskSummary();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAdCampaignAttribution : public FPlayFabBaseModel
    {
		
		// [optional] Attribution network name
		FString Platform;
		// [optional] Attribution campaign identifier
		FString CampaignId;
		// UTC time stamp of attribution
		FDateTime AttributedAt;
	
        FAdCampaignAttribution() :
			FPlayFabBaseModel(),
			Platform(),
			CampaignId(),
			AttributedAt(0)
			{}
		
		FAdCampaignAttribution(const FAdCampaignAttribution& src) :
			FPlayFabBaseModel(),
			Platform(src.Platform),
			CampaignId(src.CampaignId),
			AttributedAt(src.AttributedAt)
			{}
			
		FAdCampaignAttribution(const TSharedPtr<FJsonObject>& obj) : FAdCampaignAttribution()
        {
            readFromValue(obj);
        }
		
		~FAdCampaignAttribution();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddCharacterVirtualCurrencyRequest : public FPlayFabBaseModel
    {
		
		// PlayFab unique identifier of the user whose virtual currency balance is to be incremented.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// Name of the virtual currency which is to be incremented.
		FString VirtualCurrency;
		// Amount to be added to the character balance of the specified virtual currency. Maximum VC balance is Int32 (2,147,483,647). Any increase over this value will be discarded.
		int32 Amount;
	
        FAddCharacterVirtualCurrencyRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			VirtualCurrency(),
			Amount(0)
			{}
		
		FAddCharacterVirtualCurrencyRequest(const FAddCharacterVirtualCurrencyRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			VirtualCurrency(src.VirtualCurrency),
			Amount(src.Amount)
			{}
			
		FAddCharacterVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FAddCharacterVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }
		
		~FAddCharacterVirtualCurrencyRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddFriendRequest : public FPlayFabBaseModel
    {
		
		// PlayFab identifier of the player to add a new friend.
		FString PlayFabId;
		// [optional] The PlayFab identifier of the user being added.
		FString FriendPlayFabId;
		// [optional] The PlayFab username of the user being added
		FString FriendUsername;
		// [optional] Email address of the user being added.
		FString FriendEmail;
		// [optional] Title-specific display name of the user to being added.
		FString FriendTitleDisplayName;
	
        FAddFriendRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			FriendPlayFabId(),
			FriendUsername(),
			FriendEmail(),
			FriendTitleDisplayName()
			{}
		
		FAddFriendRequest(const FAddFriendRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			FriendPlayFabId(src.FriendPlayFabId),
			FriendUsername(src.FriendUsername),
			FriendEmail(src.FriendEmail),
			FriendTitleDisplayName(src.FriendTitleDisplayName)
			{}
			
		FAddFriendRequest(const TSharedPtr<FJsonObject>& obj) : FAddFriendRequest()
        {
            readFromValue(obj);
        }
		
		~FAddFriendRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddPlayerTagRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique tag for player profile.
		FString TagName;
	
        FAddPlayerTagRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			TagName()
			{}
		
		FAddPlayerTagRequest(const FAddPlayerTagRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			TagName(src.TagName)
			{}
			
		FAddPlayerTagRequest(const TSharedPtr<FJsonObject>& obj) : FAddPlayerTagRequest()
        {
            readFromValue(obj);
        }
		
		~FAddPlayerTagRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddPlayerTagResult : public FPlayFabBaseModel
    {
		
	
        FAddPlayerTagResult() :
			FPlayFabBaseModel()
			{}
		
		FAddPlayerTagResult(const FAddPlayerTagResult& src) :
			FPlayFabBaseModel()
			{}
			
		FAddPlayerTagResult(const TSharedPtr<FJsonObject>& obj) : FAddPlayerTagResult()
        {
            readFromValue(obj);
        }
		
		~FAddPlayerTagResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddSharedGroupMembersRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the shared group.
		FString SharedGroupId;
		// An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
		TArray<FString> PlayFabIds;
	
        FAddSharedGroupMembersRequest() :
			FPlayFabBaseModel(),
			SharedGroupId(),
			PlayFabIds()
			{}
		
		FAddSharedGroupMembersRequest(const FAddSharedGroupMembersRequest& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId),
			PlayFabIds(src.PlayFabIds)
			{}
			
		FAddSharedGroupMembersRequest(const TSharedPtr<FJsonObject>& obj) : FAddSharedGroupMembersRequest()
        {
            readFromValue(obj);
        }
		
		~FAddSharedGroupMembersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddSharedGroupMembersResult : public FPlayFabBaseModel
    {
		
	
        FAddSharedGroupMembersResult() :
			FPlayFabBaseModel()
			{}
		
		FAddSharedGroupMembersResult(const FAddSharedGroupMembersResult& src) :
			FPlayFabBaseModel()
			{}
			
		FAddSharedGroupMembersResult(const TSharedPtr<FJsonObject>& obj) : FAddSharedGroupMembersResult()
        {
            readFromValue(obj);
        }
		
		~FAddSharedGroupMembersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAddUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
		
		// PlayFab unique identifier of the user whose virtual currency balance is to be increased.
		FString PlayFabId;
		// Name of the virtual currency which is to be incremented.
		FString VirtualCurrency;
		// Amount to be added to the user balance of the specified virtual currency. Maximum VC balance is Int32 (2,147,483,647). Any increase over this value will be discarded.
		int32 Amount;
	
        FAddUserVirtualCurrencyRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			VirtualCurrency(),
			Amount(0)
			{}
		
		FAddUserVirtualCurrencyRequest(const FAddUserVirtualCurrencyRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			VirtualCurrency(src.VirtualCurrency),
			Amount(src.Amount)
			{}
			
		FAddUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FAddUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }
		
		~FAddUserVirtualCurrencyRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAuthenticateSessionTicketRequest : public FPlayFabBaseModel
    {
		
		// Session ticket as issued by a PlayFab client login API.
		FString SessionTicket;
	
        FAuthenticateSessionTicketRequest() :
			FPlayFabBaseModel(),
			SessionTicket()
			{}
		
		FAuthenticateSessionTicketRequest(const FAuthenticateSessionTicketRequest& src) :
			FPlayFabBaseModel(),
			SessionTicket(src.SessionTicket)
			{}
			
		FAuthenticateSessionTicketRequest(const TSharedPtr<FJsonObject>& obj) : FAuthenticateSessionTicketRequest()
        {
            readFromValue(obj);
        }
		
		~FAuthenticateSessionTicketRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum UserOrigination
	{
		UserOriginationOrganic,
		UserOriginationSteam,
		UserOriginationGoogle,
		UserOriginationAmazon,
		UserOriginationFacebook,
		UserOriginationKongregate,
		UserOriginationGamersFirst,
		UserOriginationUnknown,
		UserOriginationIOS,
		UserOriginationLoadTest,
		UserOriginationAndroid,
		UserOriginationPSN,
		UserOriginationGameCenter,
		UserOriginationCustomId,
		UserOriginationXboxLive,
		UserOriginationParse,
		UserOriginationTwitch
	};
	
	void writeUserOriginationEnumJSON(UserOrigination enumVal, JsonWriter& writer);
	UserOrigination readUserOriginationFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FUserTitleInfo : public FPlayFabBaseModel
    {
		
		// [optional] name of the user, as it is displayed in-game
		FString DisplayName;
		// [optional] source by which the user first joined the game, if known
		Boxed<UserOrigination> Origination;
		// timestamp indicating when the user was first associated with this game (this can differ significantly from when the user first registered with PlayFab)
		FDateTime Created;
		// [optional] timestamp for the last user login for this title
		OptionalTime LastLogin;
		// [optional] timestamp indicating when the user first signed into this game (this can differ from the Created timestamp, as other events, such as issuing a beta key to the user, can associate the title to the user)
		OptionalTime FirstLogin;
		// [optional] boolean indicating whether or not the user is currently banned for a title
		OptionalBool isBanned;
	
        FUserTitleInfo() :
			FPlayFabBaseModel(),
			DisplayName(),
			Origination(),
			Created(0),
			LastLogin(),
			FirstLogin(),
			isBanned()
			{}
		
		FUserTitleInfo(const FUserTitleInfo& src) :
			FPlayFabBaseModel(),
			DisplayName(src.DisplayName),
			Origination(src.Origination),
			Created(src.Created),
			LastLogin(src.LastLogin),
			FirstLogin(src.FirstLogin),
			isBanned(src.isBanned)
			{}
			
		FUserTitleInfo(const TSharedPtr<FJsonObject>& obj) : FUserTitleInfo()
        {
            readFromValue(obj);
        }
		
		~FUserTitleInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserPrivateAccountInfo : public FPlayFabBaseModel
    {
		
		// [optional] user email address
		FString Email;
	
        FUserPrivateAccountInfo() :
			FPlayFabBaseModel(),
			Email()
			{}
		
		FUserPrivateAccountInfo(const FUserPrivateAccountInfo& src) :
			FPlayFabBaseModel(),
			Email(src.Email)
			{}
			
		FUserPrivateAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserPrivateAccountInfo()
        {
            readFromValue(obj);
        }
		
		~FUserPrivateAccountInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserFacebookInfo : public FPlayFabBaseModel
    {
		
		// [optional] Facebook identifier
		FString FacebookId;
		// [optional] Facebook full name
		FString FullName;
	
        FUserFacebookInfo() :
			FPlayFabBaseModel(),
			FacebookId(),
			FullName()
			{}
		
		FUserFacebookInfo(const FUserFacebookInfo& src) :
			FPlayFabBaseModel(),
			FacebookId(src.FacebookId),
			FullName(src.FullName)
			{}
			
		FUserFacebookInfo(const TSharedPtr<FJsonObject>& obj) : FUserFacebookInfo()
        {
            readFromValue(obj);
        }
		
		~FUserFacebookInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum Currency
	{
		CurrencyAED,
		CurrencyAFN,
		CurrencyALL,
		CurrencyAMD,
		CurrencyANG,
		CurrencyAOA,
		CurrencyARS,
		CurrencyAUD,
		CurrencyAWG,
		CurrencyAZN,
		CurrencyBAM,
		CurrencyBBD,
		CurrencyBDT,
		CurrencyBGN,
		CurrencyBHD,
		CurrencyBIF,
		CurrencyBMD,
		CurrencyBND,
		CurrencyBOB,
		CurrencyBRL,
		CurrencyBSD,
		CurrencyBTN,
		CurrencyBWP,
		CurrencyBYR,
		CurrencyBZD,
		CurrencyCAD,
		CurrencyCDF,
		CurrencyCHF,
		CurrencyCLP,
		CurrencyCNY,
		CurrencyCOP,
		CurrencyCRC,
		CurrencyCUC,
		CurrencyCUP,
		CurrencyCVE,
		CurrencyCZK,
		CurrencyDJF,
		CurrencyDKK,
		CurrencyDOP,
		CurrencyDZD,
		CurrencyEGP,
		CurrencyERN,
		CurrencyETB,
		CurrencyEUR,
		CurrencyFJD,
		CurrencyFKP,
		CurrencyGBP,
		CurrencyGEL,
		CurrencyGGP,
		CurrencyGHS,
		CurrencyGIP,
		CurrencyGMD,
		CurrencyGNF,
		CurrencyGTQ,
		CurrencyGYD,
		CurrencyHKD,
		CurrencyHNL,
		CurrencyHRK,
		CurrencyHTG,
		CurrencyHUF,
		CurrencyIDR,
		CurrencyILS,
		CurrencyIMP,
		CurrencyINR,
		CurrencyIQD,
		CurrencyIRR,
		CurrencyISK,
		CurrencyJEP,
		CurrencyJMD,
		CurrencyJOD,
		CurrencyJPY,
		CurrencyKES,
		CurrencyKGS,
		CurrencyKHR,
		CurrencyKMF,
		CurrencyKPW,
		CurrencyKRW,
		CurrencyKWD,
		CurrencyKYD,
		CurrencyKZT,
		CurrencyLAK,
		CurrencyLBP,
		CurrencyLKR,
		CurrencyLRD,
		CurrencyLSL,
		CurrencyLYD,
		CurrencyMAD,
		CurrencyMDL,
		CurrencyMGA,
		CurrencyMKD,
		CurrencyMMK,
		CurrencyMNT,
		CurrencyMOP,
		CurrencyMRO,
		CurrencyMUR,
		CurrencyMVR,
		CurrencyMWK,
		CurrencyMXN,
		CurrencyMYR,
		CurrencyMZN,
		CurrencyNAD,
		CurrencyNGN,
		CurrencyNIO,
		CurrencyNOK,
		CurrencyNPR,
		CurrencyNZD,
		CurrencyOMR,
		CurrencyPAB,
		CurrencyPEN,
		CurrencyPGK,
		CurrencyPHP,
		CurrencyPKR,
		CurrencyPLN,
		CurrencyPYG,
		CurrencyQAR,
		CurrencyRON,
		CurrencyRSD,
		CurrencyRUB,
		CurrencyRWF,
		CurrencySAR,
		CurrencySBD,
		CurrencySCR,
		CurrencySDG,
		CurrencySEK,
		CurrencySGD,
		CurrencySHP,
		CurrencySLL,
		CurrencySOS,
		CurrencySPL,
		CurrencySRD,
		CurrencySTD,
		CurrencySVC,
		CurrencySYP,
		CurrencySZL,
		CurrencyTHB,
		CurrencyTJS,
		CurrencyTMT,
		CurrencyTND,
		CurrencyTOP,
		CurrencyTRY,
		CurrencyTTD,
		CurrencyTVD,
		CurrencyTWD,
		CurrencyTZS,
		CurrencyUAH,
		CurrencyUGX,
		CurrencyUSD,
		CurrencyUYU,
		CurrencyUZS,
		CurrencyVEF,
		CurrencyVND,
		CurrencyVUV,
		CurrencyWST,
		CurrencyXAF,
		CurrencyXCD,
		CurrencyXDR,
		CurrencyXOF,
		CurrencyXPF,
		CurrencyYER,
		CurrencyZAR,
		CurrencyZMW,
		CurrencyZWD
	};
	
	void writeCurrencyEnumJSON(Currency enumVal, JsonWriter& writer);
	Currency readCurrencyFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	enum TitleActivationStatus
	{
		TitleActivationStatusNone,
		TitleActivationStatusActivatedTitleKey,
		TitleActivationStatusPendingSteam,
		TitleActivationStatusActivatedSteam,
		TitleActivationStatusRevokedSteam
	};
	
	void writeTitleActivationStatusEnumJSON(TitleActivationStatus enumVal, JsonWriter& writer);
	TitleActivationStatus readTitleActivationStatusFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FUserSteamInfo : public FPlayFabBaseModel
    {
		
		// [optional] Steam identifier
		FString SteamId;
		// [optional] the country in which the player resides, from Steam data
		FString SteamCountry;
		// [optional] currency type set in the user Steam account
		Boxed<Currency> SteamCurrency;
		// [optional] what stage of game ownership the user is listed as being in, from Steam
		Boxed<TitleActivationStatus> SteamActivationStatus;
	
        FUserSteamInfo() :
			FPlayFabBaseModel(),
			SteamId(),
			SteamCountry(),
			SteamCurrency(),
			SteamActivationStatus()
			{}
		
		FUserSteamInfo(const FUserSteamInfo& src) :
			FPlayFabBaseModel(),
			SteamId(src.SteamId),
			SteamCountry(src.SteamCountry),
			SteamCurrency(src.SteamCurrency),
			SteamActivationStatus(src.SteamActivationStatus)
			{}
			
		FUserSteamInfo(const TSharedPtr<FJsonObject>& obj) : FUserSteamInfo()
        {
            readFromValue(obj);
        }
		
		~FUserSteamInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserGameCenterInfo : public FPlayFabBaseModel
    {
		
		// [optional] Gamecenter identifier
		FString GameCenterId;
	
        FUserGameCenterInfo() :
			FPlayFabBaseModel(),
			GameCenterId()
			{}
		
		FUserGameCenterInfo(const FUserGameCenterInfo& src) :
			FPlayFabBaseModel(),
			GameCenterId(src.GameCenterId)
			{}
			
		FUserGameCenterInfo(const TSharedPtr<FJsonObject>& obj) : FUserGameCenterInfo()
        {
            readFromValue(obj);
        }
		
		~FUserGameCenterInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserIosDeviceInfo : public FPlayFabBaseModel
    {
		
		// [optional] iOS device ID
		FString IosDeviceId;
	
        FUserIosDeviceInfo() :
			FPlayFabBaseModel(),
			IosDeviceId()
			{}
		
		FUserIosDeviceInfo(const FUserIosDeviceInfo& src) :
			FPlayFabBaseModel(),
			IosDeviceId(src.IosDeviceId)
			{}
			
		FUserIosDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserIosDeviceInfo()
        {
            readFromValue(obj);
        }
		
		~FUserIosDeviceInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserAndroidDeviceInfo : public FPlayFabBaseModel
    {
		
		// [optional] Android device ID
		FString AndroidDeviceId;
	
        FUserAndroidDeviceInfo() :
			FPlayFabBaseModel(),
			AndroidDeviceId()
			{}
		
		FUserAndroidDeviceInfo(const FUserAndroidDeviceInfo& src) :
			FPlayFabBaseModel(),
			AndroidDeviceId(src.AndroidDeviceId)
			{}
			
		FUserAndroidDeviceInfo(const TSharedPtr<FJsonObject>& obj) : FUserAndroidDeviceInfo()
        {
            readFromValue(obj);
        }
		
		~FUserAndroidDeviceInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserKongregateInfo : public FPlayFabBaseModel
    {
		
		// [optional] Kongregate ID
		FString KongregateId;
		// [optional] Kongregate Username
		FString KongregateName;
	
        FUserKongregateInfo() :
			FPlayFabBaseModel(),
			KongregateId(),
			KongregateName()
			{}
		
		FUserKongregateInfo(const FUserKongregateInfo& src) :
			FPlayFabBaseModel(),
			KongregateId(src.KongregateId),
			KongregateName(src.KongregateName)
			{}
			
		FUserKongregateInfo(const TSharedPtr<FJsonObject>& obj) : FUserKongregateInfo()
        {
            readFromValue(obj);
        }
		
		~FUserKongregateInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserTwitchInfo : public FPlayFabBaseModel
    {
		
		// [optional] Twitch ID
		FString TwitchId;
		// [optional] Twitch Username
		FString TwitchUserName;
	
        FUserTwitchInfo() :
			FPlayFabBaseModel(),
			TwitchId(),
			TwitchUserName()
			{}
		
		FUserTwitchInfo(const FUserTwitchInfo& src) :
			FPlayFabBaseModel(),
			TwitchId(src.TwitchId),
			TwitchUserName(src.TwitchUserName)
			{}
			
		FUserTwitchInfo(const TSharedPtr<FJsonObject>& obj) : FUserTwitchInfo()
        {
            readFromValue(obj);
        }
		
		~FUserTwitchInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserPsnInfo : public FPlayFabBaseModel
    {
		
		// [optional] PSN account ID
		FString PsnAccountId;
		// [optional] PSN online ID
		FString PsnOnlineId;
	
        FUserPsnInfo() :
			FPlayFabBaseModel(),
			PsnAccountId(),
			PsnOnlineId()
			{}
		
		FUserPsnInfo(const FUserPsnInfo& src) :
			FPlayFabBaseModel(),
			PsnAccountId(src.PsnAccountId),
			PsnOnlineId(src.PsnOnlineId)
			{}
			
		FUserPsnInfo(const TSharedPtr<FJsonObject>& obj) : FUserPsnInfo()
        {
            readFromValue(obj);
        }
		
		~FUserPsnInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserGoogleInfo : public FPlayFabBaseModel
    {
		
		// [optional] Google ID
		FString GoogleId;
		// [optional] Email address of the Google account
		FString GoogleEmail;
		// [optional] Locale of the Google account
		FString GoogleLocale;
		// [optional] Gender information of the Google account
		FString GoogleGender;
	
        FUserGoogleInfo() :
			FPlayFabBaseModel(),
			GoogleId(),
			GoogleEmail(),
			GoogleLocale(),
			GoogleGender()
			{}
		
		FUserGoogleInfo(const FUserGoogleInfo& src) :
			FPlayFabBaseModel(),
			GoogleId(src.GoogleId),
			GoogleEmail(src.GoogleEmail),
			GoogleLocale(src.GoogleLocale),
			GoogleGender(src.GoogleGender)
			{}
			
		FUserGoogleInfo(const TSharedPtr<FJsonObject>& obj) : FUserGoogleInfo()
        {
            readFromValue(obj);
        }
		
		~FUserGoogleInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserXboxInfo : public FPlayFabBaseModel
    {
		
		// [optional] XBox user ID
		FString XboxUserId;
	
        FUserXboxInfo() :
			FPlayFabBaseModel(),
			XboxUserId()
			{}
		
		FUserXboxInfo(const FUserXboxInfo& src) :
			FPlayFabBaseModel(),
			XboxUserId(src.XboxUserId)
			{}
			
		FUserXboxInfo(const TSharedPtr<FJsonObject>& obj) : FUserXboxInfo()
        {
            readFromValue(obj);
        }
		
		~FUserXboxInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserCustomIdInfo : public FPlayFabBaseModel
    {
		
		// [optional] Custom ID
		FString CustomId;
	
        FUserCustomIdInfo() :
			FPlayFabBaseModel(),
			CustomId()
			{}
		
		FUserCustomIdInfo(const FUserCustomIdInfo& src) :
			FPlayFabBaseModel(),
			CustomId(src.CustomId)
			{}
			
		FUserCustomIdInfo(const TSharedPtr<FJsonObject>& obj) : FUserCustomIdInfo()
        {
            readFromValue(obj);
        }
		
		~FUserCustomIdInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUserAccountInfo : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the user account
		FString PlayFabId;
		// Timestamp indicating when the user account was created
		FDateTime Created;
		// [optional] User account name in the PlayFab service
		FString Username;
		// [optional] Title-specific information for the user account
		TSharedPtr<FUserTitleInfo> TitleInfo;
		// [optional] Personal information for the user which is considered more sensitive
		TSharedPtr<FUserPrivateAccountInfo> PrivateInfo;
		// [optional] User Facebook information, if a Facebook account has been linked
		TSharedPtr<FUserFacebookInfo> FacebookInfo;
		// [optional] User Steam information, if a Steam account has been linked
		TSharedPtr<FUserSteamInfo> SteamInfo;
		// [optional] User Gamecenter information, if a Gamecenter account has been linked
		TSharedPtr<FUserGameCenterInfo> GameCenterInfo;
		// [optional] User iOS device information, if an iOS device has been linked
		TSharedPtr<FUserIosDeviceInfo> IosDeviceInfo;
		// [optional] User Android device information, if an Android device has been linked
		TSharedPtr<FUserAndroidDeviceInfo> AndroidDeviceInfo;
		// [optional] User Kongregate account information, if a Kongregate account has been linked
		TSharedPtr<FUserKongregateInfo> KongregateInfo;
		// [optional] User Twitch account information, if a Twitch account has been linked
		TSharedPtr<FUserTwitchInfo> TwitchInfo;
		// [optional] User PSN account information, if a PSN account has been linked
		TSharedPtr<FUserPsnInfo> PsnInfo;
		// [optional] User Google account information, if a Google account has been linked
		TSharedPtr<FUserGoogleInfo> GoogleInfo;
		// [optional] User XBox account information, if a XBox account has been linked
		TSharedPtr<FUserXboxInfo> XboxInfo;
		// [optional] Custom ID information, if a custom ID has been assigned
		TSharedPtr<FUserCustomIdInfo> CustomIdInfo;
	
        FUserAccountInfo() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Created(0),
			Username(),
			TitleInfo(nullptr),
			PrivateInfo(nullptr),
			FacebookInfo(nullptr),
			SteamInfo(nullptr),
			GameCenterInfo(nullptr),
			IosDeviceInfo(nullptr),
			AndroidDeviceInfo(nullptr),
			KongregateInfo(nullptr),
			TwitchInfo(nullptr),
			PsnInfo(nullptr),
			GoogleInfo(nullptr),
			XboxInfo(nullptr),
			CustomIdInfo(nullptr)
			{}
		
		FUserAccountInfo(const FUserAccountInfo& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Created(src.Created),
			Username(src.Username),
			TitleInfo(src.TitleInfo.IsValid() ? MakeShareable(new FUserTitleInfo(*src.TitleInfo)) : nullptr),
			PrivateInfo(src.PrivateInfo.IsValid() ? MakeShareable(new FUserPrivateAccountInfo(*src.PrivateInfo)) : nullptr),
			FacebookInfo(src.FacebookInfo.IsValid() ? MakeShareable(new FUserFacebookInfo(*src.FacebookInfo)) : nullptr),
			SteamInfo(src.SteamInfo.IsValid() ? MakeShareable(new FUserSteamInfo(*src.SteamInfo)) : nullptr),
			GameCenterInfo(src.GameCenterInfo.IsValid() ? MakeShareable(new FUserGameCenterInfo(*src.GameCenterInfo)) : nullptr),
			IosDeviceInfo(src.IosDeviceInfo.IsValid() ? MakeShareable(new FUserIosDeviceInfo(*src.IosDeviceInfo)) : nullptr),
			AndroidDeviceInfo(src.AndroidDeviceInfo.IsValid() ? MakeShareable(new FUserAndroidDeviceInfo(*src.AndroidDeviceInfo)) : nullptr),
			KongregateInfo(src.KongregateInfo.IsValid() ? MakeShareable(new FUserKongregateInfo(*src.KongregateInfo)) : nullptr),
			TwitchInfo(src.TwitchInfo.IsValid() ? MakeShareable(new FUserTwitchInfo(*src.TwitchInfo)) : nullptr),
			PsnInfo(src.PsnInfo.IsValid() ? MakeShareable(new FUserPsnInfo(*src.PsnInfo)) : nullptr),
			GoogleInfo(src.GoogleInfo.IsValid() ? MakeShareable(new FUserGoogleInfo(*src.GoogleInfo)) : nullptr),
			XboxInfo(src.XboxInfo.IsValid() ? MakeShareable(new FUserXboxInfo(*src.XboxInfo)) : nullptr),
			CustomIdInfo(src.CustomIdInfo.IsValid() ? MakeShareable(new FUserCustomIdInfo(*src.CustomIdInfo)) : nullptr)
			{}
			
		FUserAccountInfo(const TSharedPtr<FJsonObject>& obj) : FUserAccountInfo()
        {
            readFromValue(obj);
        }
		
		~FUserAccountInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAuthenticateSessionTicketResult : public FPlayFabBaseModel
    {
		
		// [optional] Account info for the user whose session ticket was supplied.
		TSharedPtr<FUserAccountInfo> UserInfo;
	
        FAuthenticateSessionTicketResult() :
			FPlayFabBaseModel(),
			UserInfo(nullptr)
			{}
		
		FAuthenticateSessionTicketResult(const FAuthenticateSessionTicketResult& src) :
			FPlayFabBaseModel(),
			UserInfo(src.UserInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.UserInfo)) : nullptr)
			{}
			
		FAuthenticateSessionTicketResult(const TSharedPtr<FJsonObject>& obj) : FAuthenticateSessionTicketResult()
        {
            readFromValue(obj);
        }
		
		~FAuthenticateSessionTicketResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAwardSteamAchievementItem : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique Steam achievement name.
		FString AchievementName;
		// Result of the award attempt (only valid on response, not on request).
		bool Result;
	
        FAwardSteamAchievementItem() :
			FPlayFabBaseModel(),
			PlayFabId(),
			AchievementName(),
			Result(false)
			{}
		
		FAwardSteamAchievementItem(const FAwardSteamAchievementItem& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			AchievementName(src.AchievementName),
			Result(src.Result)
			{}
			
		FAwardSteamAchievementItem(const TSharedPtr<FJsonObject>& obj) : FAwardSteamAchievementItem()
        {
            readFromValue(obj);
        }
		
		~FAwardSteamAchievementItem();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAwardSteamAchievementRequest : public FPlayFabBaseModel
    {
		
		// Array of achievements to grant and the users to whom they are to be granted.
		TArray<FAwardSteamAchievementItem> Achievements;
	
        FAwardSteamAchievementRequest() :
			FPlayFabBaseModel(),
			Achievements()
			{}
		
		FAwardSteamAchievementRequest(const FAwardSteamAchievementRequest& src) :
			FPlayFabBaseModel(),
			Achievements(src.Achievements)
			{}
			
		FAwardSteamAchievementRequest(const TSharedPtr<FJsonObject>& obj) : FAwardSteamAchievementRequest()
        {
            readFromValue(obj);
        }
		
		~FAwardSteamAchievementRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FAwardSteamAchievementResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of achievements granted.
		TArray<FAwardSteamAchievementItem> AchievementResults;
	
        FAwardSteamAchievementResult() :
			FPlayFabBaseModel(),
			AchievementResults()
			{}
		
		FAwardSteamAchievementResult(const FAwardSteamAchievementResult& src) :
			FPlayFabBaseModel(),
			AchievementResults(src.AchievementResults)
			{}
			
		FAwardSteamAchievementResult(const TSharedPtr<FJsonObject>& obj) : FAwardSteamAchievementResult()
        {
            readFromValue(obj);
        }
		
		~FAwardSteamAchievementResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FBanInfo : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] The unique Ban Id associated with this ban.
		FString BanId;
		// [optional] The IP address on which the ban was applied. May affect multiple players.
		FString IPAddress;
		// [optional] The MAC address on which the ban was applied. May affect multiple players.
		FString MACAddress;
		// [optional] The time when this ban was applied.
		OptionalTime Created;
		// [optional] The time when this ban expires. Permanent bans do not have expiration date.
		OptionalTime Expires;
		// [optional] The reason why this ban was applied.
		FString Reason;
		// The active state of this ban. Expired bans may still have this value set to true but they will have no effect.
		bool Active;
	
        FBanInfo() :
			FPlayFabBaseModel(),
			PlayFabId(),
			BanId(),
			IPAddress(),
			MACAddress(),
			Created(),
			Expires(),
			Reason(),
			Active(false)
			{}
		
		FBanInfo(const FBanInfo& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			BanId(src.BanId),
			IPAddress(src.IPAddress),
			MACAddress(src.MACAddress),
			Created(src.Created),
			Expires(src.Expires),
			Reason(src.Reason),
			Active(src.Active)
			{}
			
		FBanInfo(const TSharedPtr<FJsonObject>& obj) : FBanInfo()
        {
            readFromValue(obj);
        }
		
		~FBanInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FBanRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] IP address to be banned. May affect multiple players.
		FString IPAddress;
		// [optional] MAC address to be banned. May affect multiple players.
		FString MACAddress;
		// [optional] The reason for this ban. Maximum 140 characters.
		FString Reason;
		// [optional] The duration in hours for the ban. Leave this blank for a permanent ban.
		OptionalUint32 DurationInHours;
	
        FBanRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			IPAddress(),
			MACAddress(),
			Reason(),
			DurationInHours()
			{}
		
		FBanRequest(const FBanRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			IPAddress(src.IPAddress),
			MACAddress(src.MACAddress),
			Reason(src.Reason),
			DurationInHours(src.DurationInHours)
			{}
			
		FBanRequest(const TSharedPtr<FJsonObject>& obj) : FBanRequest()
        {
            readFromValue(obj);
        }
		
		~FBanRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FBanUsersRequest : public FPlayFabBaseModel
    {
		
		// List of ban requests to be applied. Maximum 100.
		TArray<FBanRequest> Bans;
	
        FBanUsersRequest() :
			FPlayFabBaseModel(),
			Bans()
			{}
		
		FBanUsersRequest(const FBanUsersRequest& src) :
			FPlayFabBaseModel(),
			Bans(src.Bans)
			{}
			
		FBanUsersRequest(const TSharedPtr<FJsonObject>& obj) : FBanUsersRequest()
        {
            readFromValue(obj);
        }
		
		~FBanUsersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FBanUsersResult : public FPlayFabBaseModel
    {
		
		// [optional] Information on the bans that were applied
		TArray<FBanInfo> BanData;
	
        FBanUsersResult() :
			FPlayFabBaseModel(),
			BanData()
			{}
		
		FBanUsersResult(const FBanUsersResult& src) :
			FPlayFabBaseModel(),
			BanData(src.BanData)
			{}
			
		FBanUsersResult(const TSharedPtr<FJsonObject>& obj) : FBanUsersResult()
        {
            readFromValue(obj);
        }
		
		~FBanUsersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItemConsumableInfo : public FPlayFabBaseModel
    {
		
		// [optional] number of times this object can be used, after which it will be removed from the player inventory
		OptionalUint32 UsageCount;
		// [optional] duration in seconds for how long the item will remain in the player inventory - once elapsed, the item will be removed (recommended minimum value is 5 seconds, as lower values can cause the item to expire before operations depending on this item's details have completed)
		OptionalUint32 UsagePeriod;
		// [optional] all inventory item instances in the player inventory sharing a non-null UsagePeriodGroup have their UsagePeriod values added together, and share the result - when that period has elapsed, all the items in the group will be removed
		FString UsagePeriodGroup;
	
        FCatalogItemConsumableInfo() :
			FPlayFabBaseModel(),
			UsageCount(),
			UsagePeriod(),
			UsagePeriodGroup()
			{}
		
		FCatalogItemConsumableInfo(const FCatalogItemConsumableInfo& src) :
			FPlayFabBaseModel(),
			UsageCount(src.UsageCount),
			UsagePeriod(src.UsagePeriod),
			UsagePeriodGroup(src.UsagePeriodGroup)
			{}
			
		FCatalogItemConsumableInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemConsumableInfo()
        {
            readFromValue(obj);
        }
		
		~FCatalogItemConsumableInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItemContainerInfo : public FPlayFabBaseModel
    {
		
		// [optional] ItemId for the catalog item used to unlock the container, if any (if not specified, a call to UnlockContainerItem will open the container, adding the contents to the player inventory and currency balances)
		FString KeyItemId;
		// [optional] unique ItemId values for all items which will be added to the player inventory, once the container has been unlocked
		TArray<FString> ItemContents;
		// [optional] unique TableId values for all RandomResultTable objects which are part of the container (once unlocked, random tables will be resolved and add the relevant items to the player inventory)
		TArray<FString> ResultTableContents;
		// [optional] virtual currency types and balances which will be added to the player inventory when the container is unlocked
		TMap<FString, uint32> VirtualCurrencyContents;
	
        FCatalogItemContainerInfo() :
			FPlayFabBaseModel(),
			KeyItemId(),
			ItemContents(),
			ResultTableContents(),
			VirtualCurrencyContents()
			{}
		
		FCatalogItemContainerInfo(const FCatalogItemContainerInfo& src) :
			FPlayFabBaseModel(),
			KeyItemId(src.KeyItemId),
			ItemContents(src.ItemContents),
			ResultTableContents(src.ResultTableContents),
			VirtualCurrencyContents(src.VirtualCurrencyContents)
			{}
			
		FCatalogItemContainerInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemContainerInfo()
        {
            readFromValue(obj);
        }
		
		~FCatalogItemContainerInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItemBundleInfo : public FPlayFabBaseModel
    {
		
		// [optional] unique ItemId values for all items which will be added to the player inventory when the bundle is added
		TArray<FString> BundledItems;
		// [optional] unique TableId values for all RandomResultTable objects which are part of the bundle (random tables will be resolved and add the relevant items to the player inventory when the bundle is added)
		TArray<FString> BundledResultTables;
		// [optional] virtual currency types and balances which will be added to the player inventory when the bundle is added
		TMap<FString, uint32> BundledVirtualCurrencies;
	
        FCatalogItemBundleInfo() :
			FPlayFabBaseModel(),
			BundledItems(),
			BundledResultTables(),
			BundledVirtualCurrencies()
			{}
		
		FCatalogItemBundleInfo(const FCatalogItemBundleInfo& src) :
			FPlayFabBaseModel(),
			BundledItems(src.BundledItems),
			BundledResultTables(src.BundledResultTables),
			BundledVirtualCurrencies(src.BundledVirtualCurrencies)
			{}
			
		FCatalogItemBundleInfo(const TSharedPtr<FJsonObject>& obj) : FCatalogItemBundleInfo()
        {
            readFromValue(obj);
        }
		
		~FCatalogItemBundleInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCatalogItem : public FPlayFabBaseModel
    {
		
		// unique identifier for this item
		FString ItemId;
		// [optional] class to which the item belongs
		FString ItemClass;
		// [optional] catalog version for this item
		FString CatalogVersion;
		// [optional] text name for the item, to show in-game
		FString DisplayName;
		// [optional] text description of item, to show in-game
		FString Description;
		// [optional] price of this item in virtual currencies and "RM" (the base Real Money purchase price, in USD pennies)
		TMap<FString, uint32> VirtualCurrencyPrices;
		// [optional] override prices for this item for specific currencies
		TMap<FString, uint32> RealCurrencyPrices;
		// [optional] list of item tags
		TArray<FString> Tags;
		// [optional] game specific custom data
		FString CustomData;
		// [optional] defines the consumable properties (number of uses, timeout) for the item
		TSharedPtr<FCatalogItemConsumableInfo> Consumable;
		// [optional] defines the container properties for the item - what items it contains, including random drop tables and virtual currencies, and what item (if any) is required to open it via the UnlockContainerItem API
		TSharedPtr<FCatalogItemContainerInfo> Container;
		// [optional] defines the bundle properties for the item - bundles are items which contain other items, including random drop tables and virtual currencies
		TSharedPtr<FCatalogItemBundleInfo> Bundle;
		// if true, then an item instance of this type can be used to grant a character to a user.
		bool CanBecomeCharacter;
		// if true, then only one item instance of this type will exist and its remaininguses will be incremented instead. RemainingUses will cap out at Int32.Max (2,147,483,647). All subsequent increases will be discarded
		bool IsStackable;
		// if true, then an item instance of this type can be traded between players using the trading APIs
		bool IsTradable;
		// [optional] URL to the item image. For Facebook purchase to display the image on the item purchase page, this must be set to an HTTP URL.
		FString ItemImageUrl;
		// BETA: If true, then only a fixed number can ever be granted.
		bool IsLimitedEdition;
		// If the item has IsLImitedEdition set to true, and this is the first time this ItemId has been defined as a limited edition item, this value determines the total number of instances to allocate for the title. Once this limit has been reached, no more instances of this ItemId can be created, and attempts to purchase or grant it will return a Result of false for that ItemId. If the item has already been defined to have a limited edition count, or if this value is less than zero, it will be ignored.
		int32 InitialLimitedEditionCount;
	
        FCatalogItem() :
			FPlayFabBaseModel(),
			ItemId(),
			ItemClass(),
			CatalogVersion(),
			DisplayName(),
			Description(),
			VirtualCurrencyPrices(),
			RealCurrencyPrices(),
			Tags(),
			CustomData(),
			Consumable(nullptr),
			Container(nullptr),
			Bundle(nullptr),
			CanBecomeCharacter(false),
			IsStackable(false),
			IsTradable(false),
			ItemImageUrl(),
			IsLimitedEdition(false),
			InitialLimitedEditionCount(0)
			{}
		
		FCatalogItem(const FCatalogItem& src) :
			FPlayFabBaseModel(),
			ItemId(src.ItemId),
			ItemClass(src.ItemClass),
			CatalogVersion(src.CatalogVersion),
			DisplayName(src.DisplayName),
			Description(src.Description),
			VirtualCurrencyPrices(src.VirtualCurrencyPrices),
			RealCurrencyPrices(src.RealCurrencyPrices),
			Tags(src.Tags),
			CustomData(src.CustomData),
			Consumable(src.Consumable.IsValid() ? MakeShareable(new FCatalogItemConsumableInfo(*src.Consumable)) : nullptr),
			Container(src.Container.IsValid() ? MakeShareable(new FCatalogItemContainerInfo(*src.Container)) : nullptr),
			Bundle(src.Bundle.IsValid() ? MakeShareable(new FCatalogItemBundleInfo(*src.Bundle)) : nullptr),
			CanBecomeCharacter(src.CanBecomeCharacter),
			IsStackable(src.IsStackable),
			IsTradable(src.IsTradable),
			ItemImageUrl(src.ItemImageUrl),
			IsLimitedEdition(src.IsLimitedEdition),
			InitialLimitedEditionCount(src.InitialLimitedEditionCount)
			{}
			
		FCatalogItem(const TSharedPtr<FJsonObject>& obj) : FCatalogItem()
        {
            readFromValue(obj);
        }
		
		~FCatalogItem();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FItemInstance : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the inventory item, as defined in the catalog.
		FString ItemId;
		// [optional] Unique item identifier for this specific instance of the item.
		FString ItemInstanceId;
		// [optional] Class name for the inventory item, as defined in the catalog.
		FString ItemClass;
		// [optional] Timestamp for when this instance was purchased.
		OptionalTime PurchaseDate;
		// [optional] Timestamp for when this instance will expire.
		OptionalTime Expiration;
		// [optional] Total number of remaining uses, if this is a consumable item.
		OptionalInt32 RemainingUses;
		// [optional] The number of uses that were added or removed to this item in this call.
		OptionalInt32 UsesIncrementedBy;
		// [optional] Game specific comment associated with this instance when it was added to the user inventory.
		FString Annotation;
		// [optional] Catalog version for the inventory item, when this instance was created.
		FString CatalogVersion;
		// [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or container.
		FString BundleParent;
		// [optional] CatalogItem.DisplayName at the time this item was purchased.
		FString DisplayName;
		// [optional] Currency type for the cost of the catalog item.
		FString UnitCurrency;
		// Cost of the catalog item in the given currency.
		uint32 UnitPrice;
		// [optional] Array of unique items that were awarded when this catalog item was purchased.
		TArray<FString> BundleContents;
		// [optional] A set of custom key-value pairs on the inventory item.
		TMap<FString, FString> CustomData;
	
        FItemInstance() :
			FPlayFabBaseModel(),
			ItemId(),
			ItemInstanceId(),
			ItemClass(),
			PurchaseDate(),
			Expiration(),
			RemainingUses(),
			UsesIncrementedBy(),
			Annotation(),
			CatalogVersion(),
			BundleParent(),
			DisplayName(),
			UnitCurrency(),
			UnitPrice(0),
			BundleContents(),
			CustomData()
			{}
		
		FItemInstance(const FItemInstance& src) :
			FPlayFabBaseModel(),
			ItemId(src.ItemId),
			ItemInstanceId(src.ItemInstanceId),
			ItemClass(src.ItemClass),
			PurchaseDate(src.PurchaseDate),
			Expiration(src.Expiration),
			RemainingUses(src.RemainingUses),
			UsesIncrementedBy(src.UsesIncrementedBy),
			Annotation(src.Annotation),
			CatalogVersion(src.CatalogVersion),
			BundleParent(src.BundleParent),
			DisplayName(src.DisplayName),
			UnitCurrency(src.UnitCurrency),
			UnitPrice(src.UnitPrice),
			BundleContents(src.BundleContents),
			CustomData(src.CustomData)
			{}
			
		FItemInstance(const TSharedPtr<FJsonObject>& obj) : FItemInstance()
        {
            readFromValue(obj);
        }
		
		~FItemInstance();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCharacterInventory : public FPlayFabBaseModel
    {
		
		// [optional] The id of this character.
		FString CharacterId;
		// [optional] The inventory of this character.
		TArray<FItemInstance> Inventory;
	
        FCharacterInventory() :
			FPlayFabBaseModel(),
			CharacterId(),
			Inventory()
			{}
		
		FCharacterInventory(const FCharacterInventory& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			Inventory(src.Inventory)
			{}
			
		FCharacterInventory(const TSharedPtr<FJsonObject>& obj) : FCharacterInventory()
        {
            readFromValue(obj);
        }
		
		~FCharacterInventory();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCharacterLeaderboardEntry : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier of the user for this leaderboard entry.
		FString PlayFabId;
		// [optional] PlayFab unique identifier of the character that belongs to the user for this leaderboard entry.
		FString CharacterId;
		// [optional] Title-specific display name of the character for this leaderboard entry.
		FString CharacterName;
		// [optional] Title-specific display name of the user for this leaderboard entry.
		FString DisplayName;
		// [optional] Name of the character class for this entry.
		FString CharacterType;
		// Specific value of the user's statistic.
		int32 StatValue;
		// User's overall position in the leaderboard.
		int32 Position;
	
        FCharacterLeaderboardEntry() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			CharacterName(),
			DisplayName(),
			CharacterType(),
			StatValue(0),
			Position(0)
			{}
		
		FCharacterLeaderboardEntry(const FCharacterLeaderboardEntry& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			CharacterName(src.CharacterName),
			DisplayName(src.DisplayName),
			CharacterType(src.CharacterType),
			StatValue(src.StatValue),
			Position(src.Position)
			{}
			
		FCharacterLeaderboardEntry(const TSharedPtr<FJsonObject>& obj) : FCharacterLeaderboardEntry()
        {
            readFromValue(obj);
        }
		
		~FCharacterLeaderboardEntry();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCharacterResult : public FPlayFabBaseModel
    {
		
		// [optional] The id for this character on this player.
		FString CharacterId;
		// [optional] The name of this character.
		FString CharacterName;
		// [optional] The type-string that was given to this character on creation.
		FString CharacterType;
	
        FCharacterResult() :
			FPlayFabBaseModel(),
			CharacterId(),
			CharacterName(),
			CharacterType()
			{}
		
		FCharacterResult(const FCharacterResult& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			CharacterName(src.CharacterName),
			CharacterType(src.CharacterType)
			{}
			
		FCharacterResult(const TSharedPtr<FJsonObject>& obj) : FCharacterResult()
        {
            readFromValue(obj);
        }
		
		~FCharacterResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum CloudScriptRevisionOption
	{
		CloudScriptRevisionOptionLive,
		CloudScriptRevisionOptionLatest,
		CloudScriptRevisionOptionSpecific
	};
	
	void writeCloudScriptRevisionOptionEnumJSON(CloudScriptRevisionOption enumVal, JsonWriter& writer);
	CloudScriptRevisionOption readCloudScriptRevisionOptionFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FConsumeItemRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique instance identifier of the item to be consumed.
		FString ItemInstanceId;
		// Number of uses to consume from the item.
		int32 ConsumeCount;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
	
        FConsumeItemRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			ItemInstanceId(),
			ConsumeCount(0),
			CharacterId()
			{}
		
		FConsumeItemRequest(const FConsumeItemRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			ItemInstanceId(src.ItemInstanceId),
			ConsumeCount(src.ConsumeCount),
			CharacterId(src.CharacterId)
			{}
			
		FConsumeItemRequest(const TSharedPtr<FJsonObject>& obj) : FConsumeItemRequest()
        {
            readFromValue(obj);
        }
		
		~FConsumeItemRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FConsumeItemResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique instance identifier of the item with uses consumed.
		FString ItemInstanceId;
		// Number of uses remaining on the item.
		int32 RemainingUses;
	
        FConsumeItemResult() :
			FPlayFabBaseModel(),
			ItemInstanceId(),
			RemainingUses(0)
			{}
		
		FConsumeItemResult(const FConsumeItemResult& src) :
			FPlayFabBaseModel(),
			ItemInstanceId(src.ItemInstanceId),
			RemainingUses(src.RemainingUses)
			{}
			
		FConsumeItemResult(const TSharedPtr<FJsonObject>& obj) : FConsumeItemResult()
        {
            readFromValue(obj);
        }
		
		~FConsumeItemResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum ContinentCode
	{
		ContinentCodeAF,
		ContinentCodeAN,
		ContinentCodeAS,
		ContinentCodeEU,
		ContinentCodeNA,
		ContinentCodeOC,
		ContinentCodeSA
	};
	
	void writeContinentCodeEnumJSON(ContinentCode enumVal, JsonWriter& writer);
	ContinentCode readContinentCodeFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	enum CountryCode
	{
		CountryCodeAF,
		CountryCodeAX,
		CountryCodeAL,
		CountryCodeDZ,
		CountryCodeAS,
		CountryCodeAD,
		CountryCodeAO,
		CountryCodeAI,
		CountryCodeAQ,
		CountryCodeAG,
		CountryCodeAR,
		CountryCodeAM,
		CountryCodeAW,
		CountryCodeAU,
		CountryCodeAT,
		CountryCodeAZ,
		CountryCodeBS,
		CountryCodeBH,
		CountryCodeBD,
		CountryCodeBB,
		CountryCodeBY,
		CountryCodeBE,
		CountryCodeBZ,
		CountryCodeBJ,
		CountryCodeBM,
		CountryCodeBT,
		CountryCodeBO,
		CountryCodeBQ,
		CountryCodeBA,
		CountryCodeBW,
		CountryCodeBV,
		CountryCodeBR,
		CountryCodeIO,
		CountryCodeBN,
		CountryCodeBG,
		CountryCodeBF,
		CountryCodeBI,
		CountryCodeKH,
		CountryCodeCM,
		CountryCodeCA,
		CountryCodeCV,
		CountryCodeKY,
		CountryCodeCF,
		CountryCodeTD,
		CountryCodeCL,
		CountryCodeCN,
		CountryCodeCX,
		CountryCodeCC,
		CountryCodeCO,
		CountryCodeKM,
		CountryCodeCG,
		CountryCodeCD,
		CountryCodeCK,
		CountryCodeCR,
		CountryCodeCI,
		CountryCodeHR,
		CountryCodeCU,
		CountryCodeCW,
		CountryCodeCY,
		CountryCodeCZ,
		CountryCodeDK,
		CountryCodeDJ,
		CountryCodeDM,
		CountryCodeDO,
		CountryCodeEC,
		CountryCodeEG,
		CountryCodeSV,
		CountryCodeGQ,
		CountryCodeER,
		CountryCodeEE,
		CountryCodeET,
		CountryCodeFK,
		CountryCodeFO,
		CountryCodeFJ,
		CountryCodeFI,
		CountryCodeFR,
		CountryCodeGF,
		CountryCodePF,
		CountryCodeTF,
		CountryCodeGA,
		CountryCodeGM,
		CountryCodeGE,
		CountryCodeDE,
		CountryCodeGH,
		CountryCodeGI,
		CountryCodeGR,
		CountryCodeGL,
		CountryCodeGD,
		CountryCodeGP,
		CountryCodeGU,
		CountryCodeGT,
		CountryCodeGG,
		CountryCodeGN,
		CountryCodeGW,
		CountryCodeGY,
		CountryCodeHT,
		CountryCodeHM,
		CountryCodeVA,
		CountryCodeHN,
		CountryCodeHK,
		CountryCodeHU,
		CountryCodeIS,
		CountryCodeIN,
		CountryCodeID,
		CountryCodeIR,
		CountryCodeIQ,
		CountryCodeIE,
		CountryCodeIM,
		CountryCodeIL,
		CountryCodeIT,
		CountryCodeJM,
		CountryCodeJP,
		CountryCodeJE,
		CountryCodeJO,
		CountryCodeKZ,
		CountryCodeKE,
		CountryCodeKI,
		CountryCodeKP,
		CountryCodeKR,
		CountryCodeKW,
		CountryCodeKG,
		CountryCodeLA,
		CountryCodeLV,
		CountryCodeLB,
		CountryCodeLS,
		CountryCodeLR,
		CountryCodeLY,
		CountryCodeLI,
		CountryCodeLT,
		CountryCodeLU,
		CountryCodeMO,
		CountryCodeMK,
		CountryCodeMG,
		CountryCodeMW,
		CountryCodeMY,
		CountryCodeMV,
		CountryCodeML,
		CountryCodeMT,
		CountryCodeMH,
		CountryCodeMQ,
		CountryCodeMR,
		CountryCodeMU,
		CountryCodeYT,
		CountryCodeMX,
		CountryCodeFM,
		CountryCodeMD,
		CountryCodeMC,
		CountryCodeMN,
		CountryCodeME,
		CountryCodeMS,
		CountryCodeMA,
		CountryCodeMZ,
		CountryCodeMM,
		CountryCodeNA,
		CountryCodeNR,
		CountryCodeNP,
		CountryCodeNL,
		CountryCodeNC,
		CountryCodeNZ,
		CountryCodeNI,
		CountryCodeNE,
		CountryCodeNG,
		CountryCodeNU,
		CountryCodeNF,
		CountryCodeMP,
		CountryCodeNO,
		CountryCodeOM,
		CountryCodePK,
		CountryCodePW,
		CountryCodePS,
		CountryCodePA,
		CountryCodePG,
		CountryCodePY,
		CountryCodePE,
		CountryCodePH,
		CountryCodePN,
		CountryCodePL,
		CountryCodePT,
		CountryCodePR,
		CountryCodeQA,
		CountryCodeRE,
		CountryCodeRO,
		CountryCodeRU,
		CountryCodeRW,
		CountryCodeBL,
		CountryCodeSH,
		CountryCodeKN,
		CountryCodeLC,
		CountryCodeMF,
		CountryCodePM,
		CountryCodeVC,
		CountryCodeWS,
		CountryCodeSM,
		CountryCodeST,
		CountryCodeSA,
		CountryCodeSN,
		CountryCodeRS,
		CountryCodeSC,
		CountryCodeSL,
		CountryCodeSG,
		CountryCodeSX,
		CountryCodeSK,
		CountryCodeSI,
		CountryCodeSB,
		CountryCodeSO,
		CountryCodeZA,
		CountryCodeGS,
		CountryCodeSS,
		CountryCodeES,
		CountryCodeLK,
		CountryCodeSD,
		CountryCodeSR,
		CountryCodeSJ,
		CountryCodeSZ,
		CountryCodeSE,
		CountryCodeCH,
		CountryCodeSY,
		CountryCodeTW,
		CountryCodeTJ,
		CountryCodeTZ,
		CountryCodeTH,
		CountryCodeTL,
		CountryCodeTG,
		CountryCodeTK,
		CountryCodeTO,
		CountryCodeTT,
		CountryCodeTN,
		CountryCodeTR,
		CountryCodeTM,
		CountryCodeTC,
		CountryCodeTV,
		CountryCodeUG,
		CountryCodeUA,
		CountryCodeAE,
		CountryCodeGB,
		CountryCodeUS,
		CountryCodeUM,
		CountryCodeUY,
		CountryCodeUZ,
		CountryCodeVU,
		CountryCodeVE,
		CountryCodeVN,
		CountryCodeVG,
		CountryCodeVI,
		CountryCodeWF,
		CountryCodeEH,
		CountryCodeYE,
		CountryCodeZM,
		CountryCodeZW
	};
	
	void writeCountryCodeEnumJSON(CountryCode enumVal, JsonWriter& writer);
	CountryCode readCountryCodeFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FCreateSharedGroupRequest : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the shared group (a random identifier will be assigned, if one is not specified).
		FString SharedGroupId;
	
        FCreateSharedGroupRequest() :
			FPlayFabBaseModel(),
			SharedGroupId()
			{}
		
		FCreateSharedGroupRequest(const FCreateSharedGroupRequest& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId)
			{}
			
		FCreateSharedGroupRequest(const TSharedPtr<FJsonObject>& obj) : FCreateSharedGroupRequest()
        {
            readFromValue(obj);
        }
		
		~FCreateSharedGroupRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FCreateSharedGroupResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the shared group.
		FString SharedGroupId;
	
        FCreateSharedGroupResult() :
			FPlayFabBaseModel(),
			SharedGroupId()
			{}
		
		FCreateSharedGroupResult(const FCreateSharedGroupResult& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId)
			{}
			
		FCreateSharedGroupResult(const TSharedPtr<FJsonObject>& obj) : FCreateSharedGroupResult()
        {
            readFromValue(obj);
        }
		
		~FCreateSharedGroupResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeleteCharacterFromUserRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// If true, the character's inventory will be transferred up to the owning user; otherwise, this request will purge those items.
		bool SaveCharacterInventory;
	
        FDeleteCharacterFromUserRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			SaveCharacterInventory(false)
			{}
		
		FDeleteCharacterFromUserRequest(const FDeleteCharacterFromUserRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			SaveCharacterInventory(src.SaveCharacterInventory)
			{}
			
		FDeleteCharacterFromUserRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteCharacterFromUserRequest()
        {
            readFromValue(obj);
        }
		
		~FDeleteCharacterFromUserRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeleteCharacterFromUserResult : public FPlayFabBaseModel
    {
		
	
        FDeleteCharacterFromUserResult() :
			FPlayFabBaseModel()
			{}
		
		FDeleteCharacterFromUserResult(const FDeleteCharacterFromUserResult& src) :
			FPlayFabBaseModel()
			{}
			
		FDeleteCharacterFromUserResult(const TSharedPtr<FJsonObject>& obj) : FDeleteCharacterFromUserResult()
        {
            readFromValue(obj);
        }
		
		~FDeleteCharacterFromUserResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeleteSharedGroupRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the shared group.
		FString SharedGroupId;
	
        FDeleteSharedGroupRequest() :
			FPlayFabBaseModel(),
			SharedGroupId()
			{}
		
		FDeleteSharedGroupRequest(const FDeleteSharedGroupRequest& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId)
			{}
			
		FDeleteSharedGroupRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteSharedGroupRequest()
        {
            readFromValue(obj);
        }
		
		~FDeleteSharedGroupRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeleteUsersRequest : public FPlayFabBaseModel
    {
		
		// An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
		TArray<FString> PlayFabIds;
		// Unique identifier for the title, found in the Settings > Game Properties section of the PlayFab developer site when a title has been selected.
		FString TitleId;
	
        FDeleteUsersRequest() :
			FPlayFabBaseModel(),
			PlayFabIds(),
			TitleId()
			{}
		
		FDeleteUsersRequest(const FDeleteUsersRequest& src) :
			FPlayFabBaseModel(),
			PlayFabIds(src.PlayFabIds),
			TitleId(src.TitleId)
			{}
			
		FDeleteUsersRequest(const TSharedPtr<FJsonObject>& obj) : FDeleteUsersRequest()
        {
            readFromValue(obj);
        }
		
		~FDeleteUsersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeleteUsersResult : public FPlayFabBaseModel
    {
		
	
        FDeleteUsersResult() :
			FPlayFabBaseModel()
			{}
		
		FDeleteUsersResult(const FDeleteUsersResult& src) :
			FPlayFabBaseModel()
			{}
			
		FDeleteUsersResult(const TSharedPtr<FJsonObject>& obj) : FDeleteUsersResult()
        {
            readFromValue(obj);
        }
		
		~FDeleteUsersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeregisterGameRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the Game Server Instance that is being deregistered.
		FString LobbyId;
	
        FDeregisterGameRequest() :
			FPlayFabBaseModel(),
			LobbyId()
			{}
		
		FDeregisterGameRequest(const FDeregisterGameRequest& src) :
			FPlayFabBaseModel(),
			LobbyId(src.LobbyId)
			{}
			
		FDeregisterGameRequest(const TSharedPtr<FJsonObject>& obj) : FDeregisterGameRequest()
        {
            readFromValue(obj);
        }
		
		~FDeregisterGameRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FDeregisterGameResponse : public FPlayFabBaseModel
    {
		
	
        FDeregisterGameResponse() :
			FPlayFabBaseModel()
			{}
		
		FDeregisterGameResponse(const FDeregisterGameResponse& src) :
			FPlayFabBaseModel()
			{}
			
		FDeregisterGameResponse(const TSharedPtr<FJsonObject>& obj) : FDeregisterGameResponse()
        {
            readFromValue(obj);
        }
		
		~FDeregisterGameResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FEmptyResult : public FPlayFabBaseModel
    {
		
	
        FEmptyResult() :
			FPlayFabBaseModel()
			{}
		
		FEmptyResult(const FEmptyResult& src) :
			FPlayFabBaseModel()
			{}
			
		FEmptyResult(const TSharedPtr<FJsonObject>& obj) : FEmptyResult()
        {
            readFromValue(obj);
        }
		
		~FEmptyResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FEvaluateRandomResultTableRequest : public FPlayFabBaseModel
    {
		
		// The unique identifier of the Random Result Table to use.
		FString TableId;
		// [optional] Specifies the catalog version that should be used to evaluate the Random Result Table.  If unspecified, uses default/primary catalog.
		FString CatalogVersion;
	
        FEvaluateRandomResultTableRequest() :
			FPlayFabBaseModel(),
			TableId(),
			CatalogVersion()
			{}
		
		FEvaluateRandomResultTableRequest(const FEvaluateRandomResultTableRequest& src) :
			FPlayFabBaseModel(),
			TableId(src.TableId),
			CatalogVersion(src.CatalogVersion)
			{}
			
		FEvaluateRandomResultTableRequest(const TSharedPtr<FJsonObject>& obj) : FEvaluateRandomResultTableRequest()
        {
            readFromValue(obj);
        }
		
		~FEvaluateRandomResultTableRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FEvaluateRandomResultTableResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier for the item returned from the Random Result Table evaluation, for the given catalog.
		FString ResultItemId;
	
        FEvaluateRandomResultTableResult() :
			FPlayFabBaseModel(),
			ResultItemId()
			{}
		
		FEvaluateRandomResultTableResult(const FEvaluateRandomResultTableResult& src) :
			FPlayFabBaseModel(),
			ResultItemId(src.ResultItemId)
			{}
			
		FEvaluateRandomResultTableResult(const TSharedPtr<FJsonObject>& obj) : FEvaluateRandomResultTableResult()
        {
            readFromValue(obj);
        }
		
		~FEvaluateRandomResultTableResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FLogStatement : public FPlayFabBaseModel
    {
		
		// [optional] 'Debug', 'Info', or 'Error'
		FString Level;
		// [optional] undefined
		FString Message;
		// [optional] Optional object accompanying the message as contextual information
		FMultitypeVar Data;
	
        FLogStatement() :
			FPlayFabBaseModel(),
			Level(),
			Message(),
			Data()
			{}
		
		FLogStatement(const FLogStatement& src) :
			FPlayFabBaseModel(),
			Level(src.Level),
			Message(src.Message),
			Data(src.Data)
			{}
			
		FLogStatement(const TSharedPtr<FJsonObject>& obj) : FLogStatement()
        {
            readFromValue(obj);
        }
		
		~FLogStatement();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FScriptExecutionError : public FPlayFabBaseModel
    {
		
		// [optional] Error code, such as CloudScriptNotFound, JavascriptException, CloudScriptFunctionArgumentSizeExceeded, CloudScriptAPIRequestCountExceeded, CloudScriptAPIRequestError, or CloudScriptHTTPRequestError
		FString Error;
		// [optional] Details about the error
		FString Message;
		// [optional] Point during the execution of the script at which the error occurred, if any
		FString StackTrace;
	
        FScriptExecutionError() :
			FPlayFabBaseModel(),
			Error(),
			Message(),
			StackTrace()
			{}
		
		FScriptExecutionError(const FScriptExecutionError& src) :
			FPlayFabBaseModel(),
			Error(src.Error),
			Message(src.Message),
			StackTrace(src.StackTrace)
			{}
			
		FScriptExecutionError(const TSharedPtr<FJsonObject>& obj) : FScriptExecutionError()
        {
            readFromValue(obj);
        }
		
		~FScriptExecutionError();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FExecuteCloudScriptResult : public FPlayFabBaseModel
    {
		
		// [optional] The name of the function that executed
		FString FunctionName;
		// The revision of the CloudScript that executed
		int32 Revision;
		// [optional] The object returned from the CloudScript function, if any
		FMultitypeVar FunctionResult;
		// [optional] Entries logged during the function execution. These include both entries logged in the function code using log.info() and log.error() and error entries for API and HTTP request failures.
		TArray<FLogStatement> Logs;
		// undefined
		double ExecutionTimeSeconds;
		// Processor time consumed while executing the function. This does not include time spent waiting on API calls or HTTP requests.
		double ProcessorTimeSeconds;
		// undefined
		uint32 MemoryConsumedBytes;
		// Number of PlayFab API requests issued by the CloudScript function
		int32 APIRequestsIssued;
		// Number of external HTTP requests issued by the CloudScript function
		int32 HttpRequestsIssued;
		// [optional] Information about the error, if any, that occured during execution
		TSharedPtr<FScriptExecutionError> Error;
	
        FExecuteCloudScriptResult() :
			FPlayFabBaseModel(),
			FunctionName(),
			Revision(0),
			FunctionResult(),
			Logs(),
			ExecutionTimeSeconds(0),
			ProcessorTimeSeconds(0),
			MemoryConsumedBytes(0),
			APIRequestsIssued(0),
			HttpRequestsIssued(0),
			Error(nullptr)
			{}
		
		FExecuteCloudScriptResult(const FExecuteCloudScriptResult& src) :
			FPlayFabBaseModel(),
			FunctionName(src.FunctionName),
			Revision(src.Revision),
			FunctionResult(src.FunctionResult),
			Logs(src.Logs),
			ExecutionTimeSeconds(src.ExecutionTimeSeconds),
			ProcessorTimeSeconds(src.ProcessorTimeSeconds),
			MemoryConsumedBytes(src.MemoryConsumedBytes),
			APIRequestsIssued(src.APIRequestsIssued),
			HttpRequestsIssued(src.HttpRequestsIssued),
			Error(src.Error.IsValid() ? MakeShareable(new FScriptExecutionError(*src.Error)) : nullptr)
			{}
			
		FExecuteCloudScriptResult(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptResult()
        {
            readFromValue(obj);
        }
		
		~FExecuteCloudScriptResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FExecuteCloudScriptServerRequest : public FPlayFabBaseModel
    {
		
		// The unique user identifier for the player on whose behalf the script is being run
		FString PlayFabId;
		// The name of the CloudScript function to execute
		FString FunctionName;
		// [optional] Object that is passed in to the function as the first argument
		FMultitypeVar FunctionParameter;
		// [optional] Option for which revision of the CloudScript to execute. 'Latest' executes the most recently created revision, 'Live' executes the current live, published revision, and 'Specific' executes the specified revision. The default value is 'Specific', if the SpeificRevision parameter is specified, otherwise it is 'Live'.
		Boxed<CloudScriptRevisionOption> RevisionSelection;
		// [optional] The specivic revision to execute, when RevisionSelection is set to 'Specific'
		OptionalInt32 SpecificRevision;
		// [optional] Generate a 'player_executed_cloudscript' PlayStream event containing the results of the function execution and other contextual information. This event will show up in the PlayStream debugger console for the player in Game Manager.
		OptionalBool GeneratePlayStreamEvent;
	
        FExecuteCloudScriptServerRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			FunctionName(),
			FunctionParameter(),
			RevisionSelection(),
			SpecificRevision(),
			GeneratePlayStreamEvent()
			{}
		
		FExecuteCloudScriptServerRequest(const FExecuteCloudScriptServerRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			FunctionName(src.FunctionName),
			FunctionParameter(src.FunctionParameter),
			RevisionSelection(src.RevisionSelection),
			SpecificRevision(src.SpecificRevision),
			GeneratePlayStreamEvent(src.GeneratePlayStreamEvent)
			{}
			
		FExecuteCloudScriptServerRequest(const TSharedPtr<FJsonObject>& obj) : FExecuteCloudScriptServerRequest()
        {
            readFromValue(obj);
        }
		
		~FExecuteCloudScriptServerRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FFacebookPlayFabIdPair : public FPlayFabBaseModel
    {
		
		// [optional] Unique Facebook identifier for a user.
		FString FacebookId;
		// [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Facebook identifier.
		FString PlayFabId;
	
        FFacebookPlayFabIdPair() :
			FPlayFabBaseModel(),
			FacebookId(),
			PlayFabId()
			{}
		
		FFacebookPlayFabIdPair(const FFacebookPlayFabIdPair& src) :
			FPlayFabBaseModel(),
			FacebookId(src.FacebookId),
			PlayFabId(src.PlayFabId)
			{}
			
		FFacebookPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FFacebookPlayFabIdPair()
        {
            readFromValue(obj);
        }
		
		~FFacebookPlayFabIdPair();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FFriendInfo : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier for this friend.
		FString FriendPlayFabId;
		// [optional] PlayFab unique username for this friend.
		FString Username;
		// [optional] Title-specific display name for this friend.
		FString TitleDisplayName;
		// [optional] Tags which have been associated with this friend.
		TArray<FString> Tags;
		// [optional] Unique lobby identifier of the Game Server Instance to which this player is currently connected.
		FString CurrentMatchmakerLobbyId;
		// [optional] Available Facebook information (if the user and PlayFab friend are also connected in Facebook).
		TSharedPtr<FUserFacebookInfo> FacebookInfo;
		// [optional] Available Steam information (if the user and PlayFab friend are also connected in Steam).
		TSharedPtr<FUserSteamInfo> SteamInfo;
		// [optional] Available Game Center information (if the user and PlayFab friend are also connected in Game Center).
		TSharedPtr<FUserGameCenterInfo> GameCenterInfo;
	
        FFriendInfo() :
			FPlayFabBaseModel(),
			FriendPlayFabId(),
			Username(),
			TitleDisplayName(),
			Tags(),
			CurrentMatchmakerLobbyId(),
			FacebookInfo(nullptr),
			SteamInfo(nullptr),
			GameCenterInfo(nullptr)
			{}
		
		FFriendInfo(const FFriendInfo& src) :
			FPlayFabBaseModel(),
			FriendPlayFabId(src.FriendPlayFabId),
			Username(src.Username),
			TitleDisplayName(src.TitleDisplayName),
			Tags(src.Tags),
			CurrentMatchmakerLobbyId(src.CurrentMatchmakerLobbyId),
			FacebookInfo(src.FacebookInfo.IsValid() ? MakeShareable(new FUserFacebookInfo(*src.FacebookInfo)) : nullptr),
			SteamInfo(src.SteamInfo.IsValid() ? MakeShareable(new FUserSteamInfo(*src.SteamInfo)) : nullptr),
			GameCenterInfo(src.GameCenterInfo.IsValid() ? MakeShareable(new FUserGameCenterInfo(*src.GameCenterInfo)) : nullptr)
			{}
			
		FFriendInfo(const TSharedPtr<FJsonObject>& obj) : FFriendInfo()
        {
            readFromValue(obj);
        }
		
		~FFriendInfo();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum GameInstanceState
	{
		GameInstanceStateOpen,
		GameInstanceStateClosed
	};
	
	void writeGameInstanceStateEnumJSON(GameInstanceState enumVal, JsonWriter& writer);
	GameInstanceState readGameInstanceStateFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FGetActionGroupResult : public FPlayFabBaseModel
    {
		
		// Action Group name
		FString Name;
		// [optional] Action Group ID
		FString Id;
	
        FGetActionGroupResult() :
			FPlayFabBaseModel(),
			Name(),
			Id()
			{}
		
		FGetActionGroupResult(const FGetActionGroupResult& src) :
			FPlayFabBaseModel(),
			Name(src.Name),
			Id(src.Id)
			{}
			
		FGetActionGroupResult(const TSharedPtr<FJsonObject>& obj) : FGetActionGroupResult()
        {
            readFromValue(obj);
        }
		
		~FGetActionGroupResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetAllActionGroupsRequest : public FPlayFabBaseModel
    {
		
	
        FGetAllActionGroupsRequest() :
			FPlayFabBaseModel()
			{}
		
		FGetAllActionGroupsRequest(const FGetAllActionGroupsRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FGetAllActionGroupsRequest(const TSharedPtr<FJsonObject>& obj) : FGetAllActionGroupsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetAllActionGroupsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetAllActionGroupsResult : public FPlayFabBaseModel
    {
		
		// List of Action Groups.
		TArray<FGetActionGroupResult> ActionGroups;
	
        FGetAllActionGroupsResult() :
			FPlayFabBaseModel(),
			ActionGroups()
			{}
		
		FGetAllActionGroupsResult(const FGetAllActionGroupsResult& src) :
			FPlayFabBaseModel(),
			ActionGroups(src.ActionGroups)
			{}
			
		FGetAllActionGroupsResult(const TSharedPtr<FJsonObject>& obj) : FGetAllActionGroupsResult()
        {
            readFromValue(obj);
        }
		
		~FGetAllActionGroupsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetAllSegmentsRequest : public FPlayFabBaseModel
    {
		
	
        FGetAllSegmentsRequest() :
			FPlayFabBaseModel()
			{}
		
		FGetAllSegmentsRequest(const FGetAllSegmentsRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FGetAllSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetAllSegmentsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetAllSegmentsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetSegmentResult : public FPlayFabBaseModel
    {
		
		// Unique identifier for this segment.
		FString Id;
		// [optional] Segment name.
		FString Name;
		// [optional] Identifier of the segments AB Test, if it is attached to one.
		FString ABTestParent;
	
        FGetSegmentResult() :
			FPlayFabBaseModel(),
			Id(),
			Name(),
			ABTestParent()
			{}
		
		FGetSegmentResult(const FGetSegmentResult& src) :
			FPlayFabBaseModel(),
			Id(src.Id),
			Name(src.Name),
			ABTestParent(src.ABTestParent)
			{}
			
		FGetSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetSegmentResult()
        {
            readFromValue(obj);
        }
		
		~FGetSegmentResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetAllSegmentsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of segments for this title.
		TArray<FGetSegmentResult> Segments;
	
        FGetAllSegmentsResult() :
			FPlayFabBaseModel(),
			Segments()
			{}
		
		FGetAllSegmentsResult(const FGetAllSegmentsResult& src) :
			FPlayFabBaseModel(),
			Segments(src.Segments)
			{}
			
		FGetAllSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetAllSegmentsResult()
        {
            readFromValue(obj);
        }
		
		~FGetAllSegmentsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCatalogItemsRequest : public FPlayFabBaseModel
    {
		
		// [optional] Which catalog is being requested. If null, uses the default catalog.
		FString CatalogVersion;
	
        FGetCatalogItemsRequest() :
			FPlayFabBaseModel(),
			CatalogVersion()
			{}
		
		FGetCatalogItemsRequest(const FGetCatalogItemsRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion)
			{}
			
		FGetCatalogItemsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCatalogItemsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCatalogItemsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of items which can be purchased.
		TArray<FCatalogItem> Catalog;
	
        FGetCatalogItemsResult() :
			FPlayFabBaseModel(),
			Catalog()
			{}
		
		FGetCatalogItemsResult(const FGetCatalogItemsResult& src) :
			FPlayFabBaseModel(),
			Catalog(src.Catalog)
			{}
			
		FGetCatalogItemsResult(const TSharedPtr<FJsonObject>& obj) : FGetCatalogItemsResult()
        {
            readFromValue(obj);
        }
		
		~FGetCatalogItemsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterDataRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Specific keys to search for in the custom user data.
		TArray<FString> Keys;
		// [optional] The version that currently exists according to the caller. The call will return the data for all of the keys if the version in the system is greater than this.
		OptionalUint32 IfChangedFromDataVersion;
	
        FGetCharacterDataRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			Keys(),
			IfChangedFromDataVersion()
			{}
		
		FGetCharacterDataRequest(const FGetCharacterDataRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			Keys(src.Keys),
			IfChangedFromDataVersion(src.IfChangedFromDataVersion)
			{}
			
		FGetCharacterDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum UserDataPermission
	{
		UserDataPermissionPrivate,
		UserDataPermissionPublic
	};
	
	void writeUserDataPermissionEnumJSON(UserDataPermission enumVal, JsonWriter& writer);
	UserDataPermission readUserDataPermissionFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FUserDataRecord : public FPlayFabBaseModel
    {
		
		// [optional] Data stored for the specified user data key.
		FString Value;
		// Timestamp for when this data was last updated.
		FDateTime LastUpdated;
		// [optional] Indicates whether this data can be read by all users (public) or only the user (private). This is used for GetUserData requests being made by one player about another player.
		Boxed<UserDataPermission> Permission;
	
        FUserDataRecord() :
			FPlayFabBaseModel(),
			Value(),
			LastUpdated(0),
			Permission()
			{}
		
		FUserDataRecord(const FUserDataRecord& src) :
			FPlayFabBaseModel(),
			Value(src.Value),
			LastUpdated(src.LastUpdated),
			Permission(src.Permission)
			{}
			
		FUserDataRecord(const TSharedPtr<FJsonObject>& obj) : FUserDataRecord()
        {
            readFromValue(obj);
        }
		
		~FUserDataRecord();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterDataResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Indicates the current version of the data that has been set. This is incremented with every set call for that type of data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
		uint32 DataVersion;
		// [optional] User specific data for this title.
		TMap<FString, FUserDataRecord> Data;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
	
        FGetCharacterDataResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			DataVersion(0),
			Data(),
			CharacterId()
			{}
		
		FGetCharacterDataResult(const FGetCharacterDataResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			DataVersion(src.DataVersion),
			Data(src.Data),
			CharacterId(src.CharacterId)
			{}
			
		FGetCharacterDataResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterInventoryRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Used to limit results to only those from a specific catalog version.
		FString CatalogVersion;
	
        FGetCharacterInventoryRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			CatalogVersion()
			{}
		
		FGetCharacterInventoryRequest(const FGetCharacterInventoryRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			CatalogVersion(src.CatalogVersion)
			{}
			
		FGetCharacterInventoryRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterInventoryRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterInventoryRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FVirtualCurrencyRechargeTime : public FPlayFabBaseModel
    {
		
		// Time remaining (in seconds) before the next recharge increment of the virtual currency.
		int32 SecondsToRecharge;
		// Server timestamp in UTC indicating the next time the virtual currency will be incremented.
		FDateTime RechargeTime;
		// Maximum value to which the regenerating currency will automatically increment. Note that it can exceed this value through use of the AddUserVirtualCurrency API call. However, it will not regenerate automatically until it has fallen below this value.
		int32 RechargeMax;
	
        FVirtualCurrencyRechargeTime() :
			FPlayFabBaseModel(),
			SecondsToRecharge(0),
			RechargeTime(0),
			RechargeMax(0)
			{}
		
		FVirtualCurrencyRechargeTime(const FVirtualCurrencyRechargeTime& src) :
			FPlayFabBaseModel(),
			SecondsToRecharge(src.SecondsToRecharge),
			RechargeTime(src.RechargeTime),
			RechargeMax(src.RechargeMax)
			{}
			
		FVirtualCurrencyRechargeTime(const TSharedPtr<FJsonObject>& obj) : FVirtualCurrencyRechargeTime()
        {
            readFromValue(obj);
        }
		
		~FVirtualCurrencyRechargeTime();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterInventoryResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Unique identifier of the character for this inventory.
		FString CharacterId;
		// [optional] Array of inventory items belonging to the character.
		TArray<FItemInstance> Inventory;
		// [optional] Array of virtual currency balance(s) belonging to the character.
		TMap<FString, int32> VirtualCurrency;
		// [optional] Array of remaining times and timestamps for virtual currencies.
		TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
	
        FGetCharacterInventoryResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			Inventory(),
			VirtualCurrency(),
			VirtualCurrencyRechargeTimes()
			{}
		
		FGetCharacterInventoryResult(const FGetCharacterInventoryResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			Inventory(src.Inventory),
			VirtualCurrency(src.VirtualCurrency),
			VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes)
			{}
			
		FGetCharacterInventoryResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterInventoryResult()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterInventoryResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterLeaderboardRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Optional character type on which to filter the leaderboard entries.
		FString CharacterType;
		// Unique identifier for the title-specific statistic for the leaderboard.
		FString StatisticName;
		// First entry in the leaderboard to be retrieved.
		int32 StartPosition;
		// Maximum number of entries to retrieve.
		int32 MaxResultsCount;
	
        FGetCharacterLeaderboardRequest() :
			FPlayFabBaseModel(),
			CharacterId(),
			CharacterType(),
			StatisticName(),
			StartPosition(0),
			MaxResultsCount(0)
			{}
		
		FGetCharacterLeaderboardRequest(const FGetCharacterLeaderboardRequest& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId),
			CharacterType(src.CharacterType),
			StatisticName(src.StatisticName),
			StartPosition(src.StartPosition),
			MaxResultsCount(src.MaxResultsCount)
			{}
			
		FGetCharacterLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterLeaderboardRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterLeaderboardRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterLeaderboardResult : public FPlayFabBaseModel
    {
		
		// [optional] Ordered list of leaderboard entries.
		TArray<FCharacterLeaderboardEntry> Leaderboard;
	
        FGetCharacterLeaderboardResult() :
			FPlayFabBaseModel(),
			Leaderboard()
			{}
		
		FGetCharacterLeaderboardResult(const FGetCharacterLeaderboardResult& src) :
			FPlayFabBaseModel(),
			Leaderboard(src.Leaderboard)
			{}
			
		FGetCharacterLeaderboardResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterLeaderboardResult()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterLeaderboardResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterStatisticsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
	
        FGetCharacterStatisticsRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId()
			{}
		
		FGetCharacterStatisticsRequest(const FGetCharacterStatisticsRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId)
			{}
			
		FGetCharacterStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FGetCharacterStatisticsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterStatisticsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetCharacterStatisticsResult : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier of the user whose character statistics are being returned.
		FString PlayFabId;
		// [optional] Unique identifier of the character for the statistics.
		FString CharacterId;
		// [optional] Character statistics for the requested user.
		TMap<FString, int32> CharacterStatistics;
	
        FGetCharacterStatisticsResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			CharacterStatistics()
			{}
		
		FGetCharacterStatisticsResult(const FGetCharacterStatisticsResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			CharacterStatistics(src.CharacterStatistics)
			{}
			
		FGetCharacterStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FGetCharacterStatisticsResult()
        {
            readFromValue(obj);
        }
		
		~FGetCharacterStatisticsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetContentDownloadUrlRequest : public FPlayFabBaseModel
    {
		
		// Key of the content item to fetch, usually formatted as a path, e.g. images/a.png
		FString Key;
		// [optional] HTTP method to fetch item - GET or HEAD. Use HEAD when only fetching metadata. Default is GET.
		FString HttpMethod;
		// [optional] True if download through CDN. CDN provides better download bandwidth and time. However, if you want latest, non-cached version of the content, set this to false. Default is true.
		OptionalBool ThruCDN;
	
        FGetContentDownloadUrlRequest() :
			FPlayFabBaseModel(),
			Key(),
			HttpMethod(),
			ThruCDN()
			{}
		
		FGetContentDownloadUrlRequest(const FGetContentDownloadUrlRequest& src) :
			FPlayFabBaseModel(),
			Key(src.Key),
			HttpMethod(src.HttpMethod),
			ThruCDN(src.ThruCDN)
			{}
			
		FGetContentDownloadUrlRequest(const TSharedPtr<FJsonObject>& obj) : FGetContentDownloadUrlRequest()
        {
            readFromValue(obj);
        }
		
		~FGetContentDownloadUrlRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetContentDownloadUrlResult : public FPlayFabBaseModel
    {
		
		// [optional] URL for downloading content via HTTP GET or HEAD method. The URL will expire in 1 hour.
		FString URL;
	
        FGetContentDownloadUrlResult() :
			FPlayFabBaseModel(),
			URL()
			{}
		
		FGetContentDownloadUrlResult(const FGetContentDownloadUrlResult& src) :
			FPlayFabBaseModel(),
			URL(src.URL)
			{}
			
		FGetContentDownloadUrlResult(const TSharedPtr<FJsonObject>& obj) : FGetContentDownloadUrlResult()
        {
            readFromValue(obj);
        }
		
		~FGetContentDownloadUrlResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetFriendLeaderboardRequest : public FPlayFabBaseModel
    {
		
		// The player whose friend leaderboard to get
		FString PlayFabId;
		// Statistic used to rank friends for this leaderboard.
		FString StatisticName;
		// Position in the leaderboard to start this listing (defaults to the first entry).
		int32 StartPosition;
		// Maximum number of entries to retrieve.
		int32 MaxResultsCount;
		// [optional] Indicates whether Steam service friends should be included in the response. Default is true.
		OptionalBool IncludeSteamFriends;
		// [optional] Indicates whether Facebook friends should be included in the response. Default is true.
		OptionalBool IncludeFacebookFriends;
	
        FGetFriendLeaderboardRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			StatisticName(),
			StartPosition(0),
			MaxResultsCount(0),
			IncludeSteamFriends(),
			IncludeFacebookFriends()
			{}
		
		FGetFriendLeaderboardRequest(const FGetFriendLeaderboardRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			StatisticName(src.StatisticName),
			StartPosition(src.StartPosition),
			MaxResultsCount(src.MaxResultsCount),
			IncludeSteamFriends(src.IncludeSteamFriends),
			IncludeFacebookFriends(src.IncludeFacebookFriends)
			{}
			
		FGetFriendLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetFriendLeaderboardRequest()
        {
            readFromValue(obj);
        }
		
		~FGetFriendLeaderboardRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetFriendsListRequest : public FPlayFabBaseModel
    {
		
		// PlayFab identifier of the player whose friend list to get.
		FString PlayFabId;
		// [optional] Indicates whether Steam service friends should be included in the response. Default is true.
		OptionalBool IncludeSteamFriends;
		// [optional] Indicates whether Facebook friends should be included in the response. Default is true.
		OptionalBool IncludeFacebookFriends;
	
        FGetFriendsListRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			IncludeSteamFriends(),
			IncludeFacebookFriends()
			{}
		
		FGetFriendsListRequest(const FGetFriendsListRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			IncludeSteamFriends(src.IncludeSteamFriends),
			IncludeFacebookFriends(src.IncludeFacebookFriends)
			{}
			
		FGetFriendsListRequest(const TSharedPtr<FJsonObject>& obj) : FGetFriendsListRequest()
        {
            readFromValue(obj);
        }
		
		~FGetFriendsListRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetFriendsListResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of friends found.
		TArray<FFriendInfo> Friends;
	
        FGetFriendsListResult() :
			FPlayFabBaseModel(),
			Friends()
			{}
		
		FGetFriendsListResult(const FGetFriendsListResult& src) :
			FPlayFabBaseModel(),
			Friends(src.Friends)
			{}
			
		FGetFriendsListResult(const TSharedPtr<FJsonObject>& obj) : FGetFriendsListResult()
        {
            readFromValue(obj);
        }
		
		~FGetFriendsListResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardAroundCharacterRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title-specific statistic for the leaderboard.
		FString StatisticName;
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Optional character type on which to filter the leaderboard entries.
		FString CharacterType;
		// Maximum number of entries to retrieve.
		int32 MaxResultsCount;
	
        FGetLeaderboardAroundCharacterRequest() :
			FPlayFabBaseModel(),
			StatisticName(),
			PlayFabId(),
			CharacterId(),
			CharacterType(),
			MaxResultsCount(0)
			{}
		
		FGetLeaderboardAroundCharacterRequest(const FGetLeaderboardAroundCharacterRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			CharacterType(src.CharacterType),
			MaxResultsCount(src.MaxResultsCount)
			{}
			
		FGetLeaderboardAroundCharacterRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundCharacterRequest()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardAroundCharacterRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardAroundCharacterResult : public FPlayFabBaseModel
    {
		
		// [optional] Ordered list of leaderboard entries.
		TArray<FCharacterLeaderboardEntry> Leaderboard;
	
        FGetLeaderboardAroundCharacterResult() :
			FPlayFabBaseModel(),
			Leaderboard()
			{}
		
		FGetLeaderboardAroundCharacterResult(const FGetLeaderboardAroundCharacterResult& src) :
			FPlayFabBaseModel(),
			Leaderboard(src.Leaderboard)
			{}
			
		FGetLeaderboardAroundCharacterResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundCharacterResult()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardAroundCharacterResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardAroundUserRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title-specific statistic for the leaderboard.
		FString StatisticName;
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Maximum number of entries to retrieve.
		int32 MaxResultsCount;
	
        FGetLeaderboardAroundUserRequest() :
			FPlayFabBaseModel(),
			StatisticName(),
			PlayFabId(),
			MaxResultsCount(0)
			{}
		
		FGetLeaderboardAroundUserRequest(const FGetLeaderboardAroundUserRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			PlayFabId(src.PlayFabId),
			MaxResultsCount(src.MaxResultsCount)
			{}
			
		FGetLeaderboardAroundUserRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundUserRequest()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardAroundUserRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPlayerLeaderboardEntry : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier of the user for this leaderboard entry.
		FString PlayFabId;
		// [optional] Title-specific display name of the user for this leaderboard entry.
		FString DisplayName;
		// Specific value of the user's statistic.
		int32 StatValue;
		// User's overall position in the leaderboard.
		int32 Position;
	
        FPlayerLeaderboardEntry() :
			FPlayFabBaseModel(),
			PlayFabId(),
			DisplayName(),
			StatValue(0),
			Position(0)
			{}
		
		FPlayerLeaderboardEntry(const FPlayerLeaderboardEntry& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			DisplayName(src.DisplayName),
			StatValue(src.StatValue),
			Position(src.Position)
			{}
			
		FPlayerLeaderboardEntry(const TSharedPtr<FJsonObject>& obj) : FPlayerLeaderboardEntry()
        {
            readFromValue(obj);
        }
		
		~FPlayerLeaderboardEntry();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardAroundUserResult : public FPlayFabBaseModel
    {
		
		// [optional] Ordered list of leaderboard entries.
		TArray<FPlayerLeaderboardEntry> Leaderboard;
	
        FGetLeaderboardAroundUserResult() :
			FPlayFabBaseModel(),
			Leaderboard()
			{}
		
		FGetLeaderboardAroundUserResult(const FGetLeaderboardAroundUserResult& src) :
			FPlayFabBaseModel(),
			Leaderboard(src.Leaderboard)
			{}
			
		FGetLeaderboardAroundUserResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardAroundUserResult()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardAroundUserResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardForUsersCharactersRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title-specific statistic for the leaderboard.
		FString StatisticName;
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Maximum number of entries to retrieve.
		int32 MaxResultsCount;
	
        FGetLeaderboardForUsersCharactersRequest() :
			FPlayFabBaseModel(),
			StatisticName(),
			PlayFabId(),
			MaxResultsCount(0)
			{}
		
		FGetLeaderboardForUsersCharactersRequest(const FGetLeaderboardForUsersCharactersRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			PlayFabId(src.PlayFabId),
			MaxResultsCount(src.MaxResultsCount)
			{}
			
		FGetLeaderboardForUsersCharactersRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardForUsersCharactersRequest()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardForUsersCharactersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardForUsersCharactersResult : public FPlayFabBaseModel
    {
		
		// [optional] Ordered list of leaderboard entries.
		TArray<FCharacterLeaderboardEntry> Leaderboard;
	
        FGetLeaderboardForUsersCharactersResult() :
			FPlayFabBaseModel(),
			Leaderboard()
			{}
		
		FGetLeaderboardForUsersCharactersResult(const FGetLeaderboardForUsersCharactersResult& src) :
			FPlayFabBaseModel(),
			Leaderboard(src.Leaderboard)
			{}
			
		FGetLeaderboardForUsersCharactersResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardForUsersCharactersResult()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardForUsersCharactersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the title-specific statistic for the leaderboard.
		FString StatisticName;
		// First entry in the leaderboard to be retrieved.
		int32 StartPosition;
		// Maximum number of entries to retrieve.
		int32 MaxResultsCount;
	
        FGetLeaderboardRequest() :
			FPlayFabBaseModel(),
			StatisticName(),
			StartPosition(0),
			MaxResultsCount(0)
			{}
		
		FGetLeaderboardRequest(const FGetLeaderboardRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			StartPosition(src.StartPosition),
			MaxResultsCount(src.MaxResultsCount)
			{}
			
		FGetLeaderboardRequest(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardRequest()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetLeaderboardResult : public FPlayFabBaseModel
    {
		
		// [optional] Ordered list of leaderboard entries.
		TArray<FPlayerLeaderboardEntry> Leaderboard;
	
        FGetLeaderboardResult() :
			FPlayFabBaseModel(),
			Leaderboard()
			{}
		
		FGetLeaderboardResult(const FGetLeaderboardResult& src) :
			FPlayFabBaseModel(),
			Leaderboard(src.Leaderboard)
			{}
			
		FGetLeaderboardResult(const TSharedPtr<FJsonObject>& obj) : FGetLeaderboardResult()
        {
            readFromValue(obj);
        }
		
		~FGetLeaderboardResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerCombinedInfoRequestParams : public FPlayFabBaseModel
    {
		
		// Whether to get the player's account Info. Defaults to false
		bool GetUserAccountInfo;
		// Whether to get the player's inventory. Defaults to false
		bool GetUserInventory;
		// Whether to get the player's virtual currency balances. Defaults to false
		bool GetUserVirtualCurrency;
		// Whether to get the player's custom data. Defaults to false
		bool GetUserData;
		// [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if UserDataKeys is false
		TArray<FString> UserDataKeys;
		// Whether to get the player's read only data. Defaults to false
		bool GetUserReadOnlyData;
		// [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if GetUserReadOnlyData is false
		TArray<FString> UserReadOnlyDataKeys;
		// Whether to get character inventories. Defaults to false.
		bool GetCharacterInventories;
		// Whether to get the list of characters. Defaults to false.
		bool GetCharacterList;
		// Whether to get title data. Defaults to false.
		bool GetTitleData;
		// [optional] Specific keys to search for in the custom data. Leave null to get all keys. Has no effect if GetTitleData is false
		TArray<FString> TitleDataKeys;
		// Whether to get player statistics. Defaults to false.
		bool GetPlayerStatistics;
		// [optional] Specific statistics to retrieve. Leave null to get all keys. Has no effect if GetPlayerStatistics is false
		TArray<FString> PlayerStatisticNames;
	
        FGetPlayerCombinedInfoRequestParams() :
			FPlayFabBaseModel(),
			GetUserAccountInfo(false),
			GetUserInventory(false),
			GetUserVirtualCurrency(false),
			GetUserData(false),
			UserDataKeys(),
			GetUserReadOnlyData(false),
			UserReadOnlyDataKeys(),
			GetCharacterInventories(false),
			GetCharacterList(false),
			GetTitleData(false),
			TitleDataKeys(),
			GetPlayerStatistics(false),
			PlayerStatisticNames()
			{}
		
		FGetPlayerCombinedInfoRequestParams(const FGetPlayerCombinedInfoRequestParams& src) :
			FPlayFabBaseModel(),
			GetUserAccountInfo(src.GetUserAccountInfo),
			GetUserInventory(src.GetUserInventory),
			GetUserVirtualCurrency(src.GetUserVirtualCurrency),
			GetUserData(src.GetUserData),
			UserDataKeys(src.UserDataKeys),
			GetUserReadOnlyData(src.GetUserReadOnlyData),
			UserReadOnlyDataKeys(src.UserReadOnlyDataKeys),
			GetCharacterInventories(src.GetCharacterInventories),
			GetCharacterList(src.GetCharacterList),
			GetTitleData(src.GetTitleData),
			TitleDataKeys(src.TitleDataKeys),
			GetPlayerStatistics(src.GetPlayerStatistics),
			PlayerStatisticNames(src.PlayerStatisticNames)
			{}
			
		FGetPlayerCombinedInfoRequestParams(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoRequestParams()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerCombinedInfoRequestParams();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerCombinedInfoRequest : public FPlayFabBaseModel
    {
		
		// PlayFabId of the user whose data will be returned
		FString PlayFabId;
		// Flags for which pieces of info to return for the user.
		FGetPlayerCombinedInfoRequestParams InfoRequestParameters;
	
        FGetPlayerCombinedInfoRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			InfoRequestParameters()
			{}
		
		FGetPlayerCombinedInfoRequest(const FGetPlayerCombinedInfoRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			InfoRequestParameters(src.InfoRequestParameters)
			{}
			
		FGetPlayerCombinedInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerCombinedInfoRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStatisticValue : public FPlayFabBaseModel
    {
		
		// [optional] unique name of the statistic
		FString StatisticName;
		// statistic value for the player
		int32 Value;
		// for updates to an existing statistic value for a player, the version of the statistic when it was loaded
		uint32 Version;
	
        FStatisticValue() :
			FPlayFabBaseModel(),
			StatisticName(),
			Value(0),
			Version(0)
			{}
		
		FStatisticValue(const FStatisticValue& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			Value(src.Value),
			Version(src.Version)
			{}
			
		FStatisticValue(const TSharedPtr<FJsonObject>& obj) : FStatisticValue()
        {
            readFromValue(obj);
        }
		
		~FStatisticValue();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerCombinedInfoResultPayload : public FPlayFabBaseModel
    {
		
		// [optional] Account information for the user. This is always retrieved.
		TSharedPtr<FUserAccountInfo> AccountInfo;
		// [optional] Array of inventory items in the user's current inventory.
		TArray<FItemInstance> UserInventory;
		// [optional] Dictionary of virtual currency balance(s) belonging to the user.
		TMap<FString, int32> UserVirtualCurrency;
		// [optional] Dictionary of remaining times and timestamps for virtual currencies.
		TMap<FString, FVirtualCurrencyRechargeTime> UserVirtualCurrencyRechargeTimes;
		// [optional] User specific custom data.
		TMap<FString, FUserDataRecord> UserData;
		// The version of the UserData that was returned.
		uint32 UserDataVersion;
		// [optional] User specific read-only data.
		TMap<FString, FUserDataRecord> UserReadOnlyData;
		// The version of the Read-Only UserData that was returned.
		uint32 UserReadOnlyDataVersion;
		// [optional] List of characters for the user.
		TArray<FCharacterResult> CharacterList;
		// [optional] Inventories for each character for the user.
		TArray<FCharacterInventory> CharacterInventories;
		// [optional] Title data for this title.
		TMap<FString, FString> TitleData;
		// [optional] List of statistics for this player.
		TArray<FStatisticValue> PlayerStatistics;
	
        FGetPlayerCombinedInfoResultPayload() :
			FPlayFabBaseModel(),
			AccountInfo(nullptr),
			UserInventory(),
			UserVirtualCurrency(),
			UserVirtualCurrencyRechargeTimes(),
			UserData(),
			UserDataVersion(0),
			UserReadOnlyData(),
			UserReadOnlyDataVersion(0),
			CharacterList(),
			CharacterInventories(),
			TitleData(),
			PlayerStatistics()
			{}
		
		FGetPlayerCombinedInfoResultPayload(const FGetPlayerCombinedInfoResultPayload& src) :
			FPlayFabBaseModel(),
			AccountInfo(src.AccountInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.AccountInfo)) : nullptr),
			UserInventory(src.UserInventory),
			UserVirtualCurrency(src.UserVirtualCurrency),
			UserVirtualCurrencyRechargeTimes(src.UserVirtualCurrencyRechargeTimes),
			UserData(src.UserData),
			UserDataVersion(src.UserDataVersion),
			UserReadOnlyData(src.UserReadOnlyData),
			UserReadOnlyDataVersion(src.UserReadOnlyDataVersion),
			CharacterList(src.CharacterList),
			CharacterInventories(src.CharacterInventories),
			TitleData(src.TitleData),
			PlayerStatistics(src.PlayerStatistics)
			{}
			
		FGetPlayerCombinedInfoResultPayload(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoResultPayload()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerCombinedInfoResultPayload();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerCombinedInfoResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Results for requested info.
		TSharedPtr<FGetPlayerCombinedInfoResultPayload> InfoResultPayload;
	
        FGetPlayerCombinedInfoResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			InfoResultPayload(nullptr)
			{}
		
		FGetPlayerCombinedInfoResult(const FGetPlayerCombinedInfoResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			InfoResultPayload(src.InfoResultPayload.IsValid() ? MakeShareable(new FGetPlayerCombinedInfoResultPayload(*src.InfoResultPayload)) : nullptr)
			{}
			
		FGetPlayerCombinedInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerCombinedInfoResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerCombinedInfoResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerSegmentsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of segments the requested player currently belongs to.
		TArray<FGetSegmentResult> Segments;
	
        FGetPlayerSegmentsResult() :
			FPlayFabBaseModel(),
			Segments()
			{}
		
		FGetPlayerSegmentsResult(const FGetPlayerSegmentsResult& src) :
			FPlayFabBaseModel(),
			Segments(src.Segments)
			{}
			
		FGetPlayerSegmentsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerSegmentsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerSegmentsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayersInSegmentRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for this segment.
		FString SegmentId;
		// [optional] Number of seconds to keep the continuation token active. After token expiration it is not possible to continue paging results. Default is 300 (5 minutes). Maximum is 1,800 (30 minutes).
		OptionalUint32 SecondsToLive;
		// [optional] Maximum number of profiles to load. Default is 1,000. Maximum is 10,000.
		OptionalUint32 MaxBatchSize;
		// [optional] Continuation token if retrieving subsequent pages of results.
		FString ContinuationToken;
	
        FGetPlayersInSegmentRequest() :
			FPlayFabBaseModel(),
			SegmentId(),
			SecondsToLive(),
			MaxBatchSize(),
			ContinuationToken()
			{}
		
		FGetPlayersInSegmentRequest(const FGetPlayersInSegmentRequest& src) :
			FPlayFabBaseModel(),
			SegmentId(src.SegmentId),
			SecondsToLive(src.SecondsToLive),
			MaxBatchSize(src.MaxBatchSize),
			ContinuationToken(src.ContinuationToken)
			{}
			
		FGetPlayersInSegmentRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayersInSegmentRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayersInSegmentRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum LoginIdentityProvider
	{
		LoginIdentityProviderUnknown,
		LoginIdentityProviderPlayFab,
		LoginIdentityProviderCustom,
		LoginIdentityProviderGameCenter,
		LoginIdentityProviderGooglePlay,
		LoginIdentityProviderSteam,
		LoginIdentityProviderXBoxLive,
		LoginIdentityProviderPSN,
		LoginIdentityProviderKongregate,
		LoginIdentityProviderFacebook,
		LoginIdentityProviderIOSDevice,
		LoginIdentityProviderAndroidDevice,
		LoginIdentityProviderTwitch
	};
	
	void writeLoginIdentityProviderEnumJSON(LoginIdentityProvider enumVal, JsonWriter& writer);
	LoginIdentityProvider readLoginIdentityProviderFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FPlayerLocation : public FPlayFabBaseModel
    {
		
		// The two-character continent code for this location
		ContinentCode pfContinentCode;
		// The two-character ISO 3166-1 country code for the country associated with the location
		CountryCode pfCountryCode;
		// [optional] City of the player's geographic location.
		FString City;
		// [optional] Latitude coordinate of the player's geographic location.
		OptionalDouble Latitude;
		// [optional] Longitude coordinate of the player's geographic location.
		OptionalDouble Longitude;
	
        FPlayerLocation() :
			FPlayFabBaseModel(),
			pfContinentCode(),
			pfCountryCode(),
			City(),
			Latitude(),
			Longitude()
			{}
		
		FPlayerLocation(const FPlayerLocation& src) :
			FPlayFabBaseModel(),
			pfContinentCode(src.pfContinentCode),
			pfCountryCode(src.pfCountryCode),
			City(src.City),
			Latitude(src.Latitude),
			Longitude(src.Longitude)
			{}
			
		FPlayerLocation(const TSharedPtr<FJsonObject>& obj) : FPlayerLocation()
        {
            readFromValue(obj);
        }
		
		~FPlayerLocation();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum PushNotificationPlatform
	{
		PushNotificationPlatformApplePushNotificationService,
		PushNotificationPlatformGoogleCloudMessaging
	};
	
	void writePushNotificationPlatformEnumJSON(PushNotificationPlatform enumVal, JsonWriter& writer);
	PushNotificationPlatform readPushNotificationPlatformFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FPushNotificationRegistration : public FPlayFabBaseModel
    {
		
		// [optional] Push notification platform
		Boxed<PushNotificationPlatform> Platform;
		// [optional] Notification configured endpoint
		FString NotificationEndpointARN;
	
        FPushNotificationRegistration() :
			FPlayFabBaseModel(),
			Platform(),
			NotificationEndpointARN()
			{}
		
		FPushNotificationRegistration(const FPushNotificationRegistration& src) :
			FPlayFabBaseModel(),
			Platform(src.Platform),
			NotificationEndpointARN(src.NotificationEndpointARN)
			{}
			
		FPushNotificationRegistration(const TSharedPtr<FJsonObject>& obj) : FPushNotificationRegistration()
        {
            readFromValue(obj);
        }
		
		~FPushNotificationRegistration();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPlayerLinkedAccount : public FPlayFabBaseModel
    {
		
		// [optional] Authentication platform
		Boxed<LoginIdentityProvider> Platform;
		// [optional] Platform user identifier
		FString PlatformUserId;
		// [optional] Linked account's username
		FString Username;
		// [optional] Linked account's email
		FString Email;
	
        FPlayerLinkedAccount() :
			FPlayFabBaseModel(),
			Platform(),
			PlatformUserId(),
			Username(),
			Email()
			{}
		
		FPlayerLinkedAccount(const FPlayerLinkedAccount& src) :
			FPlayFabBaseModel(),
			Platform(src.Platform),
			PlatformUserId(src.PlatformUserId),
			Username(src.Username),
			Email(src.Email)
			{}
			
		FPlayerLinkedAccount(const TSharedPtr<FJsonObject>& obj) : FPlayerLinkedAccount()
        {
            readFromValue(obj);
        }
		
		~FPlayerLinkedAccount();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPlayerStatistic : public FPlayFabBaseModel
    {
		
		// [optional] Statistic ID
		FString Id;
		// Statistic version (0 if not a versioned statistic)
		int32 StatisticVersion;
		// Current statistic value
		int32 StatisticValue;
		// [optional] Statistic name
		FString Name;
	
        FPlayerStatistic() :
			FPlayFabBaseModel(),
			Id(),
			StatisticVersion(0),
			StatisticValue(0),
			Name()
			{}
		
		FPlayerStatistic(const FPlayerStatistic& src) :
			FPlayFabBaseModel(),
			Id(src.Id),
			StatisticVersion(src.StatisticVersion),
			StatisticValue(src.StatisticValue),
			Name(src.Name)
			{}
			
		FPlayerStatistic(const TSharedPtr<FJsonObject>& obj) : FPlayerStatistic()
        {
            readFromValue(obj);
        }
		
		~FPlayerStatistic();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPlayerProfile : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab Player ID
		FString PlayerId;
		// [optional] Title ID this profile applies to
		FString TitleId;
		// [optional] Player Display Name
		FString DisplayName;
		// [optional] Publisher this player belongs to
		FString PublisherId;
		// [optional] Player account origination
		Boxed<LoginIdentityProvider> Origination;
		// [optional] Player record created
		OptionalTime Created;
		// [optional] Last login
		OptionalTime LastLogin;
		// [optional] Banned until UTC Date. If permanent ban this is set for 20 years after the original ban date.
		OptionalTime BannedUntil;
		// [optional] Dictionary of player's statistics using only the latest version's value
		TMap<FString, int32> Statistics;
		// [optional] A sum of player's total purchases in USD across all currencies.
		OptionalUint32 TotalValueToDateInUSD;
		// [optional] Dictionary of player's total purchases by currency.
		TMap<FString, uint32> ValuesToDate;
		// [optional] List of player's tags for segmentation.
		TArray<FString> Tags;
		// [optional] Dictionary of player's locations by type.
		TMap<FString, FPlayerLocation> Locations;
		// [optional] Dictionary of player's virtual currency balances
		TMap<FString, int32> VirtualCurrencyBalances;
		// [optional] Array of ad campaigns player has been attributed to
		TArray<FAdCampaignAttribution> AdCampaignAttributions;
		// [optional] Array of configured push notification end points
		TArray<FPushNotificationRegistration> PushNotificationRegistrations;
		// [optional] Array of third party accounts linked to this player
		TArray<FPlayerLinkedAccount> LinkedAccounts;
		// [optional] Array of player statistics
		TArray<FPlayerStatistic> PlayerStatistics;
	
        FPlayerProfile() :
			FPlayFabBaseModel(),
			PlayerId(),
			TitleId(),
			DisplayName(),
			PublisherId(),
			Origination(),
			Created(),
			LastLogin(),
			BannedUntil(),
			Statistics(),
			TotalValueToDateInUSD(),
			ValuesToDate(),
			Tags(),
			Locations(),
			VirtualCurrencyBalances(),
			AdCampaignAttributions(),
			PushNotificationRegistrations(),
			LinkedAccounts(),
			PlayerStatistics()
			{}
		
		FPlayerProfile(const FPlayerProfile& src) :
			FPlayFabBaseModel(),
			PlayerId(src.PlayerId),
			TitleId(src.TitleId),
			DisplayName(src.DisplayName),
			PublisherId(src.PublisherId),
			Origination(src.Origination),
			Created(src.Created),
			LastLogin(src.LastLogin),
			BannedUntil(src.BannedUntil),
			Statistics(src.Statistics),
			TotalValueToDateInUSD(src.TotalValueToDateInUSD),
			ValuesToDate(src.ValuesToDate),
			Tags(src.Tags),
			Locations(src.Locations),
			VirtualCurrencyBalances(src.VirtualCurrencyBalances),
			AdCampaignAttributions(src.AdCampaignAttributions),
			PushNotificationRegistrations(src.PushNotificationRegistrations),
			LinkedAccounts(src.LinkedAccounts),
			PlayerStatistics(src.PlayerStatistics)
			{}
			
		FPlayerProfile(const TSharedPtr<FJsonObject>& obj) : FPlayerProfile()
        {
            readFromValue(obj);
        }
		
		~FPlayerProfile();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayersInSegmentResult : public FPlayFabBaseModel
    {
		
		// Count of profiles matching this segment.
		int32 ProfilesInSegment;
		// [optional] Continuation token to use to retrieve subsequent pages of results. If token returns null there are no more results.
		FString ContinuationToken;
		// [optional] Array of player profiles in this segment.
		TArray<FPlayerProfile> PlayerProfiles;
	
        FGetPlayersInSegmentResult() :
			FPlayFabBaseModel(),
			ProfilesInSegment(0),
			ContinuationToken(),
			PlayerProfiles()
			{}
		
		FGetPlayersInSegmentResult(const FGetPlayersInSegmentResult& src) :
			FPlayFabBaseModel(),
			ProfilesInSegment(src.ProfilesInSegment),
			ContinuationToken(src.ContinuationToken),
			PlayerProfiles(src.PlayerProfiles)
			{}
			
		FGetPlayersInSegmentResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayersInSegmentResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayersInSegmentResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayersSegmentsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FGetPlayersSegmentsRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FGetPlayersSegmentsRequest(const FGetPlayersSegmentsRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FGetPlayersSegmentsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayersSegmentsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayersSegmentsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStatisticNameVersion : public FPlayFabBaseModel
    {
		
		// unique name of the statistic
		FString StatisticName;
		// the version of the statistic to be returned
		uint32 Version;
	
        FStatisticNameVersion() :
			FPlayFabBaseModel(),
			StatisticName(),
			Version(0)
			{}
		
		FStatisticNameVersion(const FStatisticNameVersion& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			Version(src.Version)
			{}
			
		FStatisticNameVersion(const TSharedPtr<FJsonObject>& obj) : FStatisticNameVersion()
        {
            readFromValue(obj);
        }
		
		~FStatisticNameVersion();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticsRequest : public FPlayFabBaseModel
    {
		
		// user for whom statistics are being requested
		FString PlayFabId;
		// [optional] statistics to return
		TArray<FString> StatisticNames;
		// [optional] statistics to return, if StatisticNames is not set (only statistics which have a version matching that provided will be returned)
		TArray<FStatisticNameVersion> StatisticNameVersions;
	
        FGetPlayerStatisticsRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			StatisticNames(),
			StatisticNameVersions()
			{}
		
		FGetPlayerStatisticsRequest(const FGetPlayerStatisticsRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			StatisticNames(src.StatisticNames),
			StatisticNameVersions(src.StatisticNameVersions)
			{}
			
		FGetPlayerStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticsResult : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier of the user whose statistics are being returned
		FString PlayFabId;
		// [optional] User statistics for the requested user.
		TArray<FStatisticValue> Statistics;
	
        FGetPlayerStatisticsResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Statistics()
			{}
		
		FGetPlayerStatisticsResult(const FGetPlayerStatisticsResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Statistics(src.Statistics)
			{}
			
		FGetPlayerStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticVersionsRequest : public FPlayFabBaseModel
    {
		
		// [optional] unique name of the statistic
		FString StatisticName;
	
        FGetPlayerStatisticVersionsRequest() :
			FPlayFabBaseModel(),
			StatisticName()
			{}
		
		FGetPlayerStatisticVersionsRequest(const FGetPlayerStatisticVersionsRequest& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName)
			{}
			
		FGetPlayerStatisticVersionsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticVersionsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FPlayerStatisticVersion : public FPlayFabBaseModel
    {
		
		// [optional] name of the statistic when the version became active
		FString StatisticName;
		// version of the statistic
		uint32 Version;
		// [optional] time at which the statistic version was scheduled to become active, based on the configured ResetInterval
		OptionalTime ScheduledActivationTime;
		// time when the statistic version became active
		FDateTime ActivationTime;
		// [optional] time at which the statistic version was scheduled to become inactive, based on the configured ResetInterval
		OptionalTime ScheduledDeactivationTime;
		// [optional] time when the statistic version became inactive due to statistic version incrementing
		OptionalTime DeactivationTime;
	
        FPlayerStatisticVersion() :
			FPlayFabBaseModel(),
			StatisticName(),
			Version(0),
			ScheduledActivationTime(),
			ActivationTime(0),
			ScheduledDeactivationTime(),
			DeactivationTime()
			{}
		
		FPlayerStatisticVersion(const FPlayerStatisticVersion& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			Version(src.Version),
			ScheduledActivationTime(src.ScheduledActivationTime),
			ActivationTime(src.ActivationTime),
			ScheduledDeactivationTime(src.ScheduledDeactivationTime),
			DeactivationTime(src.DeactivationTime)
			{}
			
		FPlayerStatisticVersion(const TSharedPtr<FJsonObject>& obj) : FPlayerStatisticVersion()
        {
            readFromValue(obj);
        }
		
		~FPlayerStatisticVersion();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerStatisticVersionsResult : public FPlayFabBaseModel
    {
		
		// [optional] version change history of the statistic
		TArray<FPlayerStatisticVersion> StatisticVersions;
	
        FGetPlayerStatisticVersionsResult() :
			FPlayFabBaseModel(),
			StatisticVersions()
			{}
		
		FGetPlayerStatisticVersionsResult(const FGetPlayerStatisticVersionsResult& src) :
			FPlayFabBaseModel(),
			StatisticVersions(src.StatisticVersions)
			{}
			
		FGetPlayerStatisticVersionsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerStatisticVersionsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerStatisticVersionsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerTagsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Optional namespace to filter results by
		FString Namespace;
	
        FGetPlayerTagsRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Namespace()
			{}
		
		FGetPlayerTagsRequest(const FGetPlayerTagsRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Namespace(src.Namespace)
			{}
			
		FGetPlayerTagsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerTagsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayerTagsResult : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Canonical tags (including namespace and tag's name) for the requested user
		TArray<FString> Tags;
	
        FGetPlayerTagsResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Tags()
			{}
		
		FGetPlayerTagsResult(const FGetPlayerTagsResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Tags(src.Tags)
			{}
			
		FGetPlayerTagsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayerTagsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayerTagsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromFacebookIDsRequest : public FPlayFabBaseModel
    {
		
		// Array of unique Facebook identifiers for which the title needs to get PlayFab identifiers.
		TArray<FString> FacebookIDs;
	
        FGetPlayFabIDsFromFacebookIDsRequest() :
			FPlayFabBaseModel(),
			FacebookIDs()
			{}
		
		FGetPlayFabIDsFromFacebookIDsRequest(const FGetPlayFabIDsFromFacebookIDsRequest& src) :
			FPlayFabBaseModel(),
			FacebookIDs(src.FacebookIDs)
			{}
			
		FGetPlayFabIDsFromFacebookIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromFacebookIDsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromFacebookIDsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromFacebookIDsResult : public FPlayFabBaseModel
    {
		
		// [optional] Mapping of Facebook identifiers to PlayFab identifiers.
		TArray<FFacebookPlayFabIdPair> Data;
	
        FGetPlayFabIDsFromFacebookIDsResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPlayFabIDsFromFacebookIDsResult(const FGetPlayFabIDsFromFacebookIDsResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPlayFabIDsFromFacebookIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromFacebookIDsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromFacebookIDsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromSteamIDsRequest : public FPlayFabBaseModel
    {
		
		// [optional] Array of unique Steam identifiers (Steam profile IDs) for which the title needs to get PlayFab identifiers.
		TArray<FString> SteamStringIDs;
	
        FGetPlayFabIDsFromSteamIDsRequest() :
			FPlayFabBaseModel(),
			SteamStringIDs()
			{}
		
		FGetPlayFabIDsFromSteamIDsRequest(const FGetPlayFabIDsFromSteamIDsRequest& src) :
			FPlayFabBaseModel(),
			SteamStringIDs(src.SteamStringIDs)
			{}
			
		FGetPlayFabIDsFromSteamIDsRequest(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromSteamIDsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromSteamIDsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSteamPlayFabIdPair : public FPlayFabBaseModel
    {
		
		// [optional] Unique Steam identifier for a user.
		FString SteamStringId;
		// [optional] Unique PlayFab identifier for a user, or null if no PlayFab account is linked to the Steam identifier.
		FString PlayFabId;
	
        FSteamPlayFabIdPair() :
			FPlayFabBaseModel(),
			SteamStringId(),
			PlayFabId()
			{}
		
		FSteamPlayFabIdPair(const FSteamPlayFabIdPair& src) :
			FPlayFabBaseModel(),
			SteamStringId(src.SteamStringId),
			PlayFabId(src.PlayFabId)
			{}
			
		FSteamPlayFabIdPair(const TSharedPtr<FJsonObject>& obj) : FSteamPlayFabIdPair()
        {
            readFromValue(obj);
        }
		
		~FSteamPlayFabIdPair();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPlayFabIDsFromSteamIDsResult : public FPlayFabBaseModel
    {
		
		// [optional] Mapping of Steam identifiers to PlayFab identifiers.
		TArray<FSteamPlayFabIdPair> Data;
	
        FGetPlayFabIDsFromSteamIDsResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPlayFabIDsFromSteamIDsResult(const FGetPlayFabIDsFromSteamIDsResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPlayFabIDsFromSteamIDsResult(const TSharedPtr<FJsonObject>& obj) : FGetPlayFabIDsFromSteamIDsResult()
        {
            readFromValue(obj);
        }
		
		~FGetPlayFabIDsFromSteamIDsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPublisherDataRequest : public FPlayFabBaseModel
    {
		
		//  array of keys to get back data from the Publisher data blob, set by the admin tools
		TArray<FString> Keys;
	
        FGetPublisherDataRequest() :
			FPlayFabBaseModel(),
			Keys()
			{}
		
		FGetPublisherDataRequest(const FGetPublisherDataRequest& src) :
			FPlayFabBaseModel(),
			Keys(src.Keys)
			{}
			
		FGetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetPublisherDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetPublisherDataResult : public FPlayFabBaseModel
    {
		
		// [optional] a dictionary object of key / value pairs
		TMap<FString, FString> Data;
	
        FGetPublisherDataResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetPublisherDataResult(const FGetPublisherDataResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FGetPublisherDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetPublisherDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetRandomResultTablesRequest : public FPlayFabBaseModel
    {
		
		// [optional] Specifies the catalog version that should be used to retrieve the Random Result Tables.  If unspecified, uses default/primary catalog.
		FString CatalogVersion;
		// The unique identifier of the Random Result Table to use.
		TArray<FString> TableIDs;
	
        FGetRandomResultTablesRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			TableIDs()
			{}
		
		FGetRandomResultTablesRequest(const FGetRandomResultTablesRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			TableIDs(src.TableIDs)
			{}
			
		FGetRandomResultTablesRequest(const TSharedPtr<FJsonObject>& obj) : FGetRandomResultTablesRequest()
        {
            readFromValue(obj);
        }
		
		~FGetRandomResultTablesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum ResultTableNodeType
	{
		ResultTableNodeTypeItemId,
		ResultTableNodeTypeTableId
	};
	
	void writeResultTableNodeTypeEnumJSON(ResultTableNodeType enumVal, JsonWriter& writer);
	ResultTableNodeType readResultTableNodeTypeFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FResultTableNode : public FPlayFabBaseModel
    {
		
		// Whether this entry in the table is an item or a link to another table
		ResultTableNodeType ResultItemType;
		// Either an ItemId, or the TableId of another random result table
		FString ResultItem;
		// How likely this is to be rolled - larger numbers add more weight
		int32 Weight;
	
        FResultTableNode() :
			FPlayFabBaseModel(),
			ResultItemType(),
			ResultItem(),
			Weight(0)
			{}
		
		FResultTableNode(const FResultTableNode& src) :
			FPlayFabBaseModel(),
			ResultItemType(src.ResultItemType),
			ResultItem(src.ResultItem),
			Weight(src.Weight)
			{}
			
		FResultTableNode(const TSharedPtr<FJsonObject>& obj) : FResultTableNode()
        {
            readFromValue(obj);
        }
		
		~FResultTableNode();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRandomResultTableListing : public FPlayFabBaseModel
    {
		
		// [optional] Catalog version this table is associated with
		FString CatalogVersion;
		// Unique name for this drop table
		FString TableId;
		// Child nodes that indicate what kind of drop table item this actually is.
		TArray<FResultTableNode> Nodes;
	
        FRandomResultTableListing() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			TableId(),
			Nodes()
			{}
		
		FRandomResultTableListing(const FRandomResultTableListing& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			TableId(src.TableId),
			Nodes(src.Nodes)
			{}
			
		FRandomResultTableListing(const TSharedPtr<FJsonObject>& obj) : FRandomResultTableListing()
        {
            readFromValue(obj);
        }
		
		~FRandomResultTableListing();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetRandomResultTablesResult : public FPlayFabBaseModel
    {
		
		// [optional] array of random result tables currently available
		TMap<FString, FRandomResultTableListing> Tables;
	
        FGetRandomResultTablesResult() :
			FPlayFabBaseModel(),
			Tables()
			{}
		
		FGetRandomResultTablesResult(const FGetRandomResultTablesResult& src) :
			FPlayFabBaseModel(),
			Tables(src.Tables)
			{}
			
		FGetRandomResultTablesResult(const TSharedPtr<FJsonObject>& obj) : FGetRandomResultTablesResult()
        {
            readFromValue(obj);
        }
		
		~FGetRandomResultTablesResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetSharedGroupDataRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the shared group.
		FString SharedGroupId;
		// [optional] Specific keys to retrieve from the shared group (if not specified, all keys will be returned, while an empty array indicates that no keys should be returned).
		TArray<FString> Keys;
		// [optional] If true, return the list of all members of the shared group.
		OptionalBool GetMembers;
	
        FGetSharedGroupDataRequest() :
			FPlayFabBaseModel(),
			SharedGroupId(),
			Keys(),
			GetMembers()
			{}
		
		FGetSharedGroupDataRequest(const FGetSharedGroupDataRequest& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId),
			Keys(src.Keys),
			GetMembers(src.GetMembers)
			{}
			
		FGetSharedGroupDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetSharedGroupDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetSharedGroupDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSharedGroupDataRecord : public FPlayFabBaseModel
    {
		
		// [optional] Data stored for the specified group data key.
		FString Value;
		// [optional] PlayFabId of the user to last update this value.
		FString LastUpdatedBy;
		// Timestamp for when this data was last updated.
		FDateTime LastUpdated;
		// [optional] Indicates whether this data can be read by all users (public) or only members of the group (private).
		Boxed<UserDataPermission> Permission;
	
        FSharedGroupDataRecord() :
			FPlayFabBaseModel(),
			Value(),
			LastUpdatedBy(),
			LastUpdated(0),
			Permission()
			{}
		
		FSharedGroupDataRecord(const FSharedGroupDataRecord& src) :
			FPlayFabBaseModel(),
			Value(src.Value),
			LastUpdatedBy(src.LastUpdatedBy),
			LastUpdated(src.LastUpdated),
			Permission(src.Permission)
			{}
			
		FSharedGroupDataRecord(const TSharedPtr<FJsonObject>& obj) : FSharedGroupDataRecord()
        {
            readFromValue(obj);
        }
		
		~FSharedGroupDataRecord();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetSharedGroupDataResult : public FPlayFabBaseModel
    {
		
		// [optional] Data for the requested keys.
		TMap<FString, FSharedGroupDataRecord> Data;
		// [optional] List of PlayFabId identifiers for the members of this group, if requested.
		TArray<FString> Members;
	
        FGetSharedGroupDataResult() :
			FPlayFabBaseModel(),
			Data(),
			Members()
			{}
		
		FGetSharedGroupDataResult(const FGetSharedGroupDataResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data),
			Members(src.Members)
			{}
			
		FGetSharedGroupDataResult(const TSharedPtr<FJsonObject>& obj) : FGetSharedGroupDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetSharedGroupDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTimeRequest : public FPlayFabBaseModel
    {
		
	
        FGetTimeRequest() :
			FPlayFabBaseModel()
			{}
		
		FGetTimeRequest(const FGetTimeRequest& src) :
			FPlayFabBaseModel()
			{}
			
		FGetTimeRequest(const TSharedPtr<FJsonObject>& obj) : FGetTimeRequest()
        {
            readFromValue(obj);
        }
		
		~FGetTimeRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTimeResult : public FPlayFabBaseModel
    {
		
		// Current server time when the request was received, in UTC
		FDateTime Time;
	
        FGetTimeResult() :
			FPlayFabBaseModel(),
			Time(0)
			{}
		
		FGetTimeResult(const FGetTimeResult& src) :
			FPlayFabBaseModel(),
			Time(src.Time)
			{}
			
		FGetTimeResult(const TSharedPtr<FJsonObject>& obj) : FGetTimeResult()
        {
            readFromValue(obj);
        }
		
		~FGetTimeResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTitleDataRequest : public FPlayFabBaseModel
    {
		
		// [optional] Specific keys to search for in the title data (leave null to get all keys)
		TArray<FString> Keys;
	
        FGetTitleDataRequest() :
			FPlayFabBaseModel(),
			Keys()
			{}
		
		FGetTitleDataRequest(const FGetTitleDataRequest& src) :
			FPlayFabBaseModel(),
			Keys(src.Keys)
			{}
			
		FGetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetTitleDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTitleDataResult : public FPlayFabBaseModel
    {
		
		// [optional] a dictionary object of key / value pairs
		TMap<FString, FString> Data;
	
        FGetTitleDataResult() :
			FPlayFabBaseModel(),
			Data()
			{}
		
		FGetTitleDataResult(const FGetTitleDataResult& src) :
			FPlayFabBaseModel(),
			Data(src.Data)
			{}
			
		FGetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FGetTitleDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetTitleDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTitleNewsRequest : public FPlayFabBaseModel
    {
		
		// [optional] Limits the results to the last n entries. Defaults to 10 if not set.
		OptionalInt32 Count;
	
        FGetTitleNewsRequest() :
			FPlayFabBaseModel(),
			Count()
			{}
		
		FGetTitleNewsRequest(const FGetTitleNewsRequest& src) :
			FPlayFabBaseModel(),
			Count(src.Count)
			{}
			
		FGetTitleNewsRequest(const TSharedPtr<FJsonObject>& obj) : FGetTitleNewsRequest()
        {
            readFromValue(obj);
        }
		
		~FGetTitleNewsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FTitleNewsItem : public FPlayFabBaseModel
    {
		
		// Date and time when the news items was posted.
		FDateTime Timestamp;
		// [optional] Unique identifier of news item.
		FString NewsId;
		// [optional] Title of the news item.
		FString Title;
		// [optional] News item text.
		FString Body;
	
        FTitleNewsItem() :
			FPlayFabBaseModel(),
			Timestamp(0),
			NewsId(),
			Title(),
			Body()
			{}
		
		FTitleNewsItem(const FTitleNewsItem& src) :
			FPlayFabBaseModel(),
			Timestamp(src.Timestamp),
			NewsId(src.NewsId),
			Title(src.Title),
			Body(src.Body)
			{}
			
		FTitleNewsItem(const TSharedPtr<FJsonObject>& obj) : FTitleNewsItem()
        {
            readFromValue(obj);
        }
		
		~FTitleNewsItem();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetTitleNewsResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of news items.
		TArray<FTitleNewsItem> News;
	
        FGetTitleNewsResult() :
			FPlayFabBaseModel(),
			News()
			{}
		
		FGetTitleNewsResult(const FGetTitleNewsResult& src) :
			FPlayFabBaseModel(),
			News(src.News)
			{}
			
		FGetTitleNewsResult(const TSharedPtr<FJsonObject>& obj) : FGetTitleNewsResult()
        {
            readFromValue(obj);
        }
		
		~FGetTitleNewsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserAccountInfoRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FGetUserAccountInfoRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FGetUserAccountInfoRequest(const FGetUserAccountInfoRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FGetUserAccountInfoRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserAccountInfoRequest()
        {
            readFromValue(obj);
        }
		
		~FGetUserAccountInfoRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserAccountInfoResult : public FPlayFabBaseModel
    {
		
		// [optional] Account details for the user whose information was requested.
		TSharedPtr<FUserAccountInfo> UserInfo;
	
        FGetUserAccountInfoResult() :
			FPlayFabBaseModel(),
			UserInfo(nullptr)
			{}
		
		FGetUserAccountInfoResult(const FGetUserAccountInfoResult& src) :
			FPlayFabBaseModel(),
			UserInfo(src.UserInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.UserInfo)) : nullptr)
			{}
			
		FGetUserAccountInfoResult(const TSharedPtr<FJsonObject>& obj) : FGetUserAccountInfoResult()
        {
            readFromValue(obj);
        }
		
		~FGetUserAccountInfoResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserBansRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FGetUserBansRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FGetUserBansRequest(const FGetUserBansRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FGetUserBansRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserBansRequest()
        {
            readFromValue(obj);
        }
		
		~FGetUserBansRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserBansResult : public FPlayFabBaseModel
    {
		
		// [optional] Information about the bans
		TArray<FBanInfo> BanData;
	
        FGetUserBansResult() :
			FPlayFabBaseModel(),
			BanData()
			{}
		
		FGetUserBansResult(const FGetUserBansResult& src) :
			FPlayFabBaseModel(),
			BanData(src.BanData)
			{}
			
		FGetUserBansResult(const TSharedPtr<FJsonObject>& obj) : FGetUserBansResult()
        {
            readFromValue(obj);
        }
		
		~FGetUserBansResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserDataRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Specific keys to search for in the custom user data.
		TArray<FString> Keys;
		// [optional] The version that currently exists according to the caller. The call will return the data for all of the keys if the version in the system is greater than this.
		OptionalUint32 IfChangedFromDataVersion;
	
        FGetUserDataRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Keys(),
			IfChangedFromDataVersion()
			{}
		
		FGetUserDataRequest(const FGetUserDataRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Keys(src.Keys),
			IfChangedFromDataVersion(src.IfChangedFromDataVersion)
			{}
			
		FGetUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserDataRequest()
        {
            readFromValue(obj);
        }
		
		~FGetUserDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserDataResult : public FPlayFabBaseModel
    {
		
		// [optional] PlayFab unique identifier of the user whose custom data is being returned.
		FString PlayFabId;
		// Indicates the current version of the data that has been set. This is incremented with every set call for that type of data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
		uint32 DataVersion;
		// [optional] User specific data for this title.
		TMap<FString, FUserDataRecord> Data;
	
        FGetUserDataResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			DataVersion(0),
			Data()
			{}
		
		FGetUserDataResult(const FGetUserDataResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			DataVersion(src.DataVersion),
			Data(src.Data)
			{}
			
		FGetUserDataResult(const TSharedPtr<FJsonObject>& obj) : FGetUserDataResult()
        {
            readFromValue(obj);
        }
		
		~FGetUserDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserInventoryRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FGetUserInventoryRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FGetUserInventoryRequest(const FGetUserInventoryRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FGetUserInventoryRequest(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryRequest()
        {
            readFromValue(obj);
        }
		
		~FGetUserInventoryRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGetUserInventoryResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Array of inventory items belonging to the user.
		TArray<FItemInstance> Inventory;
		// [optional] Array of virtual currency balance(s) belonging to the user.
		TMap<FString, int32> VirtualCurrency;
		// [optional] Array of remaining times and timestamps for virtual currencies.
		TMap<FString, FVirtualCurrencyRechargeTime> VirtualCurrencyRechargeTimes;
	
        FGetUserInventoryResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Inventory(),
			VirtualCurrency(),
			VirtualCurrencyRechargeTimes()
			{}
		
		FGetUserInventoryResult(const FGetUserInventoryResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Inventory(src.Inventory),
			VirtualCurrency(src.VirtualCurrency),
			VirtualCurrencyRechargeTimes(src.VirtualCurrencyRechargeTimes)
			{}
			
		FGetUserInventoryResult(const TSharedPtr<FJsonObject>& obj) : FGetUserInventoryResult()
        {
            readFromValue(obj);
        }
		
		~FGetUserInventoryResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantCharacterToUserRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Non-unique display name of the character being granted.
		FString CharacterName;
		// Type of the character being granted; statistics can be sliced based on this value.
		FString CharacterType;
	
        FGrantCharacterToUserRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterName(),
			CharacterType()
			{}
		
		FGrantCharacterToUserRequest(const FGrantCharacterToUserRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterName(src.CharacterName),
			CharacterType(src.CharacterType)
			{}
			
		FGrantCharacterToUserRequest(const TSharedPtr<FJsonObject>& obj) : FGrantCharacterToUserRequest()
        {
            readFromValue(obj);
        }
		
		~FGrantCharacterToUserRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantCharacterToUserResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier tagged to this character.
		FString CharacterId;
	
        FGrantCharacterToUserResult() :
			FPlayFabBaseModel(),
			CharacterId()
			{}
		
		FGrantCharacterToUserResult(const FGrantCharacterToUserResult& src) :
			FPlayFabBaseModel(),
			CharacterId(src.CharacterId)
			{}
			
		FGrantCharacterToUserResult(const TSharedPtr<FJsonObject>& obj) : FGrantCharacterToUserResult()
        {
            readFromValue(obj);
        }
		
		~FGrantCharacterToUserResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantedItemInstance : public FPlayFabBaseModel
    {
		
		// [optional] Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// Result of this operation.
		bool Result;
		// [optional] Unique identifier for the inventory item, as defined in the catalog.
		FString ItemId;
		// [optional] Unique item identifier for this specific instance of the item.
		FString ItemInstanceId;
		// [optional] Class name for the inventory item, as defined in the catalog.
		FString ItemClass;
		// [optional] Timestamp for when this instance was purchased.
		OptionalTime PurchaseDate;
		// [optional] Timestamp for when this instance will expire.
		OptionalTime Expiration;
		// [optional] Total number of remaining uses, if this is a consumable item.
		OptionalInt32 RemainingUses;
		// [optional] The number of uses that were added or removed to this item in this call.
		OptionalInt32 UsesIncrementedBy;
		// [optional] Game specific comment associated with this instance when it was added to the user inventory.
		FString Annotation;
		// [optional] Catalog version for the inventory item, when this instance was created.
		FString CatalogVersion;
		// [optional] Unique identifier for the parent inventory item, as defined in the catalog, for object which were added from a bundle or container.
		FString BundleParent;
		// [optional] CatalogItem.DisplayName at the time this item was purchased.
		FString DisplayName;
		// [optional] Currency type for the cost of the catalog item.
		FString UnitCurrency;
		// Cost of the catalog item in the given currency.
		uint32 UnitPrice;
		// [optional] Array of unique items that were awarded when this catalog item was purchased.
		TArray<FString> BundleContents;
		// [optional] A set of custom key-value pairs on the inventory item.
		TMap<FString, FString> CustomData;
	
        FGrantedItemInstance() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			Result(false),
			ItemId(),
			ItemInstanceId(),
			ItemClass(),
			PurchaseDate(),
			Expiration(),
			RemainingUses(),
			UsesIncrementedBy(),
			Annotation(),
			CatalogVersion(),
			BundleParent(),
			DisplayName(),
			UnitCurrency(),
			UnitPrice(0),
			BundleContents(),
			CustomData()
			{}
		
		FGrantedItemInstance(const FGrantedItemInstance& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			Result(src.Result),
			ItemId(src.ItemId),
			ItemInstanceId(src.ItemInstanceId),
			ItemClass(src.ItemClass),
			PurchaseDate(src.PurchaseDate),
			Expiration(src.Expiration),
			RemainingUses(src.RemainingUses),
			UsesIncrementedBy(src.UsesIncrementedBy),
			Annotation(src.Annotation),
			CatalogVersion(src.CatalogVersion),
			BundleParent(src.BundleParent),
			DisplayName(src.DisplayName),
			UnitCurrency(src.UnitCurrency),
			UnitPrice(src.UnitPrice),
			BundleContents(src.BundleContents),
			CustomData(src.CustomData)
			{}
			
		FGrantedItemInstance(const TSharedPtr<FJsonObject>& obj) : FGrantedItemInstance()
        {
            readFromValue(obj);
        }
		
		~FGrantedItemInstance();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantItemsToCharacterRequest : public FPlayFabBaseModel
    {
		
		// [optional] Catalog version from which items are to be granted.
		FString CatalogVersion;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] String detailing any additional information concerning this operation.
		FString Annotation;
		// [optional] Array of itemIds to grant to the user.
		TArray<FString> ItemIds;
	
        FGrantItemsToCharacterRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			CharacterId(),
			PlayFabId(),
			Annotation(),
			ItemIds()
			{}
		
		FGrantItemsToCharacterRequest(const FGrantItemsToCharacterRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			CharacterId(src.CharacterId),
			PlayFabId(src.PlayFabId),
			Annotation(src.Annotation),
			ItemIds(src.ItemIds)
			{}
			
		FGrantItemsToCharacterRequest(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToCharacterRequest()
        {
            readFromValue(obj);
        }
		
		~FGrantItemsToCharacterRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantItemsToCharacterResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of items granted to users.
		TArray<FGrantedItemInstance> ItemGrantResults;
	
        FGrantItemsToCharacterResult() :
			FPlayFabBaseModel(),
			ItemGrantResults()
			{}
		
		FGrantItemsToCharacterResult(const FGrantItemsToCharacterResult& src) :
			FPlayFabBaseModel(),
			ItemGrantResults(src.ItemGrantResults)
			{}
			
		FGrantItemsToCharacterResult(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToCharacterResult()
        {
            readFromValue(obj);
        }
		
		~FGrantItemsToCharacterResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantItemsToUserRequest : public FPlayFabBaseModel
    {
		
		// [optional] Catalog version from which items are to be granted.
		FString CatalogVersion;
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] String detailing any additional information concerning this operation.
		FString Annotation;
		// Array of itemIds to grant to the user.
		TArray<FString> ItemIds;
	
        FGrantItemsToUserRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			PlayFabId(),
			Annotation(),
			ItemIds()
			{}
		
		FGrantItemsToUserRequest(const FGrantItemsToUserRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			PlayFabId(src.PlayFabId),
			Annotation(src.Annotation),
			ItemIds(src.ItemIds)
			{}
			
		FGrantItemsToUserRequest(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUserRequest()
        {
            readFromValue(obj);
        }
		
		~FGrantItemsToUserRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantItemsToUserResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of items granted to users.
		TArray<FGrantedItemInstance> ItemGrantResults;
	
        FGrantItemsToUserResult() :
			FPlayFabBaseModel(),
			ItemGrantResults()
			{}
		
		FGrantItemsToUserResult(const FGrantItemsToUserResult& src) :
			FPlayFabBaseModel(),
			ItemGrantResults(src.ItemGrantResults)
			{}
			
		FGrantItemsToUserResult(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUserResult()
        {
            readFromValue(obj);
        }
		
		~FGrantItemsToUserResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FItemGrant : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique identifier of the catalog item to be granted to the user.
		FString ItemId;
		// [optional] String detailing any additional information concerning this operation.
		FString Annotation;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
	
        FItemGrant() :
			FPlayFabBaseModel(),
			PlayFabId(),
			ItemId(),
			Annotation(),
			CharacterId(),
			Data(),
			KeysToRemove()
			{}
		
		FItemGrant(const FItemGrant& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			ItemId(src.ItemId),
			Annotation(src.Annotation),
			CharacterId(src.CharacterId),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove)
			{}
			
		FItemGrant(const TSharedPtr<FJsonObject>& obj) : FItemGrant()
        {
            readFromValue(obj);
        }
		
		~FItemGrant();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantItemsToUsersRequest : public FPlayFabBaseModel
    {
		
		// [optional] Catalog version from which items are to be granted.
		FString CatalogVersion;
		// Array of items to grant and the users to whom the items are to be granted.
		TArray<FItemGrant> ItemGrants;
	
        FGrantItemsToUsersRequest() :
			FPlayFabBaseModel(),
			CatalogVersion(),
			ItemGrants()
			{}
		
		FGrantItemsToUsersRequest(const FGrantItemsToUsersRequest& src) :
			FPlayFabBaseModel(),
			CatalogVersion(src.CatalogVersion),
			ItemGrants(src.ItemGrants)
			{}
			
		FGrantItemsToUsersRequest(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUsersRequest()
        {
            readFromValue(obj);
        }
		
		~FGrantItemsToUsersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FGrantItemsToUsersResult : public FPlayFabBaseModel
    {
		
		// [optional] Array of items granted to users.
		TArray<FGrantedItemInstance> ItemGrantResults;
	
        FGrantItemsToUsersResult() :
			FPlayFabBaseModel(),
			ItemGrantResults()
			{}
		
		FGrantItemsToUsersResult(const FGrantItemsToUsersResult& src) :
			FPlayFabBaseModel(),
			ItemGrantResults(src.ItemGrantResults)
			{}
			
		FGrantItemsToUsersResult(const TSharedPtr<FJsonObject>& obj) : FGrantItemsToUsersResult()
        {
            readFromValue(obj);
        }
		
		~FGrantItemsToUsersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FListUsersCharactersRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FListUsersCharactersRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FListUsersCharactersRequest(const FListUsersCharactersRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FListUsersCharactersRequest(const TSharedPtr<FJsonObject>& obj) : FListUsersCharactersRequest()
        {
            readFromValue(obj);
        }
		
		~FListUsersCharactersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FListUsersCharactersResult : public FPlayFabBaseModel
    {
		
		// [optional] The requested list of characters.
		TArray<FCharacterResult> Characters;
	
        FListUsersCharactersResult() :
			FPlayFabBaseModel(),
			Characters()
			{}
		
		FListUsersCharactersResult(const FListUsersCharactersResult& src) :
			FPlayFabBaseModel(),
			Characters(src.Characters)
			{}
			
		FListUsersCharactersResult(const TSharedPtr<FJsonObject>& obj) : FListUsersCharactersResult()
        {
            readFromValue(obj);
        }
		
		~FListUsersCharactersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FModifyCharacterVirtualCurrencyResult : public FPlayFabBaseModel
    {
		
		// [optional] Name of the virtual currency which was modified.
		FString VirtualCurrency;
		// Balance of the virtual currency after modification.
		int32 Balance;
	
        FModifyCharacterVirtualCurrencyResult() :
			FPlayFabBaseModel(),
			VirtualCurrency(),
			Balance(0)
			{}
		
		FModifyCharacterVirtualCurrencyResult(const FModifyCharacterVirtualCurrencyResult& src) :
			FPlayFabBaseModel(),
			VirtualCurrency(src.VirtualCurrency),
			Balance(src.Balance)
			{}
			
		FModifyCharacterVirtualCurrencyResult(const TSharedPtr<FJsonObject>& obj) : FModifyCharacterVirtualCurrencyResult()
        {
            readFromValue(obj);
        }
		
		~FModifyCharacterVirtualCurrencyResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FModifyItemUsesRequest : public FPlayFabBaseModel
    {
		
		// PlayFab unique identifier of the user whose item is being modified.
		FString PlayFabId;
		// Unique instance identifier of the item to be modified.
		FString ItemInstanceId;
		// Number of uses to add to the item. Can be negative to remove uses.
		int32 UsesToAdd;
	
        FModifyItemUsesRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			ItemInstanceId(),
			UsesToAdd(0)
			{}
		
		FModifyItemUsesRequest(const FModifyItemUsesRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			ItemInstanceId(src.ItemInstanceId),
			UsesToAdd(src.UsesToAdd)
			{}
			
		FModifyItemUsesRequest(const TSharedPtr<FJsonObject>& obj) : FModifyItemUsesRequest()
        {
            readFromValue(obj);
        }
		
		~FModifyItemUsesRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FModifyItemUsesResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique instance identifier of the item with uses consumed.
		FString ItemInstanceId;
		// Number of uses remaining on the item.
		int32 RemainingUses;
	
        FModifyItemUsesResult() :
			FPlayFabBaseModel(),
			ItemInstanceId(),
			RemainingUses(0)
			{}
		
		FModifyItemUsesResult(const FModifyItemUsesResult& src) :
			FPlayFabBaseModel(),
			ItemInstanceId(src.ItemInstanceId),
			RemainingUses(src.RemainingUses)
			{}
			
		FModifyItemUsesResult(const TSharedPtr<FJsonObject>& obj) : FModifyItemUsesResult()
        {
            readFromValue(obj);
        }
		
		~FModifyItemUsesResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FModifyUserVirtualCurrencyResult : public FPlayFabBaseModel
    {
		
		// [optional] User currency was subtracted from.
		FString PlayFabId;
		// [optional] Name of the virtual currency which was modified.
		FString VirtualCurrency;
		// Amount added or subtracted from the user's virtual currency. Maximum VC balance is Int32 (2,147,483,647). Any increase over this value will be discarded.
		int32 BalanceChange;
		// Balance of the virtual currency after modification.
		int32 Balance;
	
        FModifyUserVirtualCurrencyResult() :
			FPlayFabBaseModel(),
			PlayFabId(),
			VirtualCurrency(),
			BalanceChange(0),
			Balance(0)
			{}
		
		FModifyUserVirtualCurrencyResult(const FModifyUserVirtualCurrencyResult& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			VirtualCurrency(src.VirtualCurrency),
			BalanceChange(src.BalanceChange),
			Balance(src.Balance)
			{}
			
		FModifyUserVirtualCurrencyResult(const TSharedPtr<FJsonObject>& obj) : FModifyUserVirtualCurrencyResult()
        {
            readFromValue(obj);
        }
		
		~FModifyUserVirtualCurrencyResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FMoveItemToCharacterFromCharacterRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique identifier of the character that currently has the item.
		FString GivingCharacterId;
		// Unique identifier of the character that will be receiving the item.
		FString ReceivingCharacterId;
		// Unique PlayFab assigned instance identifier of the item
		FString ItemInstanceId;
	
        FMoveItemToCharacterFromCharacterRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			GivingCharacterId(),
			ReceivingCharacterId(),
			ItemInstanceId()
			{}
		
		FMoveItemToCharacterFromCharacterRequest(const FMoveItemToCharacterFromCharacterRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			GivingCharacterId(src.GivingCharacterId),
			ReceivingCharacterId(src.ReceivingCharacterId),
			ItemInstanceId(src.ItemInstanceId)
			{}
			
		FMoveItemToCharacterFromCharacterRequest(const TSharedPtr<FJsonObject>& obj) : FMoveItemToCharacterFromCharacterRequest()
        {
            readFromValue(obj);
        }
		
		~FMoveItemToCharacterFromCharacterRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FMoveItemToCharacterFromCharacterResult : public FPlayFabBaseModel
    {
		
	
        FMoveItemToCharacterFromCharacterResult() :
			FPlayFabBaseModel()
			{}
		
		FMoveItemToCharacterFromCharacterResult(const FMoveItemToCharacterFromCharacterResult& src) :
			FPlayFabBaseModel()
			{}
			
		FMoveItemToCharacterFromCharacterResult(const TSharedPtr<FJsonObject>& obj) : FMoveItemToCharacterFromCharacterResult()
        {
            readFromValue(obj);
        }
		
		~FMoveItemToCharacterFromCharacterResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FMoveItemToCharacterFromUserRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// Unique PlayFab assigned instance identifier of the item
		FString ItemInstanceId;
	
        FMoveItemToCharacterFromUserRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			ItemInstanceId()
			{}
		
		FMoveItemToCharacterFromUserRequest(const FMoveItemToCharacterFromUserRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			ItemInstanceId(src.ItemInstanceId)
			{}
			
		FMoveItemToCharacterFromUserRequest(const TSharedPtr<FJsonObject>& obj) : FMoveItemToCharacterFromUserRequest()
        {
            readFromValue(obj);
        }
		
		~FMoveItemToCharacterFromUserRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FMoveItemToCharacterFromUserResult : public FPlayFabBaseModel
    {
		
	
        FMoveItemToCharacterFromUserResult() :
			FPlayFabBaseModel()
			{}
		
		FMoveItemToCharacterFromUserResult(const FMoveItemToCharacterFromUserResult& src) :
			FPlayFabBaseModel()
			{}
			
		FMoveItemToCharacterFromUserResult(const TSharedPtr<FJsonObject>& obj) : FMoveItemToCharacterFromUserResult()
        {
            readFromValue(obj);
        }
		
		~FMoveItemToCharacterFromUserResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FMoveItemToUserFromCharacterRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// Unique PlayFab assigned instance identifier of the item
		FString ItemInstanceId;
	
        FMoveItemToUserFromCharacterRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			ItemInstanceId()
			{}
		
		FMoveItemToUserFromCharacterRequest(const FMoveItemToUserFromCharacterRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			ItemInstanceId(src.ItemInstanceId)
			{}
			
		FMoveItemToUserFromCharacterRequest(const TSharedPtr<FJsonObject>& obj) : FMoveItemToUserFromCharacterRequest()
        {
            readFromValue(obj);
        }
		
		~FMoveItemToUserFromCharacterRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FMoveItemToUserFromCharacterResult : public FPlayFabBaseModel
    {
		
	
        FMoveItemToUserFromCharacterResult() :
			FPlayFabBaseModel()
			{}
		
		FMoveItemToUserFromCharacterResult(const FMoveItemToUserFromCharacterResult& src) :
			FPlayFabBaseModel()
			{}
			
		FMoveItemToUserFromCharacterResult(const TSharedPtr<FJsonObject>& obj) : FMoveItemToUserFromCharacterResult()
        {
            readFromValue(obj);
        }
		
		~FMoveItemToUserFromCharacterResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FNotifyMatchmakerPlayerLeftRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier of the Game Instance the user is leaving.
		FString LobbyId;
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FNotifyMatchmakerPlayerLeftRequest() :
			FPlayFabBaseModel(),
			LobbyId(),
			PlayFabId()
			{}
		
		FNotifyMatchmakerPlayerLeftRequest(const FNotifyMatchmakerPlayerLeftRequest& src) :
			FPlayFabBaseModel(),
			LobbyId(src.LobbyId),
			PlayFabId(src.PlayFabId)
			{}
			
		FNotifyMatchmakerPlayerLeftRequest(const TSharedPtr<FJsonObject>& obj) : FNotifyMatchmakerPlayerLeftRequest()
        {
            readFromValue(obj);
        }
		
		~FNotifyMatchmakerPlayerLeftRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum PlayerConnectionState
	{
		PlayerConnectionStateUnassigned,
		PlayerConnectionStateConnecting,
		PlayerConnectionStateParticipating,
		PlayerConnectionStateParticipated
	};
	
	void writePlayerConnectionStateEnumJSON(PlayerConnectionState enumVal, JsonWriter& writer);
	PlayerConnectionState readPlayerConnectionStateFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FNotifyMatchmakerPlayerLeftResult : public FPlayFabBaseModel
    {
		
		// [optional] State of user leaving the Game Server Instance.
		Boxed<PlayerConnectionState> PlayerState;
	
        FNotifyMatchmakerPlayerLeftResult() :
			FPlayFabBaseModel(),
			PlayerState()
			{}
		
		FNotifyMatchmakerPlayerLeftResult(const FNotifyMatchmakerPlayerLeftResult& src) :
			FPlayFabBaseModel(),
			PlayerState(src.PlayerState)
			{}
			
		FNotifyMatchmakerPlayerLeftResult(const TSharedPtr<FJsonObject>& obj) : FNotifyMatchmakerPlayerLeftResult()
        {
            readFromValue(obj);
        }
		
		~FNotifyMatchmakerPlayerLeftResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRedeemCouponRequest : public FPlayFabBaseModel
    {
		
		// Generated coupon code to redeem.
		FString CouponCode;
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Catalog version of the coupon.
		FString CatalogVersion;
		// [optional] Optional identifier for the Character that should receive the item. If null, item is added to the player
		FString CharacterId;
	
        FRedeemCouponRequest() :
			FPlayFabBaseModel(),
			CouponCode(),
			PlayFabId(),
			CatalogVersion(),
			CharacterId()
			{}
		
		FRedeemCouponRequest(const FRedeemCouponRequest& src) :
			FPlayFabBaseModel(),
			CouponCode(src.CouponCode),
			PlayFabId(src.PlayFabId),
			CatalogVersion(src.CatalogVersion),
			CharacterId(src.CharacterId)
			{}
			
		FRedeemCouponRequest(const TSharedPtr<FJsonObject>& obj) : FRedeemCouponRequest()
        {
            readFromValue(obj);
        }
		
		~FRedeemCouponRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRedeemCouponResult : public FPlayFabBaseModel
    {
		
		// [optional] Items granted to the player as a result of redeeming the coupon.
		TArray<FItemInstance> GrantedItems;
	
        FRedeemCouponResult() :
			FPlayFabBaseModel(),
			GrantedItems()
			{}
		
		FRedeemCouponResult(const FRedeemCouponResult& src) :
			FPlayFabBaseModel(),
			GrantedItems(src.GrantedItems)
			{}
			
		FRedeemCouponResult(const TSharedPtr<FJsonObject>& obj) : FRedeemCouponResult()
        {
            readFromValue(obj);
        }
		
		~FRedeemCouponResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRedeemMatchmakerTicketRequest : public FPlayFabBaseModel
    {
		
		// Server authorization ticket passed back from a call to Matchmake or StartGame.
		FString Ticket;
		// Unique identifier of the Game Server Instance that is asking for validation of the authorization ticket.
		FString LobbyId;
	
        FRedeemMatchmakerTicketRequest() :
			FPlayFabBaseModel(),
			Ticket(),
			LobbyId()
			{}
		
		FRedeemMatchmakerTicketRequest(const FRedeemMatchmakerTicketRequest& src) :
			FPlayFabBaseModel(),
			Ticket(src.Ticket),
			LobbyId(src.LobbyId)
			{}
			
		FRedeemMatchmakerTicketRequest(const TSharedPtr<FJsonObject>& obj) : FRedeemMatchmakerTicketRequest()
        {
            readFromValue(obj);
        }
		
		~FRedeemMatchmakerTicketRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRedeemMatchmakerTicketResult : public FPlayFabBaseModel
    {
		
		// Boolean indicating whether the ticket was validated by the PlayFab service.
		bool TicketIsValid;
		// [optional] Error value if the ticket was not validated.
		FString Error;
		// [optional] User account information for the user validated.
		TSharedPtr<FUserAccountInfo> UserInfo;
	
        FRedeemMatchmakerTicketResult() :
			FPlayFabBaseModel(),
			TicketIsValid(false),
			Error(),
			UserInfo(nullptr)
			{}
		
		FRedeemMatchmakerTicketResult(const FRedeemMatchmakerTicketResult& src) :
			FPlayFabBaseModel(),
			TicketIsValid(src.TicketIsValid),
			Error(src.Error),
			UserInfo(src.UserInfo.IsValid() ? MakeShareable(new FUserAccountInfo(*src.UserInfo)) : nullptr)
			{}
			
		FRedeemMatchmakerTicketResult(const TSharedPtr<FJsonObject>& obj) : FRedeemMatchmakerTicketResult()
        {
            readFromValue(obj);
        }
		
		~FRedeemMatchmakerTicketResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRefreshGameServerInstanceHeartbeatRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier of the Game Server Instance for which the heartbeat is updated.
		FString LobbyId;
	
        FRefreshGameServerInstanceHeartbeatRequest() :
			FPlayFabBaseModel(),
			LobbyId()
			{}
		
		FRefreshGameServerInstanceHeartbeatRequest(const FRefreshGameServerInstanceHeartbeatRequest& src) :
			FPlayFabBaseModel(),
			LobbyId(src.LobbyId)
			{}
			
		FRefreshGameServerInstanceHeartbeatRequest(const TSharedPtr<FJsonObject>& obj) : FRefreshGameServerInstanceHeartbeatRequest()
        {
            readFromValue(obj);
        }
		
		~FRefreshGameServerInstanceHeartbeatRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRefreshGameServerInstanceHeartbeatResult : public FPlayFabBaseModel
    {
		
	
        FRefreshGameServerInstanceHeartbeatResult() :
			FPlayFabBaseModel()
			{}
		
		FRefreshGameServerInstanceHeartbeatResult(const FRefreshGameServerInstanceHeartbeatResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRefreshGameServerInstanceHeartbeatResult(const TSharedPtr<FJsonObject>& obj) : FRefreshGameServerInstanceHeartbeatResult()
        {
            readFromValue(obj);
        }
		
		~FRefreshGameServerInstanceHeartbeatResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	enum Region
	{
		RegionUSCentral,
		RegionUSEast,
		RegionEUWest,
		RegionSingapore,
		RegionJapan,
		RegionBrazil,
		RegionAustralia
	};
	
	void writeRegionEnumJSON(Region enumVal, JsonWriter& writer);
	Region readRegionFromValue(const TSharedPtr<FJsonValue>& value);
	
	
	struct PLAYFAB_API FRegisterGameRequest : public FPlayFabBaseModel
    {
		
		// IP address of the Game Server Instance.
		FString ServerHost;
		// Port number for communication with the Game Server Instance.
		FString ServerPort;
		// Unique identifier of the build running on the Game Server Instance.
		FString Build;
		// Region in which the Game Server Instance is running. For matchmaking using non-AWS region names, set this to any AWS region and use Tags (below) to specify your custom region.
		Region pfRegion;
		// Game Mode the Game Server instance is running. Note that this must be defined in the Game Modes tab in the PlayFab Game Manager, along with the Build ID (the same Game Mode can be defined for multiple Build IDs).
		FString GameMode;
		// [optional] Tags for the Game Server Instance
		TMap<FString, FString> Tags;
	
        FRegisterGameRequest() :
			FPlayFabBaseModel(),
			ServerHost(),
			ServerPort(),
			Build(),
			pfRegion(),
			GameMode(),
			Tags()
			{}
		
		FRegisterGameRequest(const FRegisterGameRequest& src) :
			FPlayFabBaseModel(),
			ServerHost(src.ServerHost),
			ServerPort(src.ServerPort),
			Build(src.Build),
			pfRegion(src.pfRegion),
			GameMode(src.GameMode),
			Tags(src.Tags)
			{}
			
		FRegisterGameRequest(const TSharedPtr<FJsonObject>& obj) : FRegisterGameRequest()
        {
            readFromValue(obj);
        }
		
		~FRegisterGameRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRegisterGameResponse : public FPlayFabBaseModel
    {
		
		// [optional] Unique identifier generated for the Game Server Instance that is registered.
		FString LobbyId;
	
        FRegisterGameResponse() :
			FPlayFabBaseModel(),
			LobbyId()
			{}
		
		FRegisterGameResponse(const FRegisterGameResponse& src) :
			FPlayFabBaseModel(),
			LobbyId(src.LobbyId)
			{}
			
		FRegisterGameResponse(const TSharedPtr<FJsonObject>& obj) : FRegisterGameResponse()
        {
            readFromValue(obj);
        }
		
		~FRegisterGameResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveFriendRequest : public FPlayFabBaseModel
    {
		
		// PlayFab identifier of the friend account which is to be removed.
		FString FriendPlayFabId;
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FRemoveFriendRequest() :
			FPlayFabBaseModel(),
			FriendPlayFabId(),
			PlayFabId()
			{}
		
		FRemoveFriendRequest(const FRemoveFriendRequest& src) :
			FPlayFabBaseModel(),
			FriendPlayFabId(src.FriendPlayFabId),
			PlayFabId(src.PlayFabId)
			{}
			
		FRemoveFriendRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveFriendRequest()
        {
            readFromValue(obj);
        }
		
		~FRemoveFriendRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemovePlayerTagRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique tag for player profile.
		FString TagName;
	
        FRemovePlayerTagRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			TagName()
			{}
		
		FRemovePlayerTagRequest(const FRemovePlayerTagRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			TagName(src.TagName)
			{}
			
		FRemovePlayerTagRequest(const TSharedPtr<FJsonObject>& obj) : FRemovePlayerTagRequest()
        {
            readFromValue(obj);
        }
		
		~FRemovePlayerTagRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemovePlayerTagResult : public FPlayFabBaseModel
    {
		
	
        FRemovePlayerTagResult() :
			FPlayFabBaseModel()
			{}
		
		FRemovePlayerTagResult(const FRemovePlayerTagResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRemovePlayerTagResult(const TSharedPtr<FJsonObject>& obj) : FRemovePlayerTagResult()
        {
            readFromValue(obj);
        }
		
		~FRemovePlayerTagResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveSharedGroupMembersRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the shared group.
		FString SharedGroupId;
		// An array of unique PlayFab assigned ID of the user on whom the operation will be performed.
		TArray<FString> PlayFabIds;
	
        FRemoveSharedGroupMembersRequest() :
			FPlayFabBaseModel(),
			SharedGroupId(),
			PlayFabIds()
			{}
		
		FRemoveSharedGroupMembersRequest(const FRemoveSharedGroupMembersRequest& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId),
			PlayFabIds(src.PlayFabIds)
			{}
			
		FRemoveSharedGroupMembersRequest(const TSharedPtr<FJsonObject>& obj) : FRemoveSharedGroupMembersRequest()
        {
            readFromValue(obj);
        }
		
		~FRemoveSharedGroupMembersRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRemoveSharedGroupMembersResult : public FPlayFabBaseModel
    {
		
	
        FRemoveSharedGroupMembersResult() :
			FPlayFabBaseModel()
			{}
		
		FRemoveSharedGroupMembersResult(const FRemoveSharedGroupMembersResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRemoveSharedGroupMembersResult(const TSharedPtr<FJsonObject>& obj) : FRemoveSharedGroupMembersResult()
        {
            readFromValue(obj);
        }
		
		~FRemoveSharedGroupMembersResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FReportPlayerServerRequest : public FPlayFabBaseModel
    {
		
		// PlayFabId of the reporting player.
		FString ReporterId;
		// PlayFabId of the reported player.
		FString ReporteeId;
		// [optional] Title player was reported in, optional if report not for specific title.
		FString TitleId;
		// [optional] Optional additional comment by reporting player.
		FString Comment;
	
        FReportPlayerServerRequest() :
			FPlayFabBaseModel(),
			ReporterId(),
			ReporteeId(),
			TitleId(),
			Comment()
			{}
		
		FReportPlayerServerRequest(const FReportPlayerServerRequest& src) :
			FPlayFabBaseModel(),
			ReporterId(src.ReporterId),
			ReporteeId(src.ReporteeId),
			TitleId(src.TitleId),
			Comment(src.Comment)
			{}
			
		FReportPlayerServerRequest(const TSharedPtr<FJsonObject>& obj) : FReportPlayerServerRequest()
        {
            readFromValue(obj);
        }
		
		~FReportPlayerServerRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FReportPlayerServerResult : public FPlayFabBaseModel
    {
		
		// Indicates whether this action completed successfully.
		bool Updated;
		// The number of remaining reports which may be filed today by this reporting player.
		int32 SubmissionsRemaining;
	
        FReportPlayerServerResult() :
			FPlayFabBaseModel(),
			Updated(false),
			SubmissionsRemaining(0)
			{}
		
		FReportPlayerServerResult(const FReportPlayerServerResult& src) :
			FPlayFabBaseModel(),
			Updated(src.Updated),
			SubmissionsRemaining(src.SubmissionsRemaining)
			{}
			
		FReportPlayerServerResult(const TSharedPtr<FJsonObject>& obj) : FReportPlayerServerResult()
        {
            readFromValue(obj);
        }
		
		~FReportPlayerServerResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeAllBansForUserRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
	
        FRevokeAllBansForUserRequest() :
			FPlayFabBaseModel(),
			PlayFabId()
			{}
		
		FRevokeAllBansForUserRequest(const FRevokeAllBansForUserRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId)
			{}
			
		FRevokeAllBansForUserRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeAllBansForUserRequest()
        {
            readFromValue(obj);
        }
		
		~FRevokeAllBansForUserRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeAllBansForUserResult : public FPlayFabBaseModel
    {
		
		// [optional] Information on the bans that were revoked.
		TArray<FBanInfo> BanData;
	
        FRevokeAllBansForUserResult() :
			FPlayFabBaseModel(),
			BanData()
			{}
		
		FRevokeAllBansForUserResult(const FRevokeAllBansForUserResult& src) :
			FPlayFabBaseModel(),
			BanData(src.BanData)
			{}
			
		FRevokeAllBansForUserResult(const TSharedPtr<FJsonObject>& obj) : FRevokeAllBansForUserResult()
        {
            readFromValue(obj);
        }
		
		~FRevokeAllBansForUserResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeBansRequest : public FPlayFabBaseModel
    {
		
		// Ids of the bans to be revoked. Maximum 100.
		TArray<FString> BanIds;
	
        FRevokeBansRequest() :
			FPlayFabBaseModel(),
			BanIds()
			{}
		
		FRevokeBansRequest(const FRevokeBansRequest& src) :
			FPlayFabBaseModel(),
			BanIds(src.BanIds)
			{}
			
		FRevokeBansRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeBansRequest()
        {
            readFromValue(obj);
        }
		
		~FRevokeBansRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeBansResult : public FPlayFabBaseModel
    {
		
		// [optional] Information on the bans that were revoked
		TArray<FBanInfo> BanData;
	
        FRevokeBansResult() :
			FPlayFabBaseModel(),
			BanData()
			{}
		
		FRevokeBansResult(const FRevokeBansResult& src) :
			FPlayFabBaseModel(),
			BanData(src.BanData)
			{}
			
		FRevokeBansResult(const TSharedPtr<FJsonObject>& obj) : FRevokeBansResult()
        {
            readFromValue(obj);
        }
		
		~FRevokeBansResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeInventoryItemRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// Unique PlayFab assigned instance identifier of the item
		FString ItemInstanceId;
	
        FRevokeInventoryItemRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			ItemInstanceId()
			{}
		
		FRevokeInventoryItemRequest(const FRevokeInventoryItemRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			ItemInstanceId(src.ItemInstanceId)
			{}
			
		FRevokeInventoryItemRequest(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryItemRequest()
        {
            readFromValue(obj);
        }
		
		~FRevokeInventoryItemRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FRevokeInventoryResult : public FPlayFabBaseModel
    {
		
	
        FRevokeInventoryResult() :
			FPlayFabBaseModel()
			{}
		
		FRevokeInventoryResult(const FRevokeInventoryResult& src) :
			FPlayFabBaseModel()
			{}
			
		FRevokeInventoryResult(const TSharedPtr<FJsonObject>& obj) : FRevokeInventoryResult()
        {
            readFromValue(obj);
        }
		
		~FRevokeInventoryResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSendPushNotificationRequest : public FPlayFabBaseModel
    {
		
		// PlayFabId of the recipient of the push notification.
		FString Recipient;
		// Text of message to send.
		FString Message;
		// [optional] Subject of message to send (may not be displayed in all platforms.
		FString Subject;
	
        FSendPushNotificationRequest() :
			FPlayFabBaseModel(),
			Recipient(),
			Message(),
			Subject()
			{}
		
		FSendPushNotificationRequest(const FSendPushNotificationRequest& src) :
			FPlayFabBaseModel(),
			Recipient(src.Recipient),
			Message(src.Message),
			Subject(src.Subject)
			{}
			
		FSendPushNotificationRequest(const TSharedPtr<FJsonObject>& obj) : FSendPushNotificationRequest()
        {
            readFromValue(obj);
        }
		
		~FSendPushNotificationRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSendPushNotificationResult : public FPlayFabBaseModel
    {
		
	
        FSendPushNotificationResult() :
			FPlayFabBaseModel()
			{}
		
		FSendPushNotificationResult(const FSendPushNotificationResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSendPushNotificationResult(const TSharedPtr<FJsonObject>& obj) : FSendPushNotificationResult()
        {
            readFromValue(obj);
        }
		
		~FSendPushNotificationResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetGameServerInstanceDataRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier of the Game Instance to be updated.
		FString LobbyId;
		// Custom data to set for the specified game server instance.
		FString GameServerData;
	
        FSetGameServerInstanceDataRequest() :
			FPlayFabBaseModel(),
			LobbyId(),
			GameServerData()
			{}
		
		FSetGameServerInstanceDataRequest(const FSetGameServerInstanceDataRequest& src) :
			FPlayFabBaseModel(),
			LobbyId(src.LobbyId),
			GameServerData(src.GameServerData)
			{}
			
		FSetGameServerInstanceDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceDataRequest()
        {
            readFromValue(obj);
        }
		
		~FSetGameServerInstanceDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetGameServerInstanceDataResult : public FPlayFabBaseModel
    {
		
	
        FSetGameServerInstanceDataResult() :
			FPlayFabBaseModel()
			{}
		
		FSetGameServerInstanceDataResult(const FSetGameServerInstanceDataResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSetGameServerInstanceDataResult(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceDataResult()
        {
            readFromValue(obj);
        }
		
		~FSetGameServerInstanceDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetGameServerInstanceStateRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier of the Game Instance to be updated.
		FString LobbyId;
		// State to set for the specified game server instance.
		GameInstanceState State;
	
        FSetGameServerInstanceStateRequest() :
			FPlayFabBaseModel(),
			LobbyId(),
			State()
			{}
		
		FSetGameServerInstanceStateRequest(const FSetGameServerInstanceStateRequest& src) :
			FPlayFabBaseModel(),
			LobbyId(src.LobbyId),
			State(src.State)
			{}
			
		FSetGameServerInstanceStateRequest(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceStateRequest()
        {
            readFromValue(obj);
        }
		
		~FSetGameServerInstanceStateRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetGameServerInstanceStateResult : public FPlayFabBaseModel
    {
		
	
        FSetGameServerInstanceStateResult() :
			FPlayFabBaseModel()
			{}
		
		FSetGameServerInstanceStateResult(const FSetGameServerInstanceStateResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSetGameServerInstanceStateResult(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceStateResult()
        {
            readFromValue(obj);
        }
		
		~FSetGameServerInstanceStateResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetGameServerInstanceTagsRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier of the Game Server Instance to be updated.
		FString LobbyId;
		// Tags to set for the specified Game Server Instance. Note that this is the complete list of tags to be associated with the Game Server Instance.
		TMap<FString, FString> Tags;
	
        FSetGameServerInstanceTagsRequest() :
			FPlayFabBaseModel(),
			LobbyId(),
			Tags()
			{}
		
		FSetGameServerInstanceTagsRequest(const FSetGameServerInstanceTagsRequest& src) :
			FPlayFabBaseModel(),
			LobbyId(src.LobbyId),
			Tags(src.Tags)
			{}
			
		FSetGameServerInstanceTagsRequest(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceTagsRequest()
        {
            readFromValue(obj);
        }
		
		~FSetGameServerInstanceTagsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetGameServerInstanceTagsResult : public FPlayFabBaseModel
    {
		
	
        FSetGameServerInstanceTagsResult() :
			FPlayFabBaseModel()
			{}
		
		FSetGameServerInstanceTagsResult(const FSetGameServerInstanceTagsResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSetGameServerInstanceTagsResult(const TSharedPtr<FJsonObject>& obj) : FSetGameServerInstanceTagsResult()
        {
            readFromValue(obj);
        }
		
		~FSetGameServerInstanceTagsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetPublisherDataRequest : public FPlayFabBaseModel
    {
		
		// key we want to set a value on (note, this is additive - will only replace an existing key's value if they are the same name.) Keys are trimmed of whitespace. Keys may not begin with the '!' character.
		FString Key;
		// [optional] new value to set. Set to null to remove a value
		FString Value;
	
        FSetPublisherDataRequest() :
			FPlayFabBaseModel(),
			Key(),
			Value()
			{}
		
		FSetPublisherDataRequest(const FSetPublisherDataRequest& src) :
			FPlayFabBaseModel(),
			Key(src.Key),
			Value(src.Value)
			{}
			
		FSetPublisherDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetPublisherDataRequest()
        {
            readFromValue(obj);
        }
		
		~FSetPublisherDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetPublisherDataResult : public FPlayFabBaseModel
    {
		
	
        FSetPublisherDataResult() :
			FPlayFabBaseModel()
			{}
		
		FSetPublisherDataResult(const FSetPublisherDataResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSetPublisherDataResult(const TSharedPtr<FJsonObject>& obj) : FSetPublisherDataResult()
        {
            readFromValue(obj);
        }
		
		~FSetPublisherDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetTitleDataRequest : public FPlayFabBaseModel
    {
		
		// key we want to set a value on (note, this is additive - will only replace an existing key's value if they are the same name.) Keys are trimmed of whitespace. Keys may not begin with the '!' character.
		FString Key;
		// [optional] new value to set. Set to null to remove a value
		FString Value;
	
        FSetTitleDataRequest() :
			FPlayFabBaseModel(),
			Key(),
			Value()
			{}
		
		FSetTitleDataRequest(const FSetTitleDataRequest& src) :
			FPlayFabBaseModel(),
			Key(src.Key),
			Value(src.Value)
			{}
			
		FSetTitleDataRequest(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataRequest()
        {
            readFromValue(obj);
        }
		
		~FSetTitleDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSetTitleDataResult : public FPlayFabBaseModel
    {
		
	
        FSetTitleDataResult() :
			FPlayFabBaseModel()
			{}
		
		FSetTitleDataResult(const FSetTitleDataResult& src) :
			FPlayFabBaseModel()
			{}
			
		FSetTitleDataResult(const TSharedPtr<FJsonObject>& obj) : FSetTitleDataResult()
        {
            readFromValue(obj);
        }
		
		~FSetTitleDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FStatisticUpdate : public FPlayFabBaseModel
    {
		
		// unique name of the statistic
		FString StatisticName;
		// [optional] for updates to an existing statistic value for a player, the version of the statistic when it was loaded. Null when setting the statistic value for the first time.
		OptionalUint32 Version;
		// statistic value for the player
		int32 Value;
	
        FStatisticUpdate() :
			FPlayFabBaseModel(),
			StatisticName(),
			Version(),
			Value(0)
			{}
		
		FStatisticUpdate(const FStatisticUpdate& src) :
			FPlayFabBaseModel(),
			StatisticName(src.StatisticName),
			Version(src.Version),
			Value(src.Value)
			{}
			
		FStatisticUpdate(const TSharedPtr<FJsonObject>& obj) : FStatisticUpdate()
        {
            readFromValue(obj);
        }
		
		~FStatisticUpdate();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSubtractCharacterVirtualCurrencyRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// Name of the virtual currency which is to be decremented.
		FString VirtualCurrency;
		// Amount to be subtracted from the user balance of the specified virtual currency.
		int32 Amount;
	
        FSubtractCharacterVirtualCurrencyRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			VirtualCurrency(),
			Amount(0)
			{}
		
		FSubtractCharacterVirtualCurrencyRequest(const FSubtractCharacterVirtualCurrencyRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			VirtualCurrency(src.VirtualCurrency),
			Amount(src.Amount)
			{}
			
		FSubtractCharacterVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FSubtractCharacterVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }
		
		~FSubtractCharacterVirtualCurrencyRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FSubtractUserVirtualCurrencyRequest : public FPlayFabBaseModel
    {
		
		// PlayFab unique identifier of the user whose virtual currency balance is to be decreased.
		FString PlayFabId;
		// Name of the virtual currency which is to be decremented.
		FString VirtualCurrency;
		// Amount to be subtracted from the user balance of the specified virtual currency.
		int32 Amount;
	
        FSubtractUserVirtualCurrencyRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			VirtualCurrency(),
			Amount(0)
			{}
		
		FSubtractUserVirtualCurrencyRequest(const FSubtractUserVirtualCurrencyRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			VirtualCurrency(src.VirtualCurrency),
			Amount(src.Amount)
			{}
			
		FSubtractUserVirtualCurrencyRequest(const TSharedPtr<FJsonObject>& obj) : FSubtractUserVirtualCurrencyRequest()
        {
            readFromValue(obj);
        }
		
		~FSubtractUserVirtualCurrencyRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlockContainerInstanceRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// ItemInstanceId of the container to unlock.
		FString ContainerItemInstanceId;
		// [optional] ItemInstanceId of the key that will be consumed by unlocking this container.  If the container requires a key, this parameter is required.
		FString KeyItemInstanceId;
		// [optional] Specifies the catalog version that should be used to determine container contents.  If unspecified, uses catalog associated with the item instance.
		FString CatalogVersion;
	
        FUnlockContainerInstanceRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			ContainerItemInstanceId(),
			KeyItemInstanceId(),
			CatalogVersion()
			{}
		
		FUnlockContainerInstanceRequest(const FUnlockContainerInstanceRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			ContainerItemInstanceId(src.ContainerItemInstanceId),
			KeyItemInstanceId(src.KeyItemInstanceId),
			CatalogVersion(src.CatalogVersion)
			{}
			
		FUnlockContainerInstanceRequest(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerInstanceRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlockContainerInstanceRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlockContainerItemRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// Catalog ItemId of the container type to unlock.
		FString ContainerItemId;
		// [optional] Specifies the catalog version that should be used to determine container contents.  If unspecified, uses default/primary catalog.
		FString CatalogVersion;
	
        FUnlockContainerItemRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			ContainerItemId(),
			CatalogVersion()
			{}
		
		FUnlockContainerItemRequest(const FUnlockContainerItemRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			ContainerItemId(src.ContainerItemId),
			CatalogVersion(src.CatalogVersion)
			{}
			
		FUnlockContainerItemRequest(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerItemRequest()
        {
            readFromValue(obj);
        }
		
		~FUnlockContainerItemRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUnlockContainerItemResult : public FPlayFabBaseModel
    {
		
		// [optional] Unique instance identifier of the container unlocked.
		FString UnlockedItemInstanceId;
		// [optional] Unique instance identifier of the key used to unlock the container, if applicable.
		FString UnlockedWithItemInstanceId;
		// [optional] Items granted to the player as a result of unlocking the container.
		TArray<FItemInstance> GrantedItems;
		// [optional] Virtual currency granted to the player as a result of unlocking the container.
		TMap<FString, uint32> VirtualCurrency;
	
        FUnlockContainerItemResult() :
			FPlayFabBaseModel(),
			UnlockedItemInstanceId(),
			UnlockedWithItemInstanceId(),
			GrantedItems(),
			VirtualCurrency()
			{}
		
		FUnlockContainerItemResult(const FUnlockContainerItemResult& src) :
			FPlayFabBaseModel(),
			UnlockedItemInstanceId(src.UnlockedItemInstanceId),
			UnlockedWithItemInstanceId(src.UnlockedWithItemInstanceId),
			GrantedItems(src.GrantedItems),
			VirtualCurrency(src.VirtualCurrency)
			{}
			
		FUnlockContainerItemResult(const TSharedPtr<FJsonObject>& obj) : FUnlockContainerItemResult()
        {
            readFromValue(obj);
        }
		
		~FUnlockContainerItemResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateBanRequest : public FPlayFabBaseModel
    {
		
		// The id of the ban to be updated.
		FString BanId;
		// [optional] The updated reason for the ban to be updated. Maximum 140 characters. Null for no change.
		FString Reason;
		// [optional] The updated expiration date for the ban. Null for no change.
		OptionalTime Expires;
		// [optional] The updated IP address for the ban. Null for no change.
		FString IPAddress;
		// [optional] The updated MAC address for the ban. Null for no change.
		FString MACAddress;
		// [optional] Whether to make this ban permanent. Set to true to make this ban permanent. This will not modify Active state.
		OptionalBool Permanent;
		// [optional] The updated active state for the ban. Null for no change.
		OptionalBool Active;
	
        FUpdateBanRequest() :
			FPlayFabBaseModel(),
			BanId(),
			Reason(),
			Expires(),
			IPAddress(),
			MACAddress(),
			Permanent(),
			Active()
			{}
		
		FUpdateBanRequest(const FUpdateBanRequest& src) :
			FPlayFabBaseModel(),
			BanId(src.BanId),
			Reason(src.Reason),
			Expires(src.Expires),
			IPAddress(src.IPAddress),
			MACAddress(src.MACAddress),
			Permanent(src.Permanent),
			Active(src.Active)
			{}
			
		FUpdateBanRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBanRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateBanRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateBansRequest : public FPlayFabBaseModel
    {
		
		// List of bans to be updated. Maximum 100.
		TArray<FUpdateBanRequest> Bans;
	
        FUpdateBansRequest() :
			FPlayFabBaseModel(),
			Bans()
			{}
		
		FUpdateBansRequest(const FUpdateBansRequest& src) :
			FPlayFabBaseModel(),
			Bans(src.Bans)
			{}
			
		FUpdateBansRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateBansRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateBansRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateBansResult : public FPlayFabBaseModel
    {
		
		// [optional] Information on the bans that were updated
		TArray<FBanInfo> BanData;
	
        FUpdateBansResult() :
			FPlayFabBaseModel(),
			BanData()
			{}
		
		FUpdateBansResult(const FUpdateBansResult& src) :
			FPlayFabBaseModel(),
			BanData(src.BanData)
			{}
			
		FUpdateBansResult(const TSharedPtr<FJsonObject>& obj) : FUpdateBansResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateBansResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCharacterDataRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
		// [optional] Permission to be applied to all user data keys written in this request. Defaults to "private" if not set.
		Boxed<UserDataPermission> Permission;
	
        FUpdateCharacterDataRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			Data(),
			KeysToRemove(),
			Permission()
			{}
		
		FUpdateCharacterDataRequest(const FUpdateCharacterDataRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove),
			Permission(src.Permission)
			{}
			
		FUpdateCharacterDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterDataRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateCharacterDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCharacterDataResult : public FPlayFabBaseModel
    {
		
		// Indicates the current version of the data that has been set. This is incremented with every set call for that type of data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
		uint32 DataVersion;
	
        FUpdateCharacterDataResult() :
			FPlayFabBaseModel(),
			DataVersion(0)
			{}
		
		FUpdateCharacterDataResult(const FUpdateCharacterDataResult& src) :
			FPlayFabBaseModel(),
			DataVersion(src.DataVersion)
			{}
			
		FUpdateCharacterDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterDataResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateCharacterDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCharacterStatisticsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// [optional] Statistics to be updated with the provided values.
		TMap<FString, int32> CharacterStatistics;
	
        FUpdateCharacterStatisticsRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			CharacterStatistics()
			{}
		
		FUpdateCharacterStatisticsRequest(const FUpdateCharacterStatisticsRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			CharacterStatistics(src.CharacterStatistics)
			{}
			
		FUpdateCharacterStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterStatisticsRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateCharacterStatisticsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateCharacterStatisticsResult : public FPlayFabBaseModel
    {
		
	
        FUpdateCharacterStatisticsResult() :
			FPlayFabBaseModel()
			{}
		
		FUpdateCharacterStatisticsResult(const FUpdateCharacterStatisticsResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUpdateCharacterStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FUpdateCharacterStatisticsResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateCharacterStatisticsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdatePlayerStatisticsRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Statistics to be updated with the provided values
		TArray<FStatisticUpdate> Statistics;
		// [optional] Indicates whether the statistics provided should be set, regardless of the aggregation method set on the statistic. Default is false.
		OptionalBool ForceUpdate;
	
        FUpdatePlayerStatisticsRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Statistics(),
			ForceUpdate()
			{}
		
		FUpdatePlayerStatisticsRequest(const FUpdatePlayerStatisticsRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Statistics(src.Statistics),
			ForceUpdate(src.ForceUpdate)
			{}
			
		FUpdatePlayerStatisticsRequest(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticsRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdatePlayerStatisticsRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdatePlayerStatisticsResult : public FPlayFabBaseModel
    {
		
	
        FUpdatePlayerStatisticsResult() :
			FPlayFabBaseModel()
			{}
		
		FUpdatePlayerStatisticsResult(const FUpdatePlayerStatisticsResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUpdatePlayerStatisticsResult(const TSharedPtr<FJsonObject>& obj) : FUpdatePlayerStatisticsResult()
        {
            readFromValue(obj);
        }
		
		~FUpdatePlayerStatisticsResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateSharedGroupDataRequest : public FPlayFabBaseModel
    {
		
		// Unique identifier for the shared group.
		FString SharedGroupId;
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
		// [optional] Permission to be applied to all user data keys in this request.
		Boxed<UserDataPermission> Permission;
	
        FUpdateSharedGroupDataRequest() :
			FPlayFabBaseModel(),
			SharedGroupId(),
			Data(),
			KeysToRemove(),
			Permission()
			{}
		
		FUpdateSharedGroupDataRequest(const FUpdateSharedGroupDataRequest& src) :
			FPlayFabBaseModel(),
			SharedGroupId(src.SharedGroupId),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove),
			Permission(src.Permission)
			{}
			
		FUpdateSharedGroupDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateSharedGroupDataRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateSharedGroupDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateSharedGroupDataResult : public FPlayFabBaseModel
    {
		
	
        FUpdateSharedGroupDataResult() :
			FPlayFabBaseModel()
			{}
		
		FUpdateSharedGroupDataResult(const FUpdateSharedGroupDataResult& src) :
			FPlayFabBaseModel()
			{}
			
		FUpdateSharedGroupDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateSharedGroupDataResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateSharedGroupDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserDataRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
		// [optional] Permission to be applied to all user data keys written in this request. Defaults to "private" if not set.
		Boxed<UserDataPermission> Permission;
	
        FUpdateUserDataRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Data(),
			KeysToRemove(),
			Permission()
			{}
		
		FUpdateUserDataRequest(const FUpdateUserDataRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove),
			Permission(src.Permission)
			{}
			
		FUpdateUserDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserDataResult : public FPlayFabBaseModel
    {
		
		// Indicates the current version of the data that has been set. This is incremented with every set call for that type of data (read-only, internal, etc). This version can be provided in Get calls to find updated data.
		uint32 DataVersion;
	
        FUpdateUserDataResult() :
			FPlayFabBaseModel(),
			DataVersion(0)
			{}
		
		FUpdateUserDataResult(const FUpdateUserDataResult& src) :
			FPlayFabBaseModel(),
			DataVersion(src.DataVersion)
			{}
			
		FUpdateUserDataResult(const TSharedPtr<FJsonObject>& obj) : FUpdateUserDataResult()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserDataResult();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserInternalDataRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
	
        FUpdateUserInternalDataRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			Data(),
			KeysToRemove()
			{}
		
		FUpdateUserInternalDataRequest(const FUpdateUserInternalDataRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove)
			{}
			
		FUpdateUserInternalDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserInternalDataRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserInternalDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FUpdateUserInventoryItemDataRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// [optional] Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// Unique PlayFab assigned instance identifier of the item
		FString ItemInstanceId;
		// [optional] Key-value pairs to be written to the custom data. Note that keys are trimmed of whitespace, are limited in size, and may not begin with a '!' character.
		TMap<FString, FString> Data;
		// [optional] Optional list of Data-keys to remove from UserData.  Some SDKs cannot insert null-values into Data due to language constraints.  Use this to delete the keys directly.
		TArray<FString> KeysToRemove;
	
        FUpdateUserInventoryItemDataRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			ItemInstanceId(),
			Data(),
			KeysToRemove()
			{}
		
		FUpdateUserInventoryItemDataRequest(const FUpdateUserInventoryItemDataRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			ItemInstanceId(src.ItemInstanceId),
			Data(src.Data),
			KeysToRemove(src.KeysToRemove)
			{}
			
		FUpdateUserInventoryItemDataRequest(const TSharedPtr<FJsonObject>& obj) : FUpdateUserInventoryItemDataRequest()
        {
            readFromValue(obj);
        }
		
		~FUpdateUserInventoryItemDataRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FWriteEventResponse : public FPlayFabBaseModel
    {
		
		// [optional] The unique identifier of the event. The values of this identifier consist of ASCII characters and are not constrained to any particular format.
		FString EventId;
	
        FWriteEventResponse() :
			FPlayFabBaseModel(),
			EventId()
			{}
		
		FWriteEventResponse(const FWriteEventResponse& src) :
			FPlayFabBaseModel(),
			EventId(src.EventId)
			{}
			
		FWriteEventResponse(const TSharedPtr<FJsonObject>& obj) : FWriteEventResponse()
        {
            readFromValue(obj);
        }
		
		~FWriteEventResponse();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FWriteServerCharacterEventRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// Unique PlayFab assigned ID for a specific character owned by a user
		FString CharacterId;
		// The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it commonly follows the subject_verb_object pattern (e.g. player_logged_in).
		FString EventName;
		// [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
		OptionalTime Timestamp;
		// [optional] Custom event properties. Each property consists of a name (string) and a value (JSON object).
		TMap<FString, FMultitypeVar> Body;
	
        FWriteServerCharacterEventRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			CharacterId(),
			EventName(),
			Timestamp(),
			Body()
			{}
		
		FWriteServerCharacterEventRequest(const FWriteServerCharacterEventRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			CharacterId(src.CharacterId),
			EventName(src.EventName),
			Timestamp(src.Timestamp),
			Body(src.Body)
			{}
			
		FWriteServerCharacterEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteServerCharacterEventRequest()
        {
            readFromValue(obj);
        }
		
		~FWriteServerCharacterEventRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FWriteServerPlayerEventRequest : public FPlayFabBaseModel
    {
		
		// Unique PlayFab assigned ID of the user on whom the operation will be performed.
		FString PlayFabId;
		// The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it commonly follows the subject_verb_object pattern (e.g. player_logged_in).
		FString EventName;
		// [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
		OptionalTime Timestamp;
		// [optional] Custom data properties associated with the event. Each property consists of a name (string) and a value (JSON object).
		TMap<FString, FMultitypeVar> Body;
	
        FWriteServerPlayerEventRequest() :
			FPlayFabBaseModel(),
			PlayFabId(),
			EventName(),
			Timestamp(),
			Body()
			{}
		
		FWriteServerPlayerEventRequest(const FWriteServerPlayerEventRequest& src) :
			FPlayFabBaseModel(),
			PlayFabId(src.PlayFabId),
			EventName(src.EventName),
			Timestamp(src.Timestamp),
			Body(src.Body)
			{}
			
		FWriteServerPlayerEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteServerPlayerEventRequest()
        {
            readFromValue(obj);
        }
		
		~FWriteServerPlayerEventRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	
	struct PLAYFAB_API FWriteTitleEventRequest : public FPlayFabBaseModel
    {
		
		// The name of the event, within the namespace scoped to the title. The naming convention is up to the caller, but it commonly follows the subject_verb_object pattern (e.g. player_logged_in).
		FString EventName;
		// [optional] The time (in UTC) associated with this event. The value dafaults to the current time.
		OptionalTime Timestamp;
		// [optional] Custom event properties. Each property consists of a name (string) and a value (JSON object).
		TMap<FString, FMultitypeVar> Body;
	
        FWriteTitleEventRequest() :
			FPlayFabBaseModel(),
			EventName(),
			Timestamp(),
			Body()
			{}
		
		FWriteTitleEventRequest(const FWriteTitleEventRequest& src) :
			FPlayFabBaseModel(),
			EventName(src.EventName),
			Timestamp(src.Timestamp),
			Body(src.Body)
			{}
			
		FWriteTitleEventRequest(const TSharedPtr<FJsonObject>& obj) : FWriteTitleEventRequest()
        {
            readFromValue(obj);
        }
		
		~FWriteTitleEventRequest();
		
        void writeJSON(JsonWriter& writer) const override;
        bool readFromValue(const TSharedPtr<FJsonObject>& obj) override;
    };
	

}
}

